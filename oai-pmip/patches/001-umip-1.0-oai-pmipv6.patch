[PATCH] Support for PMIPv6 for UMIP 1.0

v20131230: Ported OAI patch to UMIP 1.0
           (Romain Kuntz <r.kuntz@ipflavors.com>)

Proxy Mobile IPv6 (PMIPv6) is a network-based mobility management
protocol for localized domains, which has been actively standardized
by IETF. OpenAirInterface Proxy Mobile IPv6 is an implementation of
the RFC 5213 developped by EURECOM. OAI PMIPv6 is opensource under
the GNU General Public License version 2.

Copyright 2013 OpenAir3 - Mobile Communication Department - EURECOM
               (Sophia-Antipolis, FRANCE)

This patch is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This patch is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this patch; if not, write to the Free Software Foundation,
Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.

diff -Nur umip/configure.ac umip-pmipv6/configure.ac
--- umip/configure.ac	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/configure.ac	2013-12-22 18:31:03.000000000 +0100
@@ -89,6 +89,43 @@
 	AC_MSG_ERROR([POSIX thread library required but not found.])
 ])
 
+AC_CHECK_LIB(pcap, pcap_compile, [], [
+	AC_MSG_ERROR([PCAP library required but not found.])
+])
+AC_CHECK_LIB(pcap, pcap_open_live, [], [
+	AC_MSG_ERROR([PCAP library required but not found.])
+])
+AC_CHECK_LIB(pcap, pcap_lookupnet, [], [
+	AC_MSG_ERROR([PCAP library required but not found.])
+])
+AC_CHECK_LIB(pcap, pcap_setfilter, [], [
+	AC_MSG_ERROR([PCAP library required but not found.])
+])
+AC_CHECK_LIB(pcap, pcap_next, [], [
+	AC_MSG_ERROR([PCAP library required but not found.])
+])
+
+AC_ARG_WITH(pmip-use-radius,
+			AC_HELP_STRING([--with-pmip-use-radius],[use radius auth]),
+			[ac_cv_pmip_use_radius=$withval], [ac_cv_pmip_use_radius=no])
+if test x$ac_cv_pmip_use_radius = xyes; then
+	AC_CHECK_LIB(freeradius-client, rc_read_config, [], [
+	AC_MSG_ERROR([freeradius-client library required but not found.])
+	])
+	AC_CHECK_LIB(freeradius-client, rc_read_dictionary, [], [
+	AC_MSG_ERROR([freeradius-client library required but not found.])
+	])
+	AC_CHECK_LIB(freeradius-client, rc_avpair_add, [], [
+	AC_MSG_ERROR([freeradius-client library required but not found.])
+	])
+	AC_CHECK_LIB(freeradius-client, rc_avpair_get, [], [
+	AC_MSG_ERROR([freeradius-client library required but not found.])
+	])
+	AC_CHECK_LIB(freeradius-client, rc_avpair_free, [], [
+	AC_MSG_ERROR([freeradius-client library required but not found.])
+	])
+fi
+
 AC_CHECK_LIB(netlink, rtnl_talk)
 AM_CONDITIONAL(LOCAL_NETLINK, test x$ac_cv_lib_netlink_rtnl_talk = xno)
 
@@ -109,6 +146,13 @@
 	       [ac_cv_use_builtin_crypto], [ac_cv_use_builtin_crypto=no])
 AM_CONDITIONAL(BUILTIN_CRYPTO, test x$ac_cv_lib_crypto_HMAC_Init = xno)
 
+if test ac_cv_pmip_use_radius = xyes; then
+        AC_DEFINE([USE_RADIUS], [1], [USE RADIUS AUTH])
+fi
+AC_CACHE_CHECK([whether to use RADIUS client library],
+			   [ac_cv_pmip_use_radius], [ac_cv_pmip_use_radius=no])
+AM_CONDITIONAL(USE_RADIUS, test x$ac_cv_pmip_use_radius = xyes)
+
 dnl Option --disable-debug
 AC_ARG_ENABLE(debug,
 	AC_HELP_STRING([--disable-debug],[disable debug messages and asserts]),
@@ -213,6 +257,7 @@
 
   Use built-in crypto: ............ $ac_cv_use_builtin_crypto
   Use OpenSSL crypto library: ..... $ac_cv_lib_crypto_HMAC_Init
+  Use RADIUS client library: ...... $ac_cv_pmip_use_radius
   Enable debugging mode: .......... $ac_cv_enable_debug
   Enable virtual debug terminal: .. $ac_cv_enable_vt
 
diff -Nur umip/extras/example-ha-lma.conf umip-pmipv6/extras/example-ha-lma.conf
--- umip/extras/example-ha-lma.conf	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/extras/example-ha-lma.conf	2013-12-22 18:31:42.000000000 +0100
@@ -0,0 +1,82 @@
+# This is an example of mip6d Local Mobility Anchor configuration file
+NodeConfig HA;
+
+## If set to > 0, will not detach from tty
+DebugLevel 10;
+
+## List of interfaces where we serve as Home Agent
+Interface "eth1";
+#Interface "eth0";
+
+##
+## IPsec configuration
+##
+
+UseMnHaIPsec enabled;
+
+## Key Management Mobility Capability
+#KeyMngMobCapability disabled;
+
+IPsecPolicySet {
+    HomeAgentAddress 3ffe:2620:6:1::1;
+
+    HomeAddress 3ffe:2620:6:1::1234/64;
+    HomeAddress 3ffe:2620:6:1::1235/64;
+
+    IPsecPolicy Mh UseESP;
+    IPsecPolicy TunnelMh UseESP;
+
+#   IPsecPolicy Mh UseESP 1 2;
+#   IPsecPolicy ICMP UseESP 5;
+#   IPsecPolicy TunnelMh UseESP 3 4;
+}
+
+DoRouteOptimizationCN           disabled;
+DoRouteOptimizationMN           disabled;
+UseMnHaIPsec                    disabled;
+KeyMngMobCapability             disabled;
+
+ProxyMipLma "LMA testbed n1" {
+    RFC5213TimestampBasedApproachInUse                   enabled;
+    RFC5213MobileNodeGeneratedTimestampInUse             disabled;
+    RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks      fe80::211:22ff:fe33:4455;
+    RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks      00:11:22:33:44:55;
+
+## Value in milliseconds
+    RFC5213MinDelayBeforeBCEDelete                       10000;
+
+## Value in milliseconds
+    RFC5213MaxDelayBeforeNewBCEAssign                    1500;
+
+## Value in milliseconds
+    RFC5213TimestampValidityWindow                       300;
+
+    LmaPmipNetworkAddress                                2001:100::1;
+    LmaPmipNetworkDevice                                 "eth0";
+    LmaCoreNetworkAddress                                2001:2::1;
+    LmaCoreNetworkDevice                                 "eth1";
+## Value in milliseconds
+    RetransmissionTimeOut                                500;
+    MaxMessageRetransmissions                            5;
+    TunnelingEnabled                                     enabled;
+##    DynamicTunnelingEnabled                              enabled;
+    DynamicTunnelingEnabled                              disabled;
+    MaxDelayBeforeDynamicTunnelingDelete                 60000;
+
+## MAG 1 (warning line defining MagAddressIngress must be before line defining MagAddressEgress)
+    MagAddressIngress                                    2001:1::1;
+    MagAddressEgress                                     2001:100::2;
+
+## MAG 2 (warning line defining MagAddressIngress must be before line defining MagAddressEgress)
+    MagAddressIngress                                    2001:1::2;
+    MagAddressEgress                                     2001:100::3;
+
+## MAG 3 (warning line defining MagAddressIngress must be before line defining MagAddressEgress)
+## MAG address must end this the last records containing 0::0 addresses
+
+    MagAddressIngress                                    0::0;
+    MagAddressEgress                                     0::0;
+
+    # MAG ... up to PMIP_MAX_MAGS = 64
+
+}
diff -Nur umip/extras/example-mag1.conf umip-pmipv6/extras/example-mag1.conf
--- umip/extras/example-mag1.conf	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/extras/example-mag1.conf	2013-12-22 18:32:03.000000000 +0100
@@ -0,0 +1,38 @@
+# This is an example of mip6d Mobile Access Gateway configuration file
+NodeConfig MAG;
+
+## If set to > 0, will not detach from tty
+DebugLevel 10;
+
+DoRouteOptimizationCN   disabled;
+DoRouteOptimizationMN   disabled;
+UseMnHaIPsec            disabled;
+KeyMngMobCapability     disabled;
+
+ProxyMipMag  "MAG1 testbed n1"{
+    RFC5213TimestampBasedApproachInUse                   enabled;
+    RFC5213MobileNodeGeneratedTimestampInUse             disabled;
+    RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks      fe80::211:22ff:fe33:4455;
+    RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks      00:11:22:33:44:55;
+    RFC5213EnableMAGLocalRouting                         enabled;
+    LmaPmipNetworkAddress                                2001:100::1;
+    MagAddressIngress                                    2001:1::1;
+    MagAddressEgress                                     2001:100::2;
+    MagDeviceIngress                                     "eth1";
+    MagDeviceEgress                                      "eth0";
+## Value in milliseconds
+    PBULifeTime                                          40000;
+## Value in milliseconds
+    RetransmissionTimeOut                                500;
+    MaxMessageRetransmissions                            5;
+    TunnelingEnabled                                     enabled;
+##    DynamicTunnelingEnabled                              enabled;
+    DynamicTunnelingEnabled                              disabled;
+    MaxDelayBeforeDynamicTunnelingDelete                 60000;
+    RadiusClientConfigFile                               "/usr/local/etc/radiusclient/radiusclient.conf";
+    RadiusPassword                                       "linux";
+    PcapSyslogAssociationGrepString                      "A wireless client is associated - ";
+    PcapSyslogDeAssociationGrepString                    "A wireless client is deauthenticated - ";
+}
+
+
diff -Nur umip/extras/example-mag2.conf umip-pmipv6/extras/example-mag2.conf
--- umip/extras/example-mag2.conf	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/extras/example-mag2.conf	2013-12-22 18:33:25.000000000 +0100
@@ -0,0 +1,38 @@
+# This is an example of mip6d Mobile Access Gateway configuration file
+NodeConfig MAG;
+
+## If set to > 0, will not detach from tty
+DebugLevel 10;
+
+DoRouteOptimizationCN   disabled;
+DoRouteOptimizationMN   disabled;
+UseMnHaIPsec            disabled;
+KeyMngMobCapability     disabled;
+
+ProxyMipMag  "MAG2 testbed n1"{
+    RFC5213TimestampBasedApproachInUse                   enabled;
+    RFC5213MobileNodeGeneratedTimestampInUse             disabled;
+    RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks      fe80::211:22ff:fe33:4455;
+    RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks      00:11:22:33:44:55;
+    RFC5213EnableMAGLocalRouting                         enabled;
+    LmaPmipNetworkAddress                                2001:100::1;
+    MagAddressIngress                                    2001:1::2;
+    MagAddressEgress                                     2001:100::3;
+    MagDeviceIngress                                     "eth1";
+    MagDeviceEgress                                      "eth0";
+## Value in milliseconds
+    PBULifeTime                                          40000;
+## Value in milliseconds
+    RetransmissionTimeOut                                500;
+    MaxMessageRetransmissions                            5;
+    TunnelingEnabled                                     enabled;
+##    DynamicTunnelingEnabled                            enabled;
+    DynamicTunnelingEnabled                              disabled;
+    MaxDelayBeforeDynamicTunnelingDelete                 60000;
+    RadiusClientConfigFile                               "/usr/local/etc/radiusclient/radiusclient.conf";
+    RadiusPassword                                       "linux";
+    PcapSyslogAssociationGrepString                      "[Wireless]ReAssociation Success:STA ";
+    PcapSyslogDeAssociationGrepString                    "[Wireless]Received Deauth:STA ";
+}
+
+
diff -Nur umip/extras/mac-mapping.auth umip-pmipv6/extras/mac-mapping.auth
--- umip/extras/mac-mapping.auth	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/extras/mac-mapping.auth	2013-12-22 18:33:54.000000000 +0100
@@ -0,0 +1,8 @@
+# This file is a configuration file for authorizing mobile nodes
+# to register to the PMIP testbed in case RADIUS is not configured
+# The format of an authorization for a mobile node is the following:
+# [IPv6 network address assigned to the mobile node (32 chars in hex formats)][one space character][16 chars in hex format for the mobile node MAC address]
+
+# MAPPING FOR DELL LAPTOP OLYMPIE
+20010100000450000000000000000000 0000d4bed91f6e59
+
diff -Nur umip/extras/UMIP0.4_LMA_UBUNTU.10.04.py umip-pmipv6/extras/UMIP0.4_LMA_UBUNTU.10.04.py
--- umip/extras/UMIP0.4_LMA_UBUNTU.10.04.py	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/extras/UMIP0.4_LMA_UBUNTU.10.04.py	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,174 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+import sys
+import os
+import subprocess
+import getopt
+
+from subprocess  import *
+from netaddr import *
+
+g_path = os.getcwd()
+g_path = os.path.dirname(sys.argv[0]) + "/.."
+g_path = os.path.abspath(g_path)
+
+try:
+    opts, args = getopt.getopt(sys.argv[1:], "prd", ["pcap=", "runversion=", "pmipdir=", "cfile="])
+except getopt.GetoptError, err:
+    # print help information and exit:
+    print str(err) # will print something like "option -a not recognized"
+    sys.exit(2)
+
+g_pcap = "no"
+g_run_version = "1"
+g_config_file = "example-ha-lma.conf"
+
+for o,p in opts:
+  if o in ('-p','--pcap'):
+     g_pcap = p
+  elif o in ['-r','--runversion']:
+     g_run_version = str(p)
+  elif o in ['-d','--pmipdir']:
+     g_path = p
+  elif o in ['-c','--cfile']:
+     g_config_file = p
+
+############################################################################################
+g_file_config=g_path+"/extras/"+g_config_file
+############################################################################################
+
+print "Config file is : " + g_file_config
+
+g_RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks = IPAddress('0::0')
+g_RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks = " "
+g_LmaAddress                                      = IPAddress('0::0')
+g_LmaPmipNetworkDevice                            = ""
+g_LmaCoreNetworkAddress                           = IPAddress('0::0')
+g_LmaCoreNetworkDevice                            = ""
+g_MagAddressIngress                               = []
+g_MagAddressEgress                                = []
+g_num_mags                                        = 0
+
+g_fhandle = open(g_file_config, 'r')
+g_fcontent = g_fhandle.read()
+g_fhandle.close()
+
+lines = g_fcontent.splitlines()
+for line in lines:
+    line = line.rstrip().lstrip()
+    line = line.rstrip(';')
+    split = line.split(' ')
+    element = split[-1]
+    element = element.strip('"')
+    if line.startswith("#"):
+        continue
+    if 'RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks' in line:
+        print line
+        g_RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks = IPAddress(element)
+
+    elif 'RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks' in line:
+        print line
+        g_RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks = element
+    elif 'LmaPmipNetworkAddress' in line:
+        print line
+        g_LmaAddress = IPAddress(element)
+    elif 'LmaPmipNetworkDevice' in line:
+        print line
+        g_LmaPmipNetworkDevice = element
+    elif 'LmaCoreNetworkAddress' in line:
+        print line
+        g_LmaCoreNetworkAddress = IPAddress(element)
+    elif 'LmaCoreNetworkDevice' in line:
+        print line
+        g_LmaCoreNetworkDevice = element
+    elif 'MagAddressIngress' in line:
+        print line
+        g_MagAddressIngress.append(IPAddress(element))
+    elif 'MagAddressEgress' in line:
+        print line
+        g_MagAddressEgress.append(IPAddress(element))
+
+for ip in g_MagAddressIngress:
+    if ip.format() != IPAddress('0::0').format():
+        command = "ip -6 route del " + ip.format() + "/64"
+        print command
+        os.system(command)
+        g_num_mags = g_num_mags + 1
+
+
+for i in range (1 , 255):
+    command = "ip -6 tunnel del ip6tnl" + str(i) + " >/dev/null 2>&1"
+    os.system(command)
+
+command = "ip -6 addr del " + g_LmaAddress.format() + "/64 dev " + g_LmaPmipNetworkDevice
+print command
+os.system(command)
+
+command = "rmmod ip6_tunnel"
+print command
+os.system(command)
+command = "rmmod tunnel6"
+print command
+os.system(command)
+
+
+
+command = "echo \"0\" > /proc/sys/net/ipv6/conf/all/accept_ra"
+print command
+os.system(command)
+command = "echo \"0\" > /proc/sys/net/ipv6/conf/" + g_LmaPmipNetworkDevice + "/accept_ra"
+print command
+os.system(command)
+command = "echo \"0\" > /proc/sys/net/ipv6/conf/" + g_LmaCoreNetworkDevice + "/accept_ra"
+print command
+os.system(command)
+command = "echo \"1\" > /proc/sys/net/ipv6/conf/all/forwarding"
+print command
+os.system(command)
+
+
+
+command = "ip -6 addr add " + g_LmaAddress.format() + "/64 dev " + g_LmaPmipNetworkDevice
+print command
+os.system(command)
+command = "ip -6 addr add " + g_LmaCoreNetworkAddress.format()+"/64 dev "+ g_LmaCoreNetworkDevice
+print command
+os.system(command)
+
+index = 0
+for ip_ingress in g_MagAddressIngress:
+    ip_egress = g_MagAddressEgress[index]
+    if ip_ingress.format() != IPAddress('0::0').format() and ip_egress.format() != IPAddress('0::0').format():
+        command = "ip -6 route add " + ip_ingress.format() + "/64 via " + ip_egress.format() + " dev " + g_LmaPmipNetworkDevice
+        print command
+        os.system(command)
+    index += 1
+
+
+command = "modprobe ip6_tunnel"
+print command
+os.system(command)
+command = "modprobe tunnel6"
+print command
+os.system(command)
+
+command = "pkill -9 mip6d"
+print command
+os.system(command)
+
+if g_pcap == "yes":
+	command = "xhost + ; export DISPLAY=:0.0 ; sync; wireshark -i "+g_LmaPmipNetworkDevice+" -k -n -w  "+ g_path + "/logs/lma2mags."+g_run_version+".pcap &"
+	value = os.system(command)
+	print value
+
+	command = "xhost + ; export DISPLAY=:0.0 ; sync; wireshark -i "+g_LmaCoreNetworkDevice+" -k -n -w  "+ g_path + "/logs/lma2cn."+g_run_version+".pcap  &"
+	value = os.system(command)
+	print value
+
+
+# LD_LIBRARY_PATH for freeradius libs
+command = 'export LD_LIBRARY_PATH=/usr/local/lib;/usr/local/sbin/mip6d -c ' + g_file_config
+print command
+subprocess.call(command, shell=True)
+
diff -Nur umip/extras/UMIP0.4_MAG_UBUNTU.10.04.py umip-pmipv6/extras/UMIP0.4_MAG_UBUNTU.10.04.py
--- umip/extras/UMIP0.4_MAG_UBUNTU.10.04.py	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/extras/UMIP0.4_MAG_UBUNTU.10.04.py	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,167 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+import sys
+import os
+import subprocess
+import getopt
+
+from subprocess  import *
+from netaddr import *
+
+g_path = os.getcwd()
+g_path = os.path.dirname(sys.argv[0]) + "/.."
+g_path = os.path.abspath(g_path)
+
+try:
+    opts, args = getopt.getopt(sys.argv[1:], "prdc", ["pcap=", "runversion=", "pmipdir=", "cfile="])
+except getopt.GetoptError, err:
+    # print help information and exit:
+    print str(err) # will print something like "option -a not recognized"
+    sys.exit(2)
+
+g_pcap = "no"
+g_run_version = "1"
+g_config_file = ""
+
+for o,p in opts:
+  if o in ('-p','--pcap'):
+     g_pcap = p
+  elif o in ['-r','--runversion']:
+     g_run_version = str(p)
+  elif o in ['-d','--pmipdir']:
+     g_path = p
+  elif o in ['-c','--cfile']:
+     g_config_file = str(p)
+
+############################################################################################
+g_file_config=g_path+"/extras/"+g_config_file
+############################################################################################
+
+print "Config file is : " + g_file_config
+
+
+g_RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks = IPAddress('0::0')
+g_RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks = " "
+g_LmaAddress                                      = IPAddress('0::0')
+g_MagAddressIngress                               = IPAddress('0::0')
+g_MagAddressEgress                                = IPAddress('0::0')
+g_MagDeviceIngress                                = " "
+g_MagDeviceEgress                                 = " "
+
+
+g_fhandle = open(g_file_config, 'r')
+g_fcontent = g_fhandle.read()
+g_fhandle.close()
+
+lines = g_fcontent.splitlines()
+for line in lines:
+    line = line.rstrip().lstrip()
+    line = line.rstrip(';')
+    split = line.split(' ')
+    element = split[-1]
+    element = element.strip('"')
+    if 'RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks' in line:
+        print line
+        g_RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks = IPAddress(element)
+
+    elif 'RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks' in line:
+        print line
+        g_RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks = element
+    elif 'LmaPmipNetworkAddress' in line:
+        print line
+        g_LmaAddress = IPAddress(element)
+    elif 'MagAddressIngress' in line:
+        print line
+        g_MagAddressIngress = IPAddress(element)
+    elif 'MagAddressEgress' in line:
+        print line
+        g_MagAddressEgress = IPAddress(element)
+    elif 'MagDeviceIngress' in line:
+        print line
+        g_MagDeviceIngress = element
+    elif 'MagDeviceEgress' in line:
+        print line
+        g_MagDeviceEgress = element
+
+command = "ifconfig " + g_MagDeviceIngress + " down"
+print command
+os.system(command)
+
+command = "macchanger -m " +  g_RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks + " " + g_MagDeviceIngress
+print command
+os.system(command)
+
+command = "ifconfig " + g_MagDeviceIngress + " up"
+print command
+os.system(command)
+
+command = "ip -6 addr del " + g_MagAddressEgress.format() + "/64 dev " + g_MagDeviceEgress + " > /dev/null 2>&1"
+print command
+os.system(command)
+
+command = "ip -6 addr del " + g_MagAddressIngress.format() + "/64 dev " + g_MagDeviceIngress + " > /dev/null 2>&1"
+print command
+os.system(command)
+
+
+for i in range (1 , 255):
+    command = "ip -6 tunnel del ip6tnl" + str(i) + " >/dev/null 2>&1"
+    os.system(command)
+
+command = "rmmod ip6_tunnel > /dev/null 2>&1"
+print command
+os.system(command)
+command = "rmmod tunnel6 > /dev/null 2>&1"
+print command
+os.system(command)
+
+command = "ip -6 addr add " + g_MagAddressEgress.format() + "/64 dev " + g_MagDeviceEgress
+print command
+os.system(command)
+
+command = "ip -6 addr add " + g_MagAddressIngress.format() + "/64 dev " + g_MagDeviceIngress
+print command
+os.system(command)
+
+command = "echo \"0\" > /proc/sys/net/ipv6/conf/all/accept_ra"
+print command
+os.system(command)
+command = "echo \"0\" > /proc/sys/net/ipv6/conf/"+g_MagDeviceIngress+"/accept_ra"
+print command
+os.system(command)
+command = "echo \"0\" > /proc/sys/net/ipv6/conf/"+g_MagDeviceEgress+"/accept_ra"
+print command
+os.system(command)
+command = "echo \"1\" > /proc/sys/net/ipv6/conf/all/forwarding"
+print command
+os.system(command)
+
+command = "ip -6 route add to default via " + g_LmaAddress.format() + " dev " + g_MagDeviceEgress
+print command
+os.system(command)
+
+command = "modprobe ip6_tunnel"
+print command
+os.system(command)
+command = "modprobe tunnel6"
+print command
+os.system(command)
+
+command = "pkill -9 mip6d > /dev/null 2>&1"
+print command
+os.system(command)
+
+if g_pcap == "yes":
+	command = "xhost +; export DISPLAY=:0.0; sync; wireshark -i "+g_MagDeviceEgress+" -k -n -w  "+ g_path + "/logs/mag12lma."+g_run_version+".pcap &"
+	value = os.system(command)
+	print value
+
+	command = "xhost +; export DISPLAY=:0.0; sync; wireshark -i "+g_MagDeviceIngress+" -k -n -w  "+ g_path + "/logs/mag12ap."+g_run_version+".pcap  &"
+	value = os.system(command)
+	print value
+
+# LD_LIBRARY_PATH for freeradius libs
+command = 'export LD_LIBRARY_PATH=/usr/local/lib;/usr/local/sbin/mip6d -c ' + g_file_config
+subprocess.call(command, shell=True)
+
diff -Nur umip/include/netinet/ip6mh.h umip-pmipv6/include/netinet/ip6mh.h
--- umip/include/netinet/ip6mh.h	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/include/netinet/ip6mh.h	2013-12-22 17:16:41.000000000 +0100
@@ -70,6 +70,7 @@
 #define IP6_MH_BU_KEYM		0x1000	/* Key management mobility */
 #define IP6_MH_BU_MAP		0x0800	/* HMIPv6 MAP Registration */
 #define IP6_MH_BU_MR		0x0400	/* NEMO MR Registration */
+#define IP6_MH_BU_PR		0x0200  /* Proxy Registration */
 #else				/* BYTE_ORDER == LITTLE_ENDIAN */
 #define IP6_MH_BU_ACK		0x0080	/* Request a binding ack */
 #define IP6_MH_BU_HOME		0x0040	/* Home Registration */
@@ -77,6 +78,7 @@
 #define IP6_MH_BU_KEYM		0x0010	/* Key management mobility */
 #define IP6_MH_BU_MAP		0x0008	/* HMIPv6 MAP Registration */
 #define IP6_MH_BU_MR		0x0004	/* NEMO MR Registration */
+#define IP6_MH_BU_PR		0x0002  /* Proxy Registration */
 #endif
 
 struct ip6_mh_binding_ack {
diff -Nur umip/man/mip6d.conf.tmpl umip-pmipv6/man/mip6d.conf.tmpl
--- umip/man/mip6d.conf.tmpl	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/man/mip6d.conf.tmpl	2013-12-22 17:21:19.000000000 +0100
@@ -1,12 +1,12 @@
 .\" $Id: mip6d.conf.tmpl 1.33 06/05/12 11:48:36+03:00 vnuorval@tcs.hut.fi $
-.TH mip6d.conf 5 "January 31, 2006" "" "Mobile IPv6 and NEMO Daemon Configuration"
+.TH mip6d.conf 5 "January 31, 2006" "" "Mobile IPv6, Proxy MIPv6 and NEMO Daemon Configuration"
 .SH NAME
-mip6d.conf \- UMIP Mobile IPv6 and NEMO Configuration file
+mip6d.conf \- UMIP Mobile IPv6, Proxy MIPv6 and NEMO Configuration file
 .SH SYNOPSIS
 .B %etc%/mip6d.conf
 .sp
 .SH DESCRIPTION
-UMIP Mobile IPv6 and NEMO daemon's configuration file
+UMIP Mobile IPv6, Proxy MIPv6 and NEMO daemon's configuration file
 .P
 Below is a list of currently supported configuration options. All
 configuration lines are terminated with a semicolon.  Sub-sections are
@@ -34,7 +34,7 @@
 
 
 .TP
-.BR "NodeConfig " "CN | HA | MN" ";"
+.BR "NodeConfig " "CN | HA | MN | MAG" ";"
 
 Indicates if the daemon should run in Correspondent Node, Home Agent or
 Mobile Node mode.
@@ -130,7 +130,7 @@
 .nf
 .BR "Interface " "name" " {"
 .BR "	MnIfPreference " "number" ";"
-.BR "	IfType " "CN | HA | MN" ";"
+.BR "	IfType " "CN | HA | MN | MAG" ";"
 .BR "	Tunnel " "boolean" ";"
 .B }
 .fi
@@ -307,6 +307,400 @@
 an unambiguous one-to-one mapping between IPsec policies and SAs.
 Otherwise the policies will just share a common SA.
 
+.SH LOCAL MOBILITY ANCHOR SPECIFIC OPTIONS
+
+The following definitions are ignored unless the node is configured as a LMA:
+
+.TP
+.nf
+.BR "ProxyMipLma " "configuration name " "{"
+.BR "   RFC5213TimestampBasedApproachInUse "              "enabled" ";"
+.BR "   RFC5213MobileNodeGeneratedTimestampInUse "        "disabled" ";"
+.BR "   RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks " "address" ";"
+.BR "   RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks " "MAC address" ";"
+.BR "   RFC5213MinDelayBeforeBCEDelete "                  "decimal" ";"
+.BR "   RFC5213MaxDelayBeforeNewBCEAssign "               "decimal" ";"
+.BR "   RFC5213TimestampValidityWindow "                  "decimal" ";"
+.BR "   LmaAddress "                                      "address" ";"
+.BR "   LmaPmipNetworkDevice "                            "network device" ";"
+.BR "   LmaCoreNetworkAddress "                           "address" ";"
+.BR "   LmaCoreNetworkDevice "                            "network device" ";"
+.BR "   RetransmissionTimeOut "                           "decimal" ";"
+.BR "   MaxMessageRetransmissions "                       "decimal" ";"
+.BR "   TunnelingEnabled "                                "enabled | disabled" ";"
+.BR "   DynamicTunnelingEnabled "                         "enabled | disabled" ";"
+ These 2 lines repeated for each declared MAG
+.BR "   MagAddressIngress "                               "address" ";"
+.BR "   MagAddressEgress "                                "address" ";"
+.BR "}"
+.fi
+
+
+Each
+.B ProxyMipLma
+definition has a name. This is the name (enclosed in double quotes)
+of the configuration used for the LMA, this will be used in future
+releases, but it has to be filled. All the ProxyMipLma specific
+definitions are detailed below:
+
+
+.TP
+.BR "RFC5213TimestampBasedApproachInUse " "enabled" ";"
+
+This flag indicates whether or not the timestamp-based approach
+for message ordering is in use in that Proxy Mobile IPv6 domain.
+When the value for this flag is set to enabled, all the mobile
+access gateways in that Proxy Mobile IPv6 domain MUST apply the
+timestamp-based considerations listed in Section 5.5 of RFC5213.
+When the value of this flag is set to disabled (NOT IMPLEMENTED),
+sequence-number-based considerations listed in Section 5.5 of
+RFC5213MUST be applied. The default value for this flag is set
+to value of enabled, indicating that the timestamp-based mechanism
+ is in use in that Proxy Mobile IPv6 domain.
+
+
+.TP
+.BR "RFC5213MobileNodeGeneratedTimestampInUse " "disabled" ";"
+
+This flag indicates whether or not the mobile-node-generated
+timestamp approach is in use in that Proxy Mobile IPv6 domain.
+When the value for this flag is set to enabled (NOT IMPLEMENTED),
+the local mobility anchors and mobile access gateways in that
+Proxy Mobile IPv6 domain MUST apply the mobile node generated
+timestamp considerations as specified in Section 5.5 of RFC5213.
+
+This flag is relevant only when timestamp-based approach is in
+use.  The value for this flag MUST NOT be set to value of enabled,
+if the value of the TimestampBasedApproachInUse flag is set to
+disabled.
+
+.TP
+.BR "RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks " "address" ";"
+
+This variable indicates the link-local address value that all the
+mobile access gateways SHOULD use on any of the access links
+shared with any of the mobile nodes in that Proxy Mobile IPv6
+domain.  If this variable is initialized to ALL_ZERO value, it
+implies the use of fixed link-local address mode is not enabled
+for that Proxy Mobile IPv6 domain.
+
+.TP
+.BR "RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks " "MAC address" ";"
+
+This variable indicates the link-layer address value that all the
+mobile access gateways SHOULD use on any of the access links
+shared with any of the mobile nodes in that Proxy Mobile IPv6
+domain.  For access technologies where there is no link-layer
+address, this variable MUST be initialized to ALL_ZERO value.
+
+.TP
+.BR "RFC5213MinDelayBeforeBCEDelete " "decimal" ";"
+
+This variable specifies the amount of time in milliseconds the
+local mobility anchor MUST wait before it deletes a Binding Cache
+entry of a mobile node, upon receiving a Proxy Binding Update
+message from a mobile access gateway with a lifetime value of 0.
+During this wait time, if the local mobility anchor receives a
+Proxy Binding Update for the same mobility binding, with a
+lifetime value greater than 0, then it must update the binding
+cache entry with the accepted binding values.  By the end of this
+wait-time, if the local mobility anchor did not receive any valid
+Proxy Binding Update message for that mobility binding, it MUST
+delete the Binding Cache entry.  This delay essentially ensures a
+mobile node's Binding Cache entry is not deleted too quickly and
+allows some time for the new mobile access gateway to complete the
+signaling for the mobile node.
+
+The default value for this variable is 10000 milliseconds.
+
+.TP
+.BR "LmaCoreNetworkDevice " "network device" ";"
+
+Device name of the network interface on LMA host connected to core network domain.
+
+.TP
+.BR "RFC5213MaxDelayBeforeNewBCEAssign " "decimal" ";"
+
+This variable specifies the amount of time in milliseconds the
+local mobility anchor MUST wait for the de-registration message
+for an existing mobility session before it decides to create a new
+mobility session.
+
+The default value for this variable is 1500 milliseconds.
+
+Note that there is a dependency between this value and the values
+used in the retransmission algorithm for Proxy Binding Updates.
+The retransmissions need to happen before
+MaxDelayBeforeNewBCEAssign runs out, as otherwise there are
+situations where a de-registration from a previous mobile access
+gateway may be lost, and the local mobility anchor creates,
+needlessly, a new mobility session and new prefixes for the mobile
+node.  However, this affects situations where there is no
+information from the lower layers about the type of a handoff or
+other parameters that can be used for identifying the mobility
+session.
+
+.TP
+.BR "RFC5213TimestampValidityWindow " "decimal" ";"
+
+This variable specifies the maximum amount of time difference in
+milliseconds between the timestamp in the received Proxy Binding
+Update message and the current time of day on the local mobility
+anchor, that is allowed by the local mobility anchor for the
+received message to be considered valid.
+
+The default value for this variable is 300 milliseconds.  This
+variable must be adjusted to suit the deployments.
+
+.TP
+.BR "LmaAddress " "address" ";"
+
+Address is an IPv6 address, it is the address of the interface
+connected to the same link where are connected MAGs egress interfaces.
+
+.TP
+.BR "LmaPmipNetworkDevice " "network device" ";"
+
+Device name of the network interface on LMA host connected to PMIP
+domain (MAG1, ... MAGn).
+
+.TP
+.BR "LmaCoreNetworkAddress " "address" ";"
+
+Address is an IPv6 address, it is the address of the interface
+connected to the core network.
+
+.TP
+.BR "LmaCoreNetworkDevice " "network device" ";"
+
+Device name of the network interface on LMA host connected to
+core network domain.
+
+.TP
+.BR "RetransmissionTimeOut " "decimal" ";"
+
+While waiting for a message response, indicates the number of milli-seconds
+the initial request will be delayed for retransmission
+
+.TP
+.BR "MaxMessageRetransmissions " "decimal" ";"
+
+While waiting for a message response, indicates the number of times
+the initial request will be transmitted.
+
+.TP
+.BR "TunnelingEnabled " "enabled | disabled" ";"
+
+Must be set to "enabled".
+
+.TP
+.BR "DynamicTunnelingEnabled " "enabled | disabled" ";"
+
+If enabled, then the creation (and deletion) of tunnel(s) between MAG(s) and LMA is on demand.
+
+.TP
+.BR "MagAddressIngress " "address" ";"
+
+Address is an IPv6 address, it is the address of the interface
+connected to the mobile network of a MAG.
+
+.TP
+.BR "MagAddressEgress " "address" ";"
+
+Address is an IPv6 address, it is the address of the interface
+connected to the PMIP network of a MAG.
+
+
+
+
+.SH MOBILE ACCESS GATEWAY SPECIFIC OPTIONS
+
+The following definitions are ignored unless the node is configured as a MAG:
+
+.TP
+.nf
+.BR "ProxyMipMag " "configuration name " "{"
+.BR "   RFC5213TimestampBasedApproachInUse "              "enabled" ";"
+.BR "   RFC5213MobileNodeGeneratedTimestampInUse "        "disabled" ";"
+.BR "   RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks " "address" ";"
+.BR "   RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks " "MAC address" ";"
+.BR "   RFC5213EnableMAGLocalRouting "                    "disabled" ";"
+.BR "   LmaAddress "                                      "address" ";"
+.BR "   MagAddressIngress "                               "address" ";"
+.BR "   MagAddressEgress "                                "address" ";"
+.BR "   MagDeviceIngress "                                "network device" ";"
+.BR "   MagDeviceEgress "                                 "network device" ";"
+.BR "   PBULifeTime "                                     "decimal" ";"
+.BR "   RetransmissionTimeOut "                           "decimal" ";"
+.BR "   MaxMessageRetransmissions "                       "decimal" ";"
+.BR "   TunnelingEnabled "                                "enabled | disabled" ";"
+.BR "   DynamicTunnelingEnabled "                         "enabled | disabled" ";"
+.BR "   RadiusClientConfigFile "                          "path" ";"
+.BR "   RadiusPassword "                                  "password" ";"
+.BR "   PcapSyslogAssociationGrepString "                 "string" ";"
+.BR "   PcapSyslogDeAssociationGrepString "               "string" ";"
+.BR "}"
+.fi
+
+Each
+.B ProxyMipMag
+definition has a name. This is the name (enclosed in double quotes)
+of the configuration used for the MAG, this will be used in future
+releases, but it has to be filled. All the ProxyMipMag specific
+definitions are detailed below:
+
+.TP
+.BR "RFC5213TimestampBasedApproachInUse " "enabled" ";"
+
+This flag indicates whether or not the timestamp-based approach
+for message ordering is in use in that Proxy Mobile IPv6 domain.
+When the value for this flag is set to enabled, all the mobile
+access gateways in that Proxy Mobile IPv6 domain MUST apply the
+timestamp-based considerations listed in Section 5.5 of RFC5213.
+When the value of this flag is set to disabled (NOT IMPLEMENTED),
+sequence-number-based considerations listed in Section 5.5 of
+RFC5213MUST be applied. The default value for this flag is set
+to value of enabled, indicating that the timestamp-based mechanism
+ is in use in that Proxy Mobile IPv6 domain.
+
+
+.TP
+.BR "RFC5213MobileNodeGeneratedTimestampInUse " "disabled" ";"
+
+This flag indicates whether or not the mobile-node-generated
+timestamp approach is in use in that Proxy Mobile IPv6 domain.
+When the value for this flag is set to enabled (NOT IMPLEMENTED),
+the local mobility anchors and mobile access gateways in that
+Proxy Mobile IPv6 domain MUST apply the mobile node generated
+timestamp considerations as specified in Section 5.5 of RFC5213.
+
+This flag is relevant only when timestamp-based approach is in
+use.  The value for this flag MUST NOT be set to value of enabled,
+if the value of the TimestampBasedApproachInUse flag is set to
+disabled.
+
+.TP
+.BR "RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks " "address" ";"
+
+This variable indicates the link-local address value that all the
+mobile access gateways SHOULD use on any of the access links
+shared with any of the mobile nodes in that Proxy Mobile IPv6
+domain.  If this variable is initialized to ALL_ZERO value, it
+implies the use of fixed link-local address mode is not enabled
+for that Proxy Mobile IPv6 domain.
+
+.TP
+.BR "RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks " "MAC address" ";"
+
+This variable indicates the link-layer address value that all the
+mobile access gateways SHOULD use on any of the access links
+shared with any of the mobile nodes in that Proxy Mobile IPv6
+domain.  For access technologies where there is no link-layer
+address, this variable MUST be initialized to ALL_ZERO value.
+
+.TP
+.BR "RFC5213EnableMAGLocalRouting " "disabled" ";"
+
+This flag indicates whether or not the mobile access gateway is
+allowed to enable local routing of the traffic exchanged between a
+visiting mobile node and a correspondent node that is locally
+connected to one of the interfaces of the mobile access gateway.
+The correspondent node can be another visiting mobile node as
+well, or a local fixed node.
+The default value for this flag is set to a value of disabled,
+indicating that the mobile access gateway MUST reverse tunnel all
+ the traffic to the mobile node's local mobility anchor.
+
+When the value of this flag is set to a value of enabled, the
+mobile access gateway MUST route the traffic locally.
+
+This aspect of local routing MAY be defined as policy on a per
+mobile basis and when present will take precedence over this flag.
+
+
+.TP
+.BR "LmaAddress " "address" ";"
+
+Address is an IPv6 address, it is the address of the interface
+connected to the same link where are connected MAGs egress interfaces.
+
+.TP
+.BR "MagAddressIngress " "address" ";"
+
+Address is an IPv6 address, it is the address of the MAG egress interface.
+(Connected to the mobile network side). This option must be included
+in a ProxyMipMag definition.
+
+.TP
+.BR "MagAddressEgress " "address" ";"
+
+Address is an IPv6 address, it is the address of the interface
+connected to the PMIP network.
+
+.TP
+.BR "MagDeviceIngress " "network device" ";"
+
+Device name (for example eth1) of the ingress network interface.
+
+.TP
+.BR "MagDeviceEgress " "network device" ";"
+
+Device name (for example eth0) of the Egress network interface.
+
+.TP
+.BR "PBULifeTime " "decimal" ";"
+
+Indicates to LMA how many milli-seconds the Binding is valid, it will
+have to be refreshed before the expiration of this value, otherwise
+the Binding will be deleted.
+
+.TP
+.BR "RetransmissionTimeOut " "decimal" ";"
+
+While waiting for a message response, indicates the number of milli-seconds
+the initial request will be delayed for retransmission.
+
+.TP
+.BR "MaxMessageRetransmissions " "decimal" ";"
+
+While waiting for a message response, indicates the number of times
+the initial request will be transmitted.
+
+.TP
+.BR "TunnelingEnabled " "enabled | disabled" ";"
+
+Must be set to "enabled".
+
+.TP
+.BR "DynamicTunnelingEnabled " "enabled | disabled" ";"
+
+Must be set to "disabled", dynamic tunneling will be fully implemented soon.
+
+.TP
+.BR "RadiusClientConfigFile " "path" ";"
+
+The path to the radius client config file.
+
+.TP
+.BR "RadiusPassword " "password" ";"
+
+Radius password for authenticating on the radius server.
+
+.TP
+.BR "PcapSyslogAssociationGrepString " "string" ";"
+
+String that should match the syslog message coming from an access point saying
+a mobile node has associated with the access point. The grep string should end
+just before the first MAC address string (for example 00:11:22:33:44:55).
+
+.TP
+.BR "PcapSyslogDeAssociationGrepString " "string" ";"
+
+String that should match the syslog message coming from an access point saying
+a mobile node has de-associated with the access point. The grep string should
+end just before the first MAC address string (for example 00:11:22:33:44:55).
+
+
 .SH HOME AGENT SPECIFIC OPTIONS
 
 The following definitions are ignored unless the node is configured as a HA:
diff -Nur umip/man/mip6d.tmpl umip-pmipv6/man/mip6d.tmpl
--- umip/man/mip6d.tmpl	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/man/mip6d.tmpl	2013-12-22 17:22:39.000000000 +0100
@@ -1,13 +1,13 @@
 .\" $Id: mip6d.tmpl 1.4 05/05/16 13:13:41+03:00 anttit@tcs.hut.fi $
-.TH mip6d 1 "May 16, 2005" "" "Mobile IPv6 and NEMO Daemon"
+.TH mip6d 1 "May 16, 2005" "" "Mobile IPv6, Proxy MIPv6 and NEMO Daemon"
 .SH NAME
-mip6d \- UMIP Mobile IPv6 and NEMO Basic Support protocol implementation
+mip6d \- UMIP Mobile IPv6, Proxy MIPv6 and NEMO Basic Support protocol implementation
 .SH SYNOPSIS
 .B mip6d [options]
 .sp
 .SH DESCRIPTION
 
-Mobile IPv6 and NEMO Basic Support implementation
+Mobile IPv6, Proxy MIPv6 and NEMO Basic Support implementation
 
 .SH OPTIONS
 .IP "\fB\-V, \-\-version\fP"
@@ -56,3 +56,5 @@
 Architecture
 .PP
 RFC3963: Network Mobility (NEMO) Basic Support Protocol
+.PP
+RFC5213: Proxy Mobile IPv6.
diff -Nur umip/src/conf.c umip-pmipv6/src/conf.c
--- umip/src/conf.c	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/conf.c	2013-12-22 18:16:22.000000000 +0100
@@ -41,6 +41,7 @@
 
 #include <netinet/in.h>
 #include <netinet/ip6mh.h>
+#include <arpa/inet.h>
 #include "defpath.h"
 #include "conf.h"
 #include "debug.h"
@@ -195,6 +196,7 @@
 
 static void conf_default(struct mip6_config *c)
 {
+	int i;
 	memset(c, 0, sizeof(*c));
 
 	/* Common options */
@@ -239,9 +241,70 @@
 	c->HaMaxBindingLife = MAX_BINDING_LIFETIME;
 	INIT_LIST_HEAD(&c->nemo_ha_served_prefixes);
 
+
+	/* PMIP global options */
+	c->RFC5213TimestampBasedApproachInUse = 1;
+	c->RFC5213MobileNodeGeneratedTimestampInUse = 1;
+	c->RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks = in6addr_any;
+	c->RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks = in6addr_any;
+	struct timespec lifetime_tunnels;
+	lifetime_tunnels.tv_sec  = 60;
+	lifetime_tunnels.tv_nsec = 0;
+	c->MaxDelayBeforeDynamicTunnelingDelete   = lifetime_tunnels; // 60000 milliseconds
+
+	/* PMIP LMA options */
+	struct timespec lifetime1;
+	lifetime1.tv_sec = 10;
+	lifetime1.tv_nsec = 0;
+	c->RFC5213MinDelayBeforeBCEDelete         = lifetime1; // 10000 milliseconds
+	struct timespec lifetime2;
+	lifetime2.tv_sec = 1;
+	lifetime2.tv_nsec = 500000000;
+	c->RFC5213MaxDelayBeforeNewBCEAssign      = lifetime2; // 1500 milliseconds
+	struct timespec lifetime3;
+	lifetime3.tv_sec = 0;
+	lifetime3.tv_nsec = 300000000;
+	c->RFC5213TimestampValidityWindow         = lifetime3; // 300 milliseconds
+
+
 	/* CN bindings */
 	c->DoRouteOptimizationCN = 1;
 	INIT_LIST_HEAD(&c->cn_binding_pol);
+
+	/* PMIP MAG options */
+	c->RFC5213EnableMAGLocalRouting = 0;
+	c->HomeNetworkPrefix             = in6addr_any;
+	c->NumMags                       = 0;
+	for (i = 0; i <  PMIP_MAX_MAGS; i++) {
+		c->MagAddressIngress[i]      = in6addr_loopback;
+		c->MagAddressEgress[i]       = in6addr_loopback;
+	}
+	c->MagDeviceIngress              = "";
+	c->MagDeviceEgress               = "";
+	c->LmaAddress                    = in6addr_loopback;
+	c->OurAddress                    = in6addr_loopback;
+	//Lifetime for PB entry
+	struct timespec lifetime4;
+	lifetime4.tv_sec  = 40;
+	lifetime4.tv_nsec = 0;
+	c->PBULifeTime    = lifetime4;
+	struct timespec lifetime5;
+	lifetime5.tv_sec  = 40;
+	lifetime5.tv_nsec = 0;
+	c->PBALifeTime    = lifetime5;
+	//Time for N_Retransmissions
+	struct timespec lifetime6;
+	lifetime6.tv_sec  = 1;
+	lifetime6.tv_nsec = 0;
+	c->RetransmissionTimeOut = lifetime6;
+	//Define the maximum # of message retransmissions.
+	int Max_rets = 5;
+	c->MaxMessageRetransmissions = Max_rets;
+	c->TunnelingEnabled          = 0;
+	c->DynamicTunnelingEnabled   = 0;
+	c->RadiusClientConfigFile    = "";
+	c->RadiusPassword            = "";
+
 }
 
 int conf_parse(struct mip6_config *c, int argc, char **argv)
@@ -282,7 +345,7 @@
 void conf_show(struct mip6_config *c)
 {
 	struct list_head *list;
-
+	int i;
 	/* Common options */
 	dbg("Configuration file = %s\n", c->config_file);
 #ifdef ENABLE_VT
@@ -388,6 +451,109 @@
 			    (acl->bind_policy == IP6_MH_BAS_ACCEPTED) ?
 			    "allow":"deny");
 		}
+
+		/* PMIPv6 LMA options */
+		dbg("RFC5213TimestampBasedApproachInUse = %s\n",
+			CONF_BOOL_STR(c->RFC5213TimestampBasedApproachInUse));
+		dbg("RFC5213MobileNodeGeneratedTimestampInUse = %s\n",
+			CONF_BOOL_STR(c->RFC5213MobileNodeGeneratedTimestampInUse));
+		dbg("RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks));
+		dbg("RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks));
+		dbg("RFC5213MinDelayBeforeBCEDelete = %u.%9u seconds\n",
+			c->RFC5213MinDelayBeforeBCEDelete.tv_sec,
+			c->RFC5213MinDelayBeforeBCEDelete.tv_nsec);
+		dbg("RFC5213MaxDelayBeforeNewBCEAssign = %u.%9u seconds\n",
+			c->RFC5213MaxDelayBeforeNewBCEAssign.tv_sec,
+			c->RFC5213MaxDelayBeforeNewBCEAssign.tv_nsec);
+		dbg("RFC5213TimestampValidityWindow = %u.%9u seconds\n",
+			c->RFC5213TimestampValidityWindow.tv_sec,
+			c->RFC5213TimestampValidityWindow.tv_nsec);
+
+		dbg("LmaPmipNetworkAddress = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->LmaAddress));
+		dbg("OurAddress = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->OurAddress));
+		dbg("HomeNetworkPrefix = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->HomeNetworkPrefix));
+		dbg("MaxMessageRetransmissions = %u\n",
+			c->MaxMessageRetransmissions);
+		dbg("TunnelingEnabled = %s\n",
+			CONF_BOOL_STR(c->TunnelingEnabled));
+		dbg("DynamicTunnelingEnabled = %s\n",
+			CONF_BOOL_STR(c->DynamicTunnelingEnabled));
+		dbg("MaxDelayBeforeDynamicTunnelingDelete = %u.%9u seconds\n",
+			c->MaxDelayBeforeDynamicTunnelingDelete.tv_sec,
+			c->MaxDelayBeforeDynamicTunnelingDelete.tv_nsec);
+
+		for (i = 0; i < c->NumMags; i++) {
+			dbg("MAG %d: \n", i);
+			dbg("- MagAddressIngress = %x:%x:%x:%x:%x:%x:%x:%x\n",
+				NIP6ADDR(&c->MagAddressIngress[i]));
+			dbg("- MagAddressEgress = %x:%x:%x:%x:%x:%x:%x:%x\n",
+				NIP6ADDR(&c->MagAddressEgress[i]));
+		}
+		break;
+
+		case MIP6_ENTITY_MAG:
+		/* PMIPv6 MAG options */
+		dbg("RFC5213TimestampBasedApproachInUse = %s\n",
+			CONF_BOOL_STR(c->RFC5213TimestampBasedApproachInUse));
+		dbg("RFC5213MobileNodeGeneratedTimestampInUse = %s\n",
+			CONF_BOOL_STR(c->RFC5213MobileNodeGeneratedTimestampInUse));
+		dbg("RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks));
+		dbg("RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks));
+		dbg("RFC5213EnableMAGLocalRouting = %s\n",
+			CONF_BOOL_STR(c->RFC5213EnableMAGLocalRouting));
+
+		dbg("MagAddressIngress = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->MagAddressIngress[0]));
+		dbg("MagAddressEgress = %x:%x:%x:%x:%x:%x:%x:%x\n", 
+			NIP6ADDR(&c->MagAddressEgress[0]));
+		dbg("MagDeviceIngress = %s\n",
+			(c->MagDeviceIngress ? c->MagDeviceIngress : "No device"));
+		dbg("MagDeviceEgress = %s\n",
+			(c->MagDeviceEgress ? c->MagDeviceEgress : "No device"));
+
+		dbg("PBULifeTime = %u.%9u seconds\n",
+			c->PBULifeTime.tv_sec,c->PBULifeTime.tv_nsec);
+		dbg("RetransmissionTimeOut = %u.%9u seconds\n",
+			c->RetransmissionTimeOut.tv_sec,
+			c->RetransmissionTimeOut.tv_nsec);
+
+		dbg("LmaPmipNetworkAddress = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->LmaAddress));
+		dbg("OurAddress = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->OurAddress));
+		dbg("HomeNetworkPrefix = %x:%x:%x:%x:%x:%x:%x:%x\n",
+			NIP6ADDR(&c->HomeNetworkPrefix));
+		dbg("MaxMessageRetransmissions = %u\n",
+			c->MaxMessageRetransmissions);
+		dbg("TunnelingEnabled = %s\n",
+			CONF_BOOL_STR(c->TunnelingEnabled));
+		dbg("DynamicTunnelingEnabled = %s\n",
+			CONF_BOOL_STR(c->DynamicTunnelingEnabled));
+		dbg("MaxDelayBeforeDynamicTunnelingDelete = %u.%9u seconds\n",
+			c->MaxDelayBeforeDynamicTunnelingDelete.tv_sec,
+			c->MaxDelayBeforeDynamicTunnelingDelete.tv_nsec);
+
+		dbg("RadiusClientConfigFile = %s\n",
+			(c->RadiusClientConfigFile ?
+			 c->RadiusClientConfigFile : "No Config file"));
+		dbg("RadiusPassword = %s\n",
+			(c->RadiusPassword ? c->RadiusPassword : "No password"));
+
+		dbg("PcapSyslogAssociationGrepString = %s\n",
+			(c->PcapSyslogAssociationGrepString ?
+			 c->PcapSyslogAssociationGrepString :
+			 "No syslog association grep string"));
+		dbg("PcapSyslogDeAssociationGrepString = %s\n",
+			(c->PcapSyslogDeAssociationGrepString ?
+			 c->PcapSyslogDeAssociationGrepString :
+			 "No syslog de-association grep string"));
 		break;
 
 		case MIP6_ENTITY_CN:
diff -Nur umip/src/conf.h umip-pmipv6/src/conf.h
--- umip/src/conf.h	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/conf.h	2013-12-22 18:17:38.000000000 +0100
@@ -65,6 +65,43 @@
 	/* CN options */
 	char DoRouteOptimizationCN;
 	struct list_head cn_binding_pol;
+
+	/* PMIP global options */
+	unsigned int    RFC5213TimestampBasedApproachInUse;
+	unsigned int    RFC5213MobileNodeGeneratedTimestampInUse;
+	struct in6_addr RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks;
+	struct in6_addr RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks;
+
+	/* PMIP LMA options */
+	struct timespec RFC5213MinDelayBeforeBCEDelete;
+	struct timespec RFC5213MaxDelayBeforeNewBCEAssign;
+	struct timespec RFC5213TimestampValidityWindow;
+
+	/* PMIP MAG options */
+	unsigned int    RFC5213EnableMAGLocalRouting;
+	struct in6_addr LmaAddress;                 // address of LMA, PMIP network side.
+	char*           LmaPmipNetworkDevice;       // PMIP LMA device, PMIP network side.
+	struct in6_addr LmaCoreNetworkAddress;      // address of LMA, core network side.
+	char*           LmaCoreNetworkDevice;       // PMIP LMA device, core network side.
+	unsigned int    NumMags;
+	#define PMIP_MAX_MAGS    64
+	struct in6_addr MagAddressIngress[PMIP_MAX_MAGS]; // ingress address of MAG.
+	struct in6_addr MagAddressEgress[PMIP_MAX_MAGS];  // egress address of MAG.
+	char*           MagDeviceIngress;           // ingress device.
+	char*           MagDeviceEgress;            // egress device.
+	struct in6_addr OurAddress;
+	struct in6_addr HomeNetworkPrefix;          // home network address common for domain!
+	struct timespec PBULifeTime;                // Life time of Proxy Binding Update.
+	struct timespec PBALifeTime;                // Life time MR side.
+	struct timespec RetransmissionTimeOut;      // Time-out before retransmission of a message.
+	int             MaxMessageRetransmissions;  //indicates the maximum number of message retransmissions
+	char            TunnelingEnabled;
+	char            DynamicTunnelingEnabled;
+	struct timespec MaxDelayBeforeDynamicTunnelingDelete;
+	char*           RadiusClientConfigFile;
+	char*           RadiusPassword;
+	char*           PcapSyslogAssociationGrepString;
+	char*           PcapSyslogDeAssociationGrepString;
 };
 
 struct net_iface {
@@ -84,6 +121,7 @@
 #define MIP6_ENTITY_CN 0
 #define MIP6_ENTITY_MN 1
 #define MIP6_ENTITY_HA 2
+#define MIP6_ENTITY_MAG 3
 
 static inline int is_cn(void)
 {
@@ -100,6 +138,12 @@
 	return conf.mip6_entity == MIP6_ENTITY_HA;
 }
 
+static inline int is_mag(void)
+{
+	return conf.mip6_entity == MIP6_ENTITY_MAG;
+}
+
+
 static inline int is_if_entity_set(struct net_iface *i)
 {
 	return i->mip6_if_entity != MIP6_ENTITY_NO;
@@ -125,6 +169,13 @@
 		(!is_if_entity_set(i) || i->mip6_if_entity == MIP6_ENTITY_HA));
 }
 
+
+static inline int is_if_mag(struct net_iface *i)
+{
+	return (is_mag() &&
+            (!is_if_entity_set(i) || i->mip6_if_entity == MIP6_ENTITY_MAG));
+}
+
 int conf_parse(struct mip6_config *c, int argc, char **argv);
 
 void conf_show(struct mip6_config *c);
diff -Nur umip/src/gram.y umip-pmipv6/src/gram.y
--- umip/src/gram.y	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/gram.y	2013-12-22 18:29:39.000000000 +0100
@@ -114,6 +114,7 @@
 %union {
 	char *string;
 	struct in6_addr addr;
+	struct in6_addr macaddr;
 	char bool;
 	unsigned int num;
 	unsigned int numpair[2];
@@ -122,6 +123,7 @@
 
 %token <string> QSTRING
 %token <addr>	ADDR
+%token <macaddr>	MACADDR
 %token <bool>	BOOL
 %token <num>	NUMBER
 %token <dec>	DECIMAL
@@ -201,6 +203,41 @@
 %token		HASERVEDPREFIX
 %token		MOBRTRUSEEXPLICITMODE
 %token		CNBINDINGPOLICYSET
+/* PMIP CONF ELEMENTS */
+%token		RFC5213TIMESTAMPBASEDAPPROACHINUSE;
+%token		RFC5213MOBILENODEGENERATEDTIMESTAMPINUSE;
+%token		RFC5213FIXEDMAGLINKLOCALADDRESSONALLACCESSLINKS;
+%token		RFC5213FIXEDMAGLINKLAYERADDRESSONALLACCESSLINKS;
+%token		RFC5213MINDELAYBEFOREBCEDELETE;
+%token		RFC5213MAXDELAYBEFORENEWBCEASSIGN;
+%token		RFC5213TIMESTAMPVALIDITYWINDOW;
+%token		RFC5213ENABLEMAGLOCALROUTING
+%token		MIP6LMA
+%token		MIP6MAG
+%token		PROXYMIPLMA
+%token		PROXYMIPMAG
+%token		ALLLMAMULTICASTADDRESS
+%token		LMAPMIPNETWORKADDRESS
+%token		LMAPMIPNETWORKDEVICE
+%token		LMACORENETWORKADDRESS
+%token		LMACORENETWORKDEVICE
+%token		MAGADDRESSINGRESS
+%token		MAGADDRESSEGRESS
+%token		MAGDEVICEINGRESS
+%token		MAGDEVICEEGRESS
+%token		OURADDRESS
+%token		HOMENETWORKPREFIX
+%token		PBULIFETIME
+%token		PBALIFETIME
+%token		RETRANSMISSIONTIMEOUT
+%token		MAXMESSAGERETRANSMISSIONS
+%token		TUNNELINGENABLED
+%token		DYNAMICTUNNELINGENABLED
+%token		MAXDELAYBEFOREDYNAMICTUNNELINGDELETE
+%token		RADIUSPASSWORD
+%token		RADIUSCLIENTCONFIGFILE
+%token		PCAPSYSLOGASSOCIATIONGREPSTRING
+%token		PCAPSYSLOGDEASSOCIATIONGREPSTRING
 
 %token		INV_TOKEN
 
@@ -390,11 +427,14 @@
 			conf_parsed->NoHomeReturn = $2;
 		}
 		| CNBINDINGPOLICYSET  '{' cnbindingpoldefs '}'
+		| PROXYMIPLMA proxymiplmadef
+		| PROXYMIPMAG proxymipmagdef
 		;
 
 mip6entity	: MIP6CN { $$ = MIP6_ENTITY_CN;	}
 		| MIP6MN { $$ = MIP6_ENTITY_MN; }
 		| MIP6HA { $$ = MIP6_ENTITY_HA; }
+		| MIP6MAG { $$ = MIP6_ENTITY_MAG; }
 		;
 
 ifacedef	: QSTRING ifacesub
@@ -846,4 +886,254 @@
 			list_add_tail(&p->list, &prefixes);
 		}
 		;
+
+proxymiplmadef	: QSTRING proxymiplmasub
+		{
+			conf_parsed->HomeNetworkPrefix = in6addr_any;
+			conf_parsed->OurAddress        = in6addr_loopback;
+		}
+		;
+
+proxymiplmasub	: '{' proxymiplmaopts '}'
+		| ';'
+		;
+
+proxymiplmaopts	: proxymiplmaopt
+		| proxymiplmaopts proxymiplmaopt
+		;
+
+proxymiplmaopt	: LMAPMIPNETWORKADDRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->LmaAddress, &$2, sizeof(struct in6_addr));
+		}
+		| LMAPMIPNETWORKDEVICE QSTRING ';'
+		{
+			conf_parsed->LmaPmipNetworkDevice = $2;
+		}
+                | LMACORENETWORKADDRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->LmaCoreNetworkAddress, &$2, sizeof(struct in6_addr));
+		}
+		| LMACORENETWORKDEVICE QSTRING ';'
+		{
+			conf_parsed->LmaCoreNetworkDevice = $2;
+		}
+		| RFC5213TIMESTAMPBASEDAPPROACHINUSE BOOL ';'
+		{
+			conf_parsed->RFC5213TimestampBasedApproachInUse = $2;
+		}
+		| RFC5213MOBILENODEGENERATEDTIMESTAMPINUSE BOOL ';'
+		{
+			conf_parsed->RFC5213MobileNodeGeneratedTimestampInUse = $2;
+		}
+		| RFC5213FIXEDMAGLINKLOCALADDRESSONALLACCESSLINKS ADDR ';'
+		{
+			memcpy(&conf_parsed->RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks, &$2, sizeof(struct in6_addr));
+		}
+		| RFC5213FIXEDMAGLINKLAYERADDRESSONALLACCESSLINKS  MACADDR ';'
+		{
+			memcpy(&conf_parsed->RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks, &$2, sizeof(struct in6_addr));
+		}
+		| RFC5213MINDELAYBEFOREBCEDELETE NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->RFC5213MinDelayBeforeBCEDelete = lifetime;
+		}
+		| RFC5213MAXDELAYBEFORENEWBCEASSIGN NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->RFC5213MaxDelayBeforeNewBCEAssign = lifetime;
+		}
+		| RFC5213TIMESTAMPVALIDITYWINDOW NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->RFC5213TimestampValidityWindow = lifetime;
+		}
+		| OURADDRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->OurAddress, &$2, sizeof(struct in6_addr));
+		}
+		| HOMENETWORKPREFIX ADDR ';'
+		{
+			memcpy(&conf_parsed->HomeNetworkPrefix, &$2, sizeof(struct in6_addr));
+		}
+		| TUNNELINGENABLED BOOL ';'
+		{
+			conf_parsed->TunnelingEnabled = $2;
+		}
+		| DYNAMICTUNNELINGENABLED BOOL ';'
+		{
+			conf_parsed->DynamicTunnelingEnabled = $2;
+		}
+		| MAXDELAYBEFOREDYNAMICTUNNELINGDELETE NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->MaxDelayBeforeDynamicTunnelingDelete = lifetime;
+		}
+		| PBULIFETIME NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->PBULifeTime = lifetime;
+		}
+		| PBALIFETIME NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->PBALifeTime = lifetime;
+		}
+		| RETRANSMISSIONTIMEOUT NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->RetransmissionTimeOut = lifetime;
+		}
+		| MAXMESSAGERETRANSMISSIONS NUMBER ';'
+		{
+			conf_parsed->MaxMessageRetransmissions = $2;
+		}
+		| MAGADDRESSINGRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->MagAddressIngress[conf_parsed->NumMags], &$2, sizeof(struct in6_addr));
+		}
+		| MAGADDRESSEGRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->MagAddressEgress[conf_parsed->NumMags], &$2, sizeof(struct in6_addr));
+			if (! IN6_IS_ADDR_UNSPECIFIED(&conf_parsed->MagAddressEgress[conf_parsed->NumMags])) {
+				conf_parsed->NumMags = conf_parsed->NumMags + 1;
+			}
+		}
+		;
+
+proxymipmagdef	: QSTRING proxymipmagsub
+		{
+			conf_parsed->HomeNetworkPrefix = in6addr_any;
+			conf_parsed->OurAddress        = in6addr_loopback;
+		}
+		;
+
+proxymipmagsub	: '{' proxymipmagopts '}'
+		| ';'
+		;
+
+proxymipmagopts	: proxymipmagopt
+		| proxymipmagopts proxymipmagopt
+		;
+
+proxymipmagopt	: LMAPMIPNETWORKADDRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->LmaAddress, &$2, sizeof(struct in6_addr));
+		}
+		| RFC5213TIMESTAMPBASEDAPPROACHINUSE BOOL ';'
+		{
+			conf_parsed->RFC5213TimestampBasedApproachInUse = $2;
+		}
+		| RFC5213MOBILENODEGENERATEDTIMESTAMPINUSE BOOL ';'
+		{
+			conf_parsed->RFC5213MobileNodeGeneratedTimestampInUse = $2;
+		}
+		| RFC5213FIXEDMAGLINKLOCALADDRESSONALLACCESSLINKS ADDR ';'
+		{
+			memcpy(&conf_parsed->RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks, &$2, sizeof(struct in6_addr));
+		}
+		| RFC5213FIXEDMAGLINKLAYERADDRESSONALLACCESSLINKS MACADDR ';'
+		{
+			memcpy(&conf_parsed->RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks, &$2, sizeof(struct in6_addr));
+		}
+		| RFC5213ENABLEMAGLOCALROUTING BOOL ';'
+		{
+			conf_parsed->RFC5213EnableMAGLocalRouting = $2;
+		}
+		| OURADDRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->OurAddress, &$2, sizeof(struct in6_addr));
+		}
+		| MAGADDRESSINGRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->MagAddressIngress[0], &$2, sizeof(struct in6_addr));
+		}
+		| MAGADDRESSEGRESS ADDR ';'
+		{
+			memcpy(&conf_parsed->MagAddressEgress[0], &$2, sizeof(struct in6_addr));
+		}
+		| MAGDEVICEINGRESS QSTRING ';'
+		{
+			conf_parsed->MagDeviceIngress = $2;
+		}
+		| MAGDEVICEEGRESS QSTRING ';'
+		{
+			conf_parsed->MagDeviceEgress = $2;
+		}
+		| HOMENETWORKPREFIX ADDR ';'
+		{
+			memcpy(&conf_parsed->HomeNetworkPrefix, &$2, sizeof(struct in6_addr));
+		}
+		| TUNNELINGENABLED BOOL ';'
+		{
+			conf_parsed->TunnelingEnabled = $2;
+		}
+		| DYNAMICTUNNELINGENABLED BOOL ';'
+		{
+			conf_parsed->DynamicTunnelingEnabled = $2;
+		}
+		| MAXDELAYBEFOREDYNAMICTUNNELINGDELETE NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->MaxDelayBeforeDynamicTunnelingDelete = lifetime;
+		}
+		| PBULIFETIME NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->PBULifeTime = lifetime;
+		}
+		| PBALIFETIME NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->PBALifeTime = lifetime;
+		}
+		| RETRANSMISSIONTIMEOUT NUMBER ';'
+		{
+			struct timespec lifetime;
+			lifetime.tv_sec = $2/1000;
+			lifetime.tv_nsec = ($2 % 1000)*1000000;
+			conf_parsed->RetransmissionTimeOut = lifetime;
+		}
+		| MAXMESSAGERETRANSMISSIONS NUMBER ';'
+		{
+			conf_parsed->MaxMessageRetransmissions = $2;
+		}
+		| RADIUSPASSWORD QSTRING ';'
+		{
+			conf_parsed->RadiusPassword = $2;
+		}
+		| RADIUSCLIENTCONFIGFILE QSTRING ';'
+		{
+			conf_parsed->RadiusClientConfigFile = $2;
+		}
+		| PCAPSYSLOGASSOCIATIONGREPSTRING QSTRING ';'
+		{
+			conf_parsed->PcapSyslogAssociationGrepString = $2;
+		}
+		| PCAPSYSLOGDEASSOCIATIONGREPSTRING QSTRING ';'
+		{
+			conf_parsed->PcapSyslogDeAssociationGrepString = $2;
+		}
+		;
 %%
diff -Nur umip/src/ha.c umip-pmipv6/src/ha.c
--- umip/src/ha.c	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/ha.c	2013-12-22 17:16:41.000000000 +0100
@@ -61,6 +61,9 @@
 #include "prefix.h"
 #include "statistics.h"
 
+#include "pmip_init.h"
+#include "pmip_handler.h"
+
 static pthread_mutex_t bu_worker_mutex;
 static volatile unsigned long bu_worker_count = 0;
 static pthread_cond_t cond;
@@ -1248,7 +1251,9 @@
 {
 	struct ip6_mh_binding_update *bu = (struct ip6_mh_binding_update *)mh;
 
-	if (bu->ip6mhbu_flags & IP6_MH_BU_HOME)
+	if (bu->ip6mhbu_flags & IP6_MH_BU_PR)
+		pmip_lma_recv_pbu(mh, len, in, iif);
+	else if (bu->ip6mhbu_flags & IP6_MH_BU_HOME)
 		(void)ha_recv_home_bu(mh, len, in, iif, 0);
 	else
 		(void)cn_recv_bu(mh, len, in, iif);
@@ -1286,11 +1291,13 @@
 	ha_discover_routers(); /* Let's gather RA */
 	ha_proxy_nd_init();
 	mh_handler_reg(IP6_MH_TYPE_BU, &ha_bu_handler);
+	pmip_lma_init();
 	return 0;
 }
 
 void ha_cleanup(void)
 {
+	pmip_cleanup();
 	mh_handler_dereg(IP6_MH_TYPE_BU, &ha_bu_handler);
 	ha_proxy_nd_cleanup();
 	icmp6_handler_dereg(ND_ROUTER_ADVERT, &ha_ra_handler);
diff -Nur umip/src/icmp6.c umip-pmipv6/src/icmp6.c
--- umip/src/icmp6.c	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/icmp6.c	2013-12-22 17:16:41.000000000 +0100
@@ -52,7 +52,9 @@
 	ICMP6_DRP = 6,
 	ICMP6_MPS = 7,
 	ICMP6_MPA = 8,
-	__ICMP6_SENTINEL = 9
+	ICMP6_NS  = 9,
+	ICMP6_RS  = 10,
+	__ICMP6_SENTINEL = 11
 };
 
 
@@ -64,7 +66,7 @@
 static pthread_rwlock_t handler_lock;
 static struct icmp6_handler *handlers[__ICMP6_SENTINEL + 1];
 
-static struct sock icmp6_sock;
+struct sock icmp6_sock;
 static pthread_t icmp6_listener;
 
 static inline int icmp6_type_map(uint8_t type)
@@ -86,6 +88,10 @@
 		return ICMP6_MPS;
 	case MIP_PREFIX_ADVERT:
 		return ICMP6_MPA;
+	case ND_NEIGHBOR_SOLICIT:
+		return ICMP6_NS;
+	case ND_ROUTER_SOLICIT:
+		return ICMP6_RS;
 	default:
 		return __ICMP6_SENTINEL;
 	}
@@ -234,6 +240,12 @@
 		ICMP6_FILTER_SETPASS(ICMP6_PARAM_PROB, &filter);
 	}
 
+	if (is_mag()) {
+		ICMP6_FILTER_SETPASS(ND_NEIGHBOR_SOLICIT, &filter);
+		ICMP6_FILTER_SETPASS(ND_NEIGHBOR_ADVERT, &filter);
+		ICMP6_FILTER_SETPASS(ND_ROUTER_SOLICIT, &filter);
+	}
+
 	if (setsockopt(icmp6_sock.fd, IPPROTO_ICMPV6, ICMP6_FILTER, 
 		       &filter, sizeof(struct icmp6_filter)) < 0)
 		return -1;
diff -Nur umip/src/main.c umip-pmipv6/src/main.c
--- umip/src/main.c	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/main.c	2013-12-22 17:16:41.000000000 +0100
@@ -60,6 +60,7 @@
 #endif
 #include "tunnelctl.h"
 #include "statistics.h"
+#include "pmip.h"
 
 static void sig_child(__attribute__ ((unused)) int unused)
 {
@@ -89,6 +90,7 @@
 	/* got SIGINT, cleanup and exit */
 	syslog(LOG_INFO, "terminated (SIGINT)");
 	dbg("got SIGINT, exiting\n");
+	pmip_cleanup();
 	debug_close();
 	pthread_exit(NULL);
 }
@@ -174,10 +176,11 @@
 	pthread_exit(NULL);
 }
 
-const char *entity_string[3] = {
+const char *entity_string[4] = {
 	"Correspondent Node",
 	"Mobile Node",
-	"Home Agent" };
+	"Home Agent-Local Mobility Anchor",
+	"Mobile Access Gateway"};
 
 int main(int argc, char **argv)
 {
@@ -256,12 +259,16 @@
 		goto xfrm_failed;
 	if (cn_init() < 0)
 		goto cn_failed;
-	if ((is_ha() || is_mn()) && tunnelctl_init() < 0)
+	if ((is_ha() || is_mn() ||  is_mag()) && tunnelctl_init() < 0)
 		goto tunnelctl_failed;
 	if (is_ha() && ha_init() < 0) 
-		goto ha_failed;
+		goto pmip_failed;
+		//goto ha_failed;
 	if (is_mn() && mn_init() < 0)
 		goto mn_failed;
+	if (is_mag() && pmip_mag_init() < 0)
+		goto pmip_failed;
+
 #ifdef ENABLE_VT
 	if (vt_start(conf.vt_hostname, conf.vt_service) < 0)
 		goto vt_start_failed;
@@ -277,6 +284,8 @@
 #endif
 	if (is_mn())
 		mn_cleanup();
+pmip_failed:
+	pmip_cleanup();
 mn_failed:
 	if (is_ha())
 		ha_cleanup();
diff -Nur umip/src/Makefile.am umip-pmipv6/src/Makefile.am
--- umip/src/Makefile.am	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/Makefile.am	2013-12-22 17:16:41.000000000 +0100
@@ -2,7 +2,7 @@
 ## Process this file with automake to produce Makefile.in
 
 AM_CFLAGS = -Wall -Wextra -Wpointer-arith -Wreturn-type -pedantic -std=gnu99
-AM_CPPFLAGS = -isystem $(top_srcdir)/include
+AM_CPPFLAGS = -isystem $(top_srcdir)/include -I../src -I./pmip -I/usr/local/include
 AM_YFLAGS = -d
 
 defpath.h: $(top_builddir)/config.h
@@ -49,7 +49,31 @@
 		proc_sys.c proc_sys.h \
 		prefix.c prefix.h \
 		ipsec.c ipsec.h \
-		statistics.h
+		statistics.h \
+		./pmip/pmip.h \
+		./pmip/pmip_cache.c \
+		./pmip/pmip_cache.h \
+		./pmip/pmip_config.h \
+		./pmip/pmip_consts.h \
+		./pmip/pmip_fsm.c \
+		./pmip/pmip_fsm.h \
+		./pmip/pmip_handler.c \
+		./pmip/pmip_handler.h \
+		./pmip/pmip_hnp_cache.c \
+		./pmip/pmip_hnp_cache.h \
+		./pmip/pmip_init.c \
+		./pmip/pmip_init.h \
+		./pmip/pmip_lma_proc.c \
+		./pmip/pmip_lma_proc.h \
+		./pmip/pmip_mag_proc.c \
+		./pmip/pmip_mag_proc.h \
+		./pmip/pmip_msgs.c \
+		./pmip/pmip_msgs.h \
+		./pmip/pmip_pcap.c \
+		./pmip/pmip_pcap.h \
+		./pmip/pmip_tunnel.c \
+		./pmip/pmip_tunnel.h \
+		./pmip/pmip_types.h
 
 if ENABLE_VT
 mip6d_SOURCES += vt.c vt.h
@@ -59,7 +83,11 @@
 mip6d_SOURCES += crypto.c crypto.h
 endif
 
-mip6d_LDADD = 
+mip6d_LDADD =  -lpcap
+if USE_RADIUS
+mip6d_LDADD += -lfreeradius-client
+AM_CFLAGS    += -DUSE_RADIUS
+endif
 
 if MISSING
 mip6d_LDADD += -L$(top_builddir)/libmissing -lmissing
diff -Nur umip/src/mh.c umip-pmipv6/src/mh.c
--- umip/src/mh.c	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/mh.c	2013-12-22 17:16:41.000000000 +0100
@@ -53,6 +53,7 @@
 #include "keygen.h"
 #include "prefix.h"
 #include "statistics.h"
+#include "pmip_types.h"
 
 #define MH_DEBUG_LEVEL 1
 
@@ -62,12 +63,7 @@
 #define MDBG(...)
 #endif
 
-struct sock {
-	pthread_mutex_t send_mutex;
-	int fd;
-};
-
-static struct sock mh_sock;
+struct sock mh_sock;
 
 /* Are duplicate options allowed */
 int mh_opts_dup_ok[] = {
diff -Nur umip/src/mh.h umip-pmipv6/src/mh.h
--- umip/src/mh.h	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/mh.h	2013-12-22 17:16:41.000000000 +0100
@@ -5,12 +5,20 @@
 
 #include <netinet/in.h>
 #include <netinet/ip6mh.h>
+#include "pmip_consts.h"
+
 
 #define MIP6_SEQ_GT(x,y) ((short int)(((uint16_t)(x)) - ((uint16_t)(y))) > 0)
 
 /* If new types or options appear, these should be updated. */
-#define IP6_MH_TYPE_MAX IP6_MH_TYPE_BERROR
-#define IP6_MHOPT_MAX IP6_MHOPT_MOB_NET_PRFX
+//For PMIP
+#define IP6_MH_TYPE_MAX IP6_MH_TYPE_PBRES
+#define IP6_MHOPT_MAX IP6_MHOPT_PMIP_MAX
+
+struct sock {
+    pthread_mutex_t send_mutex;
+    int fd;
+};
 
 struct in6_addr_bundle {
 	struct in6_addr *src;
diff -Nur umip/src/movement.h umip-pmipv6/src/movement.h
--- umip/src/movement.h	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/movement.h	2013-12-22 17:16:41.000000000 +0100
@@ -98,6 +98,8 @@
 	int ll_dad_unsafe;
 	int is_tunnel;
 	unsigned short type;
+	short hwalen;
+	uint8_t hwa[16];
 	int32_t devconf[DEVCONF_MAX];
 	int32_t app_solicit;
 	struct timespec reachable;
diff -Nur umip/src/pmip/docs/Doxyfile umip-pmipv6/src/pmip/docs/Doxyfile
--- umip/src/pmip/docs/Doxyfile	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/docs/Doxyfile	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,1554 @@
+# Doxyfile 1.6.3
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project
+#
+# All text after a hash (#) is considered a comment and will be ignored
+# The format is:
+#       TAG = value [value, ...]
+# For lists items can also be appended using:
+#       TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (" ")
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all
+# text before the first occurrence of this tag. Doxygen uses libiconv (or the
+# iconv built into libc) for the transcoding. See
+# http://www.gnu.org/software/libiconv for the list of possible encodings.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded
+# by quotes) that should identify the project.
+
+PROJECT_NAME           = OpenAirInterface-PMIP6D
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number.
+# This could be handy for archiving the generated documentation or
+# if some version control system is used.
+
+PROJECT_NUMBER         = V0.4.1
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
+# base path where the generated documentation will be put.
+# If a relative path is entered, it will be relative to the location
+# where doxygen was started. If left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = ./html
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create
+# 4096 sub-directories (in 2 levels) under the output directory of each output
+# format and will distribute the generated files over these directories.
+# Enabling this option can be useful when feeding doxygen a huge amount of
+# source files, where putting all generated files in the same directory would
+# otherwise cause performance problems for the file system.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# The default language is English, other supported languages are:
+# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
+# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,
+# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
+# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
+# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrilic, Slovak,
+# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will
+# include brief member descriptions after the members that are listed in
+# the file and class documentation (similar to JavaDoc).
+# Set to NO to disable this.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend
+# the brief description of a member or function before the detailed description.
+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator
+# that is used to form the text in various listings. Each string
+# in this list, if found as the leading text of the brief description, will be
+# stripped from the text and the result after processing the whole list, is
+# used as the annotated text. Otherwise, the brief description is used as-is.
+# If left blank, the following values are used ("$name" is automatically
+# replaced with the name of the entity): "The $name class" "The $name widget"
+# "The $name file" "is" "provides" "specifies" "contains"
+# "represents" "a" "an" "the"
+
+ABBREVIATE_BRIEF       =
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# Doxygen will generate a detailed section even if there is only a brief
+# description.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full
+# path before files name in the file list and in the header files. If set
+# to NO the shortest path that makes the file name unique will be used.
+
+FULL_PATH_NAMES        = NO
+
+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag
+# can be used to strip a user-defined part of the path. Stripping is
+# only done if one of the specified strings matches the left-hand part of
+# the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the
+# path to strip.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
+# the path mentioned in the documentation of a class, which tells
+# the reader which header file to include in order to use a class.
+# If left blank only the name of the header file containing the class
+# definition is used. Otherwise one should specify the include paths that
+# are normally passed to the compiler using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter
+# (but less readable) file names. This can be useful is your file systems
+# doesn't support long names like on DOS, Mac, or CD-ROM.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen
+# will interpret the first line (until the first dot) of a JavaDoc-style
+# comment as the brief description. If set to NO, the JavaDoc
+# comments will behave just like regular Qt-style comments
+# (thus requiring an explicit @brief command for a brief description.)
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then Doxygen will
+# interpret the first line (until the first dot) of a Qt-style
+# comment as the brief description. If set to NO, the comments
+# will behave just like regular Qt-style comments (thus requiring
+# an explicit \brief command for a brief description.)
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen
+# treat a multi-line C++ special comment block (i.e. a block of //! or ///
+# comments) as a brief description. This used to be the default behaviour.
+# The new default is to treat a multi-line C++ comment block as a detailed
+# description. Set this tag to YES if you prefer the old behaviour instead.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
+# member inherits the documentation from any documented member that it
+# re-implements.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce
+# a new page for each member. If set to NO, the documentation of a member will
+# be part of the file/class/namespace that contains it.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab.
+# Doxygen uses this value to replace tabs by spaces in code fragments.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that acts
+# as commands in the documentation. An alias has the form "name=value".
+# For example adding "sideeffect=\par Side Effects:\n" will allow you to
+# put the command \sideeffect (or @sideeffect) in the documentation, which
+# will result in a user-defined paragraph with heading "Side Effects:".
+# You can put \n's in the value part of an alias to insert newlines.
+
+ALIASES                =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
+# sources only. Doxygen will then generate output that is more tailored for C.
+# For instance, some of the names that are used will be different. The list
+# of all members will be omitted, etc.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java
+# sources only. Doxygen will then generate output that is more tailored for
+# Java. For instance, namespaces will be presented as packages, qualified
+# scopes will look different, etc.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources only. Doxygen will then generate output that is more tailored for
+# Fortran.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for
+# VHDL.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it parses.
+# With this tag you can assign which parser to use for a given extension.
+# Doxygen has a built-in mapping, but you can override or extend it using this tag.
+# The format is ext=language, where ext is a file extension, and language is one of
+# the parsers supported by doxygen: IDL, Java, Javascript, C#, C, C++, D, PHP,
+# Objective-C, Python, Fortran, VHDL, C, C++. For instance to make doxygen treat
+# .inc files as Fortran files (default is PHP), and .f files as C (default is Fortran),
+# use: inc=Fortran f=C. Note that for custom extensions you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should
+# set this tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.
+# func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.
+# Doxygen will parse them like normal C++ but will assume all classes use public
+# instead of private inheritance when no explicit protection keyword is present.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate getter
+# and setter methods for a property. Setting this option to YES (the default)
+# will make doxygen to replace the get and set methods by a property in the
+# documentation. This will only work if the methods are indeed getting or
+# setting a simple type. If this is not the case, or you want to show the
+# methods anyway, you should set this option to NO.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES, then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES (the default) to allow class member groups of
+# the same type (for instance a group of public functions) to be put as a
+# subgroup of that type (e.g. under the Public Functions section). Set it to
+# NO to prevent subgrouping. Alternatively, this can be done per class using
+# the \nosubgrouping command.
+
+SUBGROUPING            = YES
+
+# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum
+# is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically
+# be useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to
+# determine which symbols to keep in memory and which to flush to disk.
+# When the cache is full, less often used symbols will be written to disk.
+# For small to medium size projects (<1000 input files) the default value is
+# probably good enough. For larger projects a too small cache size can cause
+# doxygen to be busy swapping symbols to and from disk most of the time
+# causing a significant performance penality.
+# If the system has enough physical memory increasing the cache will improve the
+# performance by keeping more symbols in memory. Note that the value works on
+# a logarithmic scale so increasing the size by one will rougly double the
+# memory usage. The cache size is given by this formula:
+# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,
+# corresponding to a cache size of 2^16 = 65536 symbols
+
+SYMBOL_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+# documentation are documented, even if no documentation was available.
+# Private class members and static file members will be hidden unless
+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class
+# will be included in the documentation.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file
+# will be included in the documentation.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)
+# defined locally in source files will be included in the documentation.
+# If set to NO only classes defined in header files are included.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local
+# methods, which are defined in the implementation section but not in
+# the interface are included in the documentation.
+# If set to NO (the default) only methods in the interface are included.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base
+# name of the file that contains the anonymous namespace. By default
+# anonymous namespace are hidden.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
+# undocumented members of documented classes, files or namespaces.
+# If set to NO (the default) these members will be included in the
+# various overviews, but no documentation section is generated.
+# This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy.
+# If set to NO (the default) these classes will be included in the various
+# overviews. This option has no effect if EXTRACT_ALL is enabled.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all
+# friend (class|struct|union) declarations.
+# If set to NO (the default) these declarations will be included in the
+# documentation.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
+# documentation blocks found inside the body of a function.
+# If set to NO (the default) these blocks will be appended to the
+# function's detailed documentation block.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation
+# that is typed after a \internal command is included. If the tag is set
+# to NO (the default) then the documentation will be excluded.
+# Set it to YES to include the internal documentation.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate
+# file names in lower-case letters. If set to YES upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+
+CASE_SENSE_NAMES       = YES
+
+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
+# will show members with their full class and namespace scopes in the
+# documentation. If set to YES the scope will be hidden.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
+# will put a list of the files that are included by a file in the documentation
+# of that file.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen
+# will list include files with double quotes in the documentation
+# rather than with sharp brackets.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
+# is inserted in the documentation for inline members.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
+# will sort the (detailed) documentation of file and class members
+# alphabetically by member name. If set to NO the members will appear in
+# declaration order.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the
+# brief documentation of file, namespace and class members alphabetically
+# by member name. If set to NO (the default) the members will appear in
+# declaration order.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the (brief and detailed) documentation of class members so that constructors and destructors are listed first. If set to NO (the default) the constructors will appear in the respective orders defined by SORT_MEMBER_DOCS and SORT_BRIEF_DOCS. This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the
+# hierarchy of group names into alphabetical order. If set to NO (the default)
+# the group names will appear in their defined order.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be
+# sorted by fully-qualified names, including namespaces. If set to
+# NO (the default), the class list will be sorted only by class name,
+# not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the
+# alphabetical list.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or
+# disable (NO) the todo list. This list is created by putting \todo
+# commands in the documentation.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or
+# disable (NO) the test list. This list is created by putting \test
+# commands in the documentation.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or
+# disable (NO) the bug list. This list is created by putting \bug
+# commands in the documentation.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or
+# disable (NO) the deprecated list. This list is created by putting
+# \deprecated commands in the documentation.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional
+# documentation sections, marked by \if sectionname ... \endif.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines
+# the initial value of a variable or define consists of for it to appear in
+# the documentation. If the initializer consists of more lines than specified
+# here it will be hidden. Use a value of 0 to hide initializers completely.
+# The appearance of the initializer of individual variables and defines in the
+# documentation can be controlled using \showinitializer or \hideinitializer
+# command in the documentation regardless of this setting.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated
+# at the bottom of the documentation of classes and structs. If set to YES the
+# list will mention the files that were used to generate the documentation.
+
+SHOW_USED_FILES        = YES
+
+# If the sources in your project are distributed over multiple directories
+# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy
+# in the documentation. The default is NO.
+
+SHOW_DIRECTORIES       = NO
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page.
+# This will remove the Files entry from the Quick Index and from the
+# Folder Tree View (if specified). The default is YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the
+# Namespaces page.
+# This will remove the Namespaces entry from the Quick Index
+# and from the Folder Tree View (if specified). The default is YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command <command> <input-file>, where <command> is the value of
+# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
+# provided by doxygen. Whatever the program writes to standard output
+# is used as the file version. See the manual for examples.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed by
+# doxygen. The layout file controls the global structure of the generated output files
+# in an output format independent way. The create the layout file that represents
+# doxygen's defaults, run doxygen with the -l option. You can optionally specify a
+# file name after the option, if omitted DoxygenLayout.xml will be used as the name
+# of the layout file.
+
+LAYOUT_FILE            =
+
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated
+# by doxygen. Possible values are YES and NO. If left blank NO is used.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated by doxygen. Possible values are YES and NO. If left blank
+# NO is used.
+
+WARNINGS               = YES
+
+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will
+# automatically be disabled.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some
+# parameters in a documented function, or documenting parameters that
+# don't exist or using markup commands wrongly.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be abled to get warnings for
+# functions that are documented, but have no documentation for their parameters
+# or return value. If set to NO (the default) doxygen will only warn about
+# wrong or incomplete parameter documentation, but not about the absence of
+# documentation.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that
+# doxygen can produce. The string should contain the $file, $line, and $text
+# tags, which will be replaced by the file and line number from which the
+# warning originated and the warning text. Optionally the format may contain
+# $version, which will be replaced by the version of the file (if it could
+# be obtained via FILE_VERSION_FILTER)
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning
+# and error messages should be written. If left blank the output is written
+# to stderr.
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag can be used to specify the files and/or directories that contain
+# documented source files. You may enter file names like "myfile.cpp" or
+# directories like "/usr/src/myproject". Separate the files or directories
+# with spaces.
+
+INPUT                  = ./..
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
+# also the default input encoding. Doxygen uses libiconv (or the iconv built
+# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for
+# the list of possible encodings.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank the following patterns are tested:
+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx
+# *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.py *.f90
+
+FILE_PATTERNS          = *.h \
+                         RECURSIVE \
+                         = \
+                         NO
+
+# The RECURSIVE tag can be used to turn specify whether or not subdirectories
+# should be searched for input files as well. Possible values are YES and NO.
+# If left blank NO is used.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+
+EXCLUDE                =
+
+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or
+# directories that are symbolic links (a Unix filesystem feature) are excluded
+# from the input.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories. Note that the wildcards are matched
+# against the file with absolute path, so to exclude all test directories
+# for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or
+# directories that contain example code fragments that are included (see
+# the \include command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp
+# and *.h) to filter out the source-files in the directories. If left
+# blank all files are included.
+
+EXAMPLE_PATTERNS       =
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude
+# commands irrespective of the value of the RECURSIVE tag.
+# Possible values are YES and NO. If left blank NO is used.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or
+# directories that contain image that are included in the documentation (see
+# the \image command).
+
+IMAGE_PATH             = images/
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command <filter> <input-file>, where <filter>
+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
+# input file. Doxygen will then use the output that the filter program writes
+# to standard output.
+# If FILTER_PATTERNS is specified, this tag will be
+# ignored.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis.
+# Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match.
+# The filters are a list of the form:
+# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further
+# info on how filters are used. If FILTER_PATTERNS is empty, INPUT_FILTER
+# is applied to all files.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will be used to filter the input files when producing source
+# files to browse (i.e. when SOURCE_BROWSER is set to YES).
+
+FILTER_SOURCE_FILES    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will
+# be generated. Documented entities will be cross-referenced with these sources.
+# Note: To get rid of all source code in the generated output, make sure also
+# VERBATIM_HEADERS is set to NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body
+# of functions and classes directly in the documentation.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
+# doxygen to hide any special comment blocks from generated source code
+# fragments. Normal C and C++ comments will always remain visible.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES
+# then for each documented function all documented
+# functions referencing it will be listed.
+
+REFERENCED_BY_RELATION = YES
+
+# If the REFERENCES_RELATION tag is set to YES
+# then for each documented function all documented entities
+# called/used by that function will be listed.
+
+REFERENCES_RELATION    = YES
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)
+# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from
+# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will
+# link to the source code.
+# Otherwise they will link to the documentation.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code
+# will point to the HTML generated by the htags(1) tool instead of doxygen
+# built-in source browser. The htags tool is part of GNU's global source
+# tagging system (see http://www.gnu.org/software/global/global.html). You
+# will need version 4.8.6 or higher.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen
+# will generate a verbatim copy of the header file for each class for
+# which an include is specified. Set to NO to disable this.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
+# of all compounds will be generated. Enable this if the project
+# contains a lot of classes, structs, unions or interfaces.
+
+ALPHABETICAL_INDEX     = NO
+
+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
+# in which this list will be split (can be a number in the range [1..20])
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all
+# classes will be put under the same header in the alphabetical index.
+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that
+# should be ignored while generating the index headers.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will
+# generate HTML output.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `html' will be used as the default path.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for
+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank
+# doxygen will generate files with .html extension.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a personal HTML header for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard header.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a personal HTML footer for
+# each generated HTML page. If it is left blank doxygen will generate a
+# standard footer.
+
+HTML_FOOTER            = footer.html
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
+# style sheet that is used by each HTML page. It can be used to
+# fine-tune the look of the HTML output. If the tag is left blank doxygen
+# will generate a default style sheet. Note that doxygen will try to copy
+# the style sheet file to the HTML output directory, so don't put your own
+# stylesheet in the HTML output directory as well, or it will be erased!
+
+HTML_STYLESHEET        =
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting
+# this to NO can help when comparing the output of multiple runs.
+
+HTML_TIMESTAMP         = YES
+
+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,
+# files or namespaces will be aligned in HTML using tables. If set to
+# NO a bullet list will be used.
+
+HTML_ALIGN_MEMBERS     = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded. For this to work a browser that supports
+# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox
+# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files
+# will be generated that can be used as input for Apple's Xcode 3
+# integrated development environment, introduced with OSX 10.5 (Leopard).
+# To create a documentation set, doxygen will generate a Makefile in the
+# HTML output directory. Running make will produce the docset in that
+# directory and running "make install" will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find
+# it at startup.
+# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html for more information.
+
+GENERATE_DOCSET        = NO
+
+# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the
+# feed. A documentation feed provides an umbrella under which multiple
+# documentation sets from a single provider (such as a company or product suite)
+# can be grouped.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that
+# should uniquely identify the documentation set bundle. This should be a
+# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
+# will append .docset to the name.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# If the GENERATE_HTMLHELP tag is set to YES, additional index files
+# will be generated that can be used as input for tools like the
+# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)
+# of the generated HTML documentation.
+
+GENERATE_HTMLHELP      = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can
+# be used to specify the file name of the resulting .chm file. You
+# can add a path in front of the file if the result should not be
+# written to the html output directory.
+
+CHM_FILE               =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can
+# be used to specify the location (absolute path including file name) of
+# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
+# the HTML help compiler on the generated index.hhp.
+
+HHC_LOCATION           =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag
+# controls if a separate .chi index file is generated (YES) or that
+# it should be included in the master .chm file (NO).
+
+GENERATE_CHI           = NO
+
+# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING
+# is used to encode HtmlHelp index (hhk), content (hhc) and project file
+# content.
+
+CHM_INDEX_ENCODING     =
+
+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag
+# controls whether a binary table of contents is generated (YES) or a
+# normal table of contents (NO) in the .chm file.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members
+# to the contents of the HTML help documentation and to the tree view.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and QHP_VIRTUAL_FOLDER
+# are set, an additional index file will be generated that can be used as input for
+# Qt's qhelpgenerator to generate a Qt Compressed Help (.qch) of the generated
+# HTML documentation.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can
+# be used to specify the file name of the resulting .qch file.
+# The path specified is relative to the HTML output folder.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#namespace
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating
+# Qt Help Project output. For more information please see
+# http://doc.trolltech.com/qthelpproject.html#virtual-folders
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to add.
+# For more information please see
+# http://doc.trolltech.com/qthelpproject.html#custom-filters
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the custom filter to add.For more information please see
+# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">Qt Help Project / Custom Filters</a>.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this project's
+# filter section matches.
+# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">Qt Help Project / Filter Attributes</a>.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can
+# be used to specify the location of Qt's qhelpgenerator.
+# If non-empty doxygen will try to run qhelpgenerator on the generated
+# .qhp file.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files
+#  will be generated, which together with the HTML files, form an Eclipse help
+#  plugin. To install this plugin and make it available under the help contents
+# menu in Eclipse, the contents of the directory containing the HTML and XML
+# files needs to be copied into the plugins directory of eclipse. The name of
+# the directory within the plugins directory should be the same as
+# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before the help appears.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have
+# this name.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at
+# top of each HTML page. The value NO (the default) enables the index and
+# the value YES disables it.
+
+DISABLE_INDEX          = NO
+
+# This tag can be used to set the number of enum values (range [1..20])
+# that doxygen will group on one line in the generated HTML documentation.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information.
+# If the tag value is set to YES, a side panel will be generated
+# containing a tree-like index structure (just like the one that
+# is generated for HTML Help). For this to work a browser that supports
+# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).
+# Windows users are probably better off using the HTML help feature.
+
+GENERATE_TREEVIEW      = YES
+
+# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories,
+# and Class Hierarchy pages using a tree view instead of an ordered list.
+
+USE_INLINE_TREES       = NO
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be
+# used to set the initial width (in pixels) of the frame in which the tree
+# is shown.
+
+TREEVIEW_WIDTH         = 250
+
+# Use this tag to change the font size of Latex formulas included
+# as images in the HTML documentation. The default is 10. Note that
+# when you change the font size after a successful doxygen run you need
+# to manually remove any form_*.png images from the HTML output directory
+# to force them to be regenerated.
+
+FORMULA_FONTSIZE       = 10
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for the HTML output. The underlying search engine uses javascript
+# and DHTML and should work on any modern browser. Note that when using HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET) there is already a search function so this one should
+# typically be disabled. For large projects the javascript based search engine
+# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.
+
+SEARCHENGINE           = NO
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be implemented using a PHP enabled web server instead of at the web client using Javascript. Doxygen will generate the search PHP script and index
+# file to put on the web server. The advantage of the server based approach is that it scales better to large projects and allows full text search. The disadvances is that it is more difficult to setup
+# and does not have live searching capabilities.
+
+SERVER_BASED_SEARCH    = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will
+# generate Latex output.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `latex' will be used as the default path.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked. If left blank `latex' will be used as the default command name.
+# Note that when enabling USE_PDFLATEX this option is only used for
+# generating bitmaps for formulas in the HTML output, but not in the
+# Makefile that is written to the output directory.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to
+# generate index for LaTeX. If left blank `makeindex' will be used as the
+# default command name.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact
+# LaTeX documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used
+# by the printer. Possible values are: a4, a4wide, letter, legal and
+# executive. If left blank a4wide will be used.
+
+PAPER_TYPE             = a4wide
+
+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX
+# packages that should be included in the LaTeX output.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for
+# the generated latex document. The header should contain everything until
+# the first chapter. If it is left blank doxygen will generate a
+# standard header. Notice: only use this tag if you know what you are doing!
+
+LATEX_HEADER           =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
+# is prepared for conversion to pdf (using ps2pdf). The pdf file will
+# contain links (just like the HTML output) instead of page references
+# This makes the output suitable for online browsing using a pdf viewer.
+
+PDF_HYPERLINKS         = NO
+
+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of
+# plain latex in the generated Makefile. Set this option to YES to get a
+# higher quality PDF documentation.
+
+USE_PDFLATEX           = NO
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
+# command to the generated LaTeX files. This will instruct LaTeX to keep
+# running if errors occur, instead of asking the user for help.
+# This option is also used when generating formulas in HTML.
+
+LATEX_BATCHMODE        = NO
+
+# If LATEX_HIDE_INDICES is set to YES then doxygen will not
+# include the index chapters (such as File Index, Compound Index, etc.)
+# in the output.
+
+LATEX_HIDE_INDICES     = NO
+
+# If LATEX_SOURCE_CODE is set to YES then doxygen will include source code with syntax highlighting in the LaTeX output. Note that which sources are shown also depends on other settings such as SOURCE_BROWSER.
+
+LATEX_SOURCE_CODE      = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
+# The RTF output is optimized for Word 97 and may not look very pretty with
+# other RTF readers or editors.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `rtf' will be used as the default path.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact
+# RTF documents. This may be useful for small projects and may help to
+# save some trees in general.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
+# will contain hyperlink fields. The RTF file will
+# contain links (just like the HTML output) instead of page references.
+# This makes the output suitable for online browsing using WORD or other
+# programs which support those fields.
+# Note: wordpad (write) and others do not support links.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's
+# config file, i.e. a series of assignments. You only have to provide
+# replacements, missing definitions are set to their default value.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an rtf document.
+# Syntax is similar to doxygen's config file.
+
+RTF_EXTENSIONS_FILE    =
+
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will
+# generate man pages
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `man' will be used as the default path.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to
+# the generated man pages (default is the subroutine's section .3)
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and Doxygen generates man output,
+# then it will generate one additional man file for each entity
+# documented in the real man page(s). These additional files
+# only source the real man page, but without them the man command
+# would be unable to find the correct page. The default is NO.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES Doxygen will
+# generate an XML file that captures the structure of
+# the code including all documentation.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be
+# put in front of it. If left blank `xml' will be used as the default path.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify an XML schema,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_SCHEMA             =
+
+# The XML_DTD tag can be used to specify an XML DTD,
+# which can be used by a validating XML parser to check the
+# syntax of the XML files.
+
+XML_DTD                =
+
+# If the XML_PROGRAMLISTING tag is set to YES Doxygen will
+# dump the program listings (including syntax highlighting
+# and cross-referencing information) to the XML output. Note that
+# enabling this will significantly increase the size of the XML output.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will
+# generate an AutoGen Definitions (see autogen.sf.net) file
+# that captures the structure of the code including all
+# documentation. Note that this feature is still experimental
+# and incomplete at the moment.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES Doxygen will
+# generate a Perl module file that captures the structure of
+# the code including all documentation. Note that this
+# feature is still experimental and incomplete at the
+# moment.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES Doxygen will generate
+# the necessary Makefile rules, Perl scripts and LaTeX code to be able
+# to generate PDF and DVI output from the Perl module output.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be
+# nicely formatted so it can be parsed by a human reader.
+# This is useful
+# if you want to understand what is going on.
+# On the other hand, if this
+# tag is set to NO the size of the Perl module output will be much smaller
+# and Perl will parse it just the same.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file
+# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.
+# This is useful so different doxyrules.make files included by the same
+# Makefile don't overwrite each other's variables.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will
+# evaluate all C-preprocessor directives found in the sources and include
+# files.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro
+# names in the source code. If set to NO (the default) only conditional
+# compilation will be performed. Macro expansion can be done in a controlled
+# way by setting EXPAND_ONLY_PREDEF to YES.
+#LG WAS NO
+MACRO_EXPANSION        = YES
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
+# then the macro expansion is limited to the macros specified with the
+# PREDEFINED and EXPAND_AS_DEFINED tags.
+#LG WAS NO
+EXPAND_ONLY_PREDEF     = YES
+
+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files
+# in the INCLUDE_PATH (see below) will be search if a #include is found.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by
+# the preprocessor.
+
+INCLUDE_PATH           = ..
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will
+# be used.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that
+# are defined before the preprocessor is started (similar to the -D option of
+# gcc). The argument of the tag is a list of macros of the form: name
+# or name=definition (no spaces). If the definition and the = are
+# omitted =1 is assumed. To prevent a macro definition from being
+# undefined via #undef or recursively expanded use the := operator
+# instead of the = operator.
+
+PREDEFINED             = PMIP=1 PMIP_CACHE_C=1 PMIP_FSM_C=1 PMIP_HANDLER_C=1 PMIP_HNP_CACHE_C=1  PMIP_INIT_C=1 PMIP_LMA_PROC_C=1 PMIP_MAG_PROC_C=1 PMIP_MSGS_C=1 PMIP_PCAP_C=1 PMIP_TUNNEL_C=1
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then
+# this tag can be used to specify a list of macro names that should be expanded.
+# The macro definition that is found in the sources will be used.
+# Use the PREDEFINED tag if you want to use a different macro definition.
+
+EXPAND_AS_DEFINED      = private_pmip_cache protected_pmip_cache public_pmip_cache private_pmip_fsm protected_pmip_fsm public_pmip_fsm private_pmip_handler protected_pmip_handler public_pmip_handler private_pmip_hnp_cache protected_pmip_hnp_cache public_pmip_hnp_cache private_pmip_init protected_pmip_init public_pmip_init private_pmip_lma_proc protected_pmip_lma_proc public_pmip_lma_proc private_pmip_mag_proc protected_pmip_mag_proc public_pmip_mag_proc private_pmip_msgs protected_pmip_msgs public_pmip_msgs private_pmip_pcap protected_pmip_pcap public_pmip_pcap private_pmip_tunnel protected_pmip_tunnel public_pmip_tunnel
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then
+# doxygen's preprocessor will remove all function-like macros that are alone
+# on a line, have an all uppercase name, and do not end with a semicolon. Such
+# function macros are typically used for boiler-plate code, and will confuse
+# the parser if not removed.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES option can be used to specify one or more tagfiles.
+# Optionally an initial location of the external documentation
+# can be added for each tagfile. The format of a tag file without
+# this location is as follows:
+#
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+#
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where "loc1" and "loc2" can be relative or absolute paths or
+# URLs. If a location is present for each tag, the installdox tool
+# does not have to be run to correct the links.
+# Note that each tag file must have a unique name
+# (where the name does NOT include the path)
+# If a tag file is not located in the directory in which doxygen
+# is run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create
+# a tag file that is based on the input files it reads.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES all external classes will be listed
+# in the class index. If set to NO only the inherited external classes
+# will be listed.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will
+# be listed.
+
+EXTERNAL_GROUPS        = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of `which perl').
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will
+# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base
+# or super classes. Setting the tag to NO turns the diagrams off. Note that
+# this option is superseded by the HAVE_DOT option below. This is only a
+# fallback. It is recommended to install and use dot, since it yields more
+# powerful graphs.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see
+# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# If set to YES, the inheritance and collaboration graphs will hide
+# inheritance and usage relations if the target is undocumented
+# or is not a class.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz, a graph visualization
+# toolkit from AT&T and Lucent Bell Labs. The other options in this section
+# have no effect if this option is set to NO (the default)
+
+HAVE_DOT               = NO
+
+# By default doxygen will write a font called FreeSans.ttf to the output
+# directory and reference it in all dot files that doxygen generates. This
+# font does not include all possible unicode characters however, so when you need
+# these (or just want a differently looking font) you can specify the font name
+# using DOT_FONTNAME. You need need to make sure dot is able to find the font,
+# which can be done by putting it in a standard location or by setting the
+# DOTFONTPATH environment variable or by setting DOT_FONTPATH to the directory
+# containing the font.
+
+DOT_FONTNAME           = FreeSans
+
+# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.
+# The default size is 10pt.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the output directory to look for the
+# FreeSans.ttf font (which doxygen will put there itself). If you specify a
+# different font using DOT_FONTNAME you can set the path where dot
+# can find it using this tag.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect inheritance relations. Setting this tag to YES will force the
+# the CLASS_DIAGRAMS tag to NO.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for each documented class showing the direct and
+# indirect implementation dependencies (inheritance, containment, and
+# class references variables) of the class with other documented classes.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen
+# will generate a graph for groups, showing the direct groups dependencies
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+
+UML_LOOK               = NO
+
+# If set to YES, the inheritance and collaboration graphs will show the
+# relations between templates and their instances.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT
+# tags are set to YES then doxygen will generate a graph for each documented
+# file showing the direct and indirect include dependencies of the file with
+# other documented files.
+
+INCLUDE_GRAPH          = YES
+
+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and
+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each
+# documented header file showing the documented files that directly or
+# indirectly include this file.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH and HAVE_DOT options are set to YES then
+# doxygen will generate a call dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable call graphs
+# for selected functions only using the \callgraph command.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then
+# doxygen will generate a caller dependency graph for every global function
+# or class method. Note that enabling this option will significantly increase
+# the time of a run. So in most cases it will be better to enable caller
+# graphs for selected functions only using the \callergraph command.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
+# will graphical hierarchy of all classes instead of a textual one.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES
+# then doxygen will show the dependencies a directory has on other directories
+# in a graphical way. The dependency relations are determined by the #include
+# relations between the files in the directories.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. Possible values are png, jpg, or gif
+# If left blank png will be used.
+
+DOT_IMAGE_FORMAT       = png
+
+# The tag DOT_PATH can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+
+DOT_PATH               = /usr/bin/dot
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the
+# \dotfile command).
+
+DOTFILE_DIRS           =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of
+# nodes that will be shown in the graph. If the number of nodes in a graph
+# becomes larger than this value, doxygen will truncate the graph, which is
+# visualized by representing a node as a red box. Note that doxygen if the
+# number of direct children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note
+# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the
+# graphs generated by dot. A depth value of 3 means that only nodes reachable
+# from the root by following a path via at most 3 edges will be shown. Nodes
+# that lay further from the root node will be omitted. Note that setting this
+# option to 1 or 2 may greatly reduce the computation time needed for large
+# code bases. Also note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not
+# seem to support this out of the box. Warning: Depending on the platform used,
+# enabling this option may lead to badly anti-aliased labels on the edges of
+# a graph (i.e. they become hard to read).
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10)
+# support this, this feature is disabled by default.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will
+# generate a legend page explaining the meaning of the various boxes and
+# arrows in the dot generated graphs.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will
+# remove the intermediate dot files that are used to generate
+# the various graphs.
+
+DOT_CLEANUP            = YES
diff -Nur umip/src/pmip/docs/footer.html umip-pmipv6/src/pmip/docs/footer.html
--- umip/src/pmip/docs/footer.html	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/docs/footer.html	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,16 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<!--
+<html xml:lang="en">
+<head>
+<title> </title>
+</head>
+
+<body>-->
+&nbsp;
+&nbsp;
+<DIV ALIGN=CENTER>
+<img alt="EURECOM - PMIP6D" src="http://mmsp01.eurecom.fr/EURECOM_logo.gif" height="90" width="270" />
+</DIV>
+</body>
+
+</html>
diff -Nur umip/src/pmip/pmip_cache.c umip-pmipv6/src/pmip/pmip_cache.c
--- umip/src/pmip/pmip_cache.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_cache.c	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,327 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_cache.c
+* \brief PMIP binding cache functions
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+#define PMIP
+#define PMIP_CACHE_C
+#ifdef HAVE_CONFIG_H
+#	include <config.h>
+#endif
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_cache.h"
+#include "pmip_handler.h"
+//---------------------------------------------------------------------------------------------------------------------
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//---------------------------------------------------------------------------------------------------------------------
+static struct hash      g_pmip_hash;
+static int              g_pmip_cache_count = 0;
+//---------------------------------------------------------------------------------------------------------------------
+int get_pmip_cache_count(int type)
+{
+    if (type == BCE_PMIP || type == BCE_TEMP) {
+        return g_pmip_cache_count;
+    }
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void dump_pbce(void *bce, void *os)
+{
+    pmip_entry_t *e = (pmip_entry_t *) bce;
+    FILE *out = (FILE *) os;
+    fprintf(out, " == Proxy Binding Cache entry ");
+    switch (e->type) {
+        case BCE_PMIP:
+            fprintf(out, "(BCE_PMIP)\n");
+            break;
+        case BCE_TEMP:
+            fprintf(out, "(BCE_TEMP)\n");
+            break;
+        default:
+            fprintf(out, "(Unknown)\n");
+    }
+    fprintf(out, " MN IID:                 %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&e->mn_suffix));
+    fprintf(out, " MN HW Address:          %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&e->mn_hw_address));
+    fprintf(out, " MN Serving MAG Address: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&e->mn_serv_mag_addr));
+    fprintf(out, " MN Serving LMA Address: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&e->mn_serv_lma_addr));
+    fprintf(out, " lifetime %ld\n ", e->lifetime.tv_sec);
+    fprintf(out, " seqno    %d\n", e->seqno_out);
+    fflush(out);
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_cache_init(void)
+{
+    int ret;
+    int mutex_return_code;
+    if (pthread_rwlock_init(&pmip_lock, NULL)) {
+        return -1;
+    }
+    mutex_return_code = pthread_rwlock_wrlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+
+    ret = hash_init(&g_pmip_hash, DOUBLE_ADDR, PMIP_CACHE_BUCKETS);
+
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+
+    #ifdef ENABLE_VT
+    if (ret < 0)
+        return ret;
+    ret = vt_pbc_init();
+    #endif
+    return ret;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void init_iface_ra()
+{
+    router_ad_iface.AdvSendAdvert = DFLT_AdvSendAdv;
+    router_ad_iface.MaxRtrAdvInterval = DFLT_MaxRtrAdvInterval;
+    router_ad_iface.MinRtrAdvInterval = 1;  //changed from -1
+    router_ad_iface.AdvIntervalOpt = DFLT_AdvIntervalOpt;
+    router_ad_iface.AdvCurHopLimit = DFLT_AdvCurHopLimit;
+    router_ad_iface.AdvHomeAgentFlag = DFLT_AdvHomeAgentFlag;
+    router_ad_iface.AdvHomeAgentInfo = DFLT_AdvHomeAgentInfo;
+    router_ad_iface.HomeAgentPreference = DFLT_HomeAgentPreference;
+    router_ad_iface.HomeAgentLifetime = 10000;  //changed from -1
+    router_ad_iface.AdvReachableTime = DFLT_AdvReachableTime;
+    router_ad_iface.AdvRetransTimer = DFLT_AdvRetransTimer;
+    router_ad_iface.AdvDefaultLifetime = 6000;
+    router_ad_iface.AdvManagedFlag = 0;
+    router_ad_iface.AdvOtherConfigFlag = 0;
+    // default values for Prefix.
+    router_ad_iface.Adv_Prefix.AdvOnLinkFlag = DFLT_AdvOnLinkFlag;
+    router_ad_iface.Adv_Prefix.AdvAutonomousFlag = DFLT_AdvAutonomousFlag;
+    router_ad_iface.Adv_Prefix.AdvRouterAddr = DFLT_AdvRouterAddr;
+    router_ad_iface.Adv_Prefix.PrefixLen = 64;
+    router_ad_iface.Adv_Prefix.AdvValidLifetime = DFLT_AdvValidLifetime;
+    router_ad_iface.Adv_Prefix.AdvPreferredLifetime = DFLT_AdvPreferredLifetime;
+}
+//---------------------------------------------------------------------------------------------------------------------
+pmip_entry_t *pmip_cache_alloc(int type)
+{
+    pmip_entry_t *tmp;
+    tmp = malloc(sizeof(pmip_entry_t));
+
+    if (tmp == NULL) {
+        dbg("NO memory allocated for PMIP cache entry..\n");
+        return NULL;
+    }
+
+    memset(tmp, 0, sizeof(*tmp));
+
+    if (pthread_rwlock_init(&tmp->lock, NULL)) {
+        free(tmp);
+        return NULL;
+    }
+    INIT_LIST_HEAD(&tmp->tqe.list);
+    tmp->type = type;
+    dbg("PMIP cache entry is allocated..\n");
+    return tmp;
+}
+//---------------------------------------------------------------------------------------------------------------------
+static int __pmipcache_insert(pmip_entry_t * bce)
+{
+    int ret;
+    ret = hash_add(&g_pmip_hash, bce, &bce->our_addr, &bce->mn_hw_address);
+    if (ret) {
+        return ret;
+    }
+    g_pmip_cache_count++;
+    dbg("PMIP cache entry is inserted for: %x:%x:%x:%x:%x:%x:%x:%x <-> %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->our_addr), NIP6ADDR(&bce->mn_hw_address));
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_cache_start(pmip_entry_t * bce)
+{
+    dbg("PMIP cache start is initialized add task pmip_timer_bce_expired_handler in %d seconds\n", bce->lifetime.tv_sec);
+    struct timespec expires;
+    clock_gettime(CLOCK_REALTIME, &bce->add_time);
+    tsadd(bce->add_time, bce->lifetime, expires);
+
+    add_task_abs(&expires, &bce->tqe,  pmip_timer_bce_expired_handler);
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+pmip_entry_t *pmip_cache_add(pmip_entry_t * bce)
+{
+    int ret = 1;
+    int mutex_return_code;
+    assert(bce);
+    bce->unreach = 0;
+    mutex_return_code = pthread_rwlock_wrlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    if ((ret = __pmipcache_insert(bce)) != 0) {
+        pthread_rwlock_unlock(&pmip_lock);
+        dbg("WARNING: PMIP ENTRY NOT INSERTED..\n");
+        return NULL;
+    }
+    dbg("Making Entry\n");
+    dbg("PMIP cache entry for: %x:%x:%x:%x:%x:%x:%x:%x with type %d is added\n", NIP6ADDR(&bce->mn_hw_address), bce->type);
+    bce->n_rets_counter = conf.MaxMessageRetransmissions;
+    dbg("Retransmissions counter intialized: %d\n", bce->n_rets_counter);
+    if (bce->type == BCE_PMIP) {
+        pmip_cache_start(bce);
+    }
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    return bce;
+}
+//---------------------------------------------------------------------------------------------------------------------
+pmip_entry_t *pmip_cache_get(const struct in6_addr * our_addr, const struct in6_addr * peer_addr)
+{
+    pmip_entry_t *bce;
+    int mutex_return_code;
+
+    assert(peer_addr && our_addr);
+    mutex_return_code = pthread_rwlock_rdlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_rdlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    bce = hash_get(&g_pmip_hash, our_addr, peer_addr);
+    if (bce) {
+        mutex_return_code = pthread_rwlock_wrlock(&bce->lock);
+        if (mutex_return_code != 0) {
+            dbg("pthread_rwlock_wrlock(&bce->lock) %s\n", strerror(mutex_return_code));
+        }
+        dbg("PMIP cache entry is found for: %x:%x:%x:%x:%x:%x:%x:%x with type %d\n", NIP6ADDR(&bce->mn_hw_address), (bce->type));
+    } else {
+        mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+        if (mutex_return_code != 0) {
+            dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+        }
+        dbg("PMIP cache entry is NOT found for %x:%x:%x:%x:%x:%x:%x:%x <-> %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(our_addr), NIP6ADDR(peer_addr));
+    }
+    return bce;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmipcache_release_entry(pmip_entry_t * bce)
+{
+    int mutex_return_code;
+    assert(bce);
+    mutex_return_code = pthread_rwlock_unlock(&bce->lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&bce->lock) %s\n", strerror(mutex_return_code));
+    }
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_cache_exists(const struct in6_addr *our_addr, const struct in6_addr *peer_addr)
+{
+    pmip_entry_t *bce;
+    int type;
+    bce = pmip_cache_get(our_addr, peer_addr);
+    if (bce == NULL) {
+        return -1;
+    }
+    dbg("PMIP cache entry does exist with type: %d\n", (bce->type));
+    type = bce->type;
+    pmipcache_release_entry(bce);
+    return type;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmipcache_free(pmip_entry_t * bce)
+{
+/* This function should really return allocated space to free
+* pool. */
+    int mutex_return_code;
+    mutex_return_code = pthread_rwlock_destroy(&bce->lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_destroy(&bce->lock) %s\n", strerror(mutex_return_code));
+    }
+    free(bce);
+    dbg("PMIP cache entry is free\n");
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_bce_delete(pmip_entry_t * bce)
+{
+    int mutex_return_code;
+
+    mutex_return_code = pthread_rwlock_wrlock(&bce->lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&bce->lock) %s\n", strerror(mutex_return_code));
+    }
+    del_task(&bce->tqe);
+    if (bce->cleanup) {
+        bce->cleanup(bce);
+    }
+    g_pmip_cache_count--;
+    hash_delete(&g_pmip_hash, &bce->our_addr, &bce->mn_hw_address);
+    mutex_return_code = pthread_rwlock_unlock(&bce->lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&bce->lock) %s\n", strerror(mutex_return_code));
+    }
+    pmipcache_free(bce);
+    dbg("PMIP cache entry is deleted!\n");
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_cache_delete(const struct in6_addr *our_addr, const struct in6_addr *peer_addr)
+{
+    int mutex_return_code;
+    pmip_entry_t *bce;
+    mutex_return_code = pthread_rwlock_wrlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    bce = hash_get(&g_pmip_hash, our_addr, peer_addr);
+    if (bce) {
+        pmip_bce_delete(bce);
+    }
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_cache_iterate(int (*func) (void *, void *), void *arg)
+{
+    int err;
+    int mutex_return_code;
+    mutex_return_code = pthread_rwlock_rdlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_rdlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    err = hash_iterate(&g_pmip_hash, func, arg);
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    return err;
+}
diff -Nur umip/src/pmip/pmip_cache.h umip-pmipv6/src/pmip/pmip_cache.h
--- umip/src/pmip/pmip_cache.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_cache.h	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,302 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_cache.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup CACHE BINDING CACHE
+ * \ingroup PMIP6D
+ *  PMIP CACHE
+ *  @{
+ */
+
+#ifndef __PMIP_CACHE_H__
+#    define __PMIP_CACHE_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_CACHE_C
+#        define private_pmip_cache(x) x
+#        define protected_pmip_cache(x) x
+#        define public_pmip_cache(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_cache(x)
+#            define protected_pmip_cache(x) extern x
+#            define public_pmip_cache(x) extern x
+#        else
+#            define private_pmip_cache(x)
+#            define protected_pmip_cache(x)
+#            define public_pmip_cache(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+#    include <pthread.h>
+#    include <arpa/inet.h>
+#    include <netinet/in.h>
+//-----------------------------------------------------------------------------
+#    include "tqueue.h"
+#    include "util.h"
+#    include "hash.h"
+//-----------------------------------------------------------------------------
+#    include "pmip_types.h"
+
+
+/*! \def PMIP_CACHE_BUCKETS
+* \brief A macro that defines the number of buckets in the hashtable "binding cache entry".
+*/
+#    define PMIP_CACHE_BUCKETS				128
+
+#    ifndef ND_OPT_PI_FLAG_RADDR
+#        define ND_OPT_PI_FLAG_RADDR		0x20
+#    endif
+#    define DFLT_AdvValidLifetime			86400   /* seconds */
+#    define DFLT_AdvOnLinkFlag				1
+#    define DFLT_AdvPreferredLifetime		14400    /* seconds */
+#    define DFLT_AdvAutonomousFlag			1
+#    ifndef ND_OPT_HAI_FLAG_SUPPORT_MR
+#        if BYTE_ORDER== BIG_ENDIAN
+#            define ND_OPT_HAI_FLAG_SUPPORT_MR  0x8000
+#        else
+#            define ND_OPT_HAI_FLAG_SUPPORT_MR  0x0080
+#        endif
+#    endif
+#    define DFLT_AdvSendAdv				1
+#    define DFLT_MaxRtrAdvInterval		1.5
+#    define DFLT_MinRtrAdvInterval		1 //(iface) (0.33 * (iface)->MaxRtrAdvInterval)
+#    define DFLT_AdvCurHopLimit			64  /* as per RFC 1700 or the next incarnation of it :) */
+#    define DFLT_AdvReachableTime		0
+#    define DFLT_AdvRetransTimer		0
+#    define DFLT_HomeAgentPreference	20
+#    define DFLT_AdvHomeAgentFlag		1
+#    define DFLT_AdvIntervalOpt			1
+#    define DFLT_AdvHomeAgentInfo		1
+#    define DFLT_AdvRouterAddr			1
+#    define MSG_SIZE 					4096
+
+/*! \struct  adv_prefix_t
+* \brief Data structure to store router advertisment informations.
+*/
+typedef struct AdvPrefix_t {
+	struct in6_addr		Prefix; 				/*!< \brief The IPv6 prefix  */
+	uint8_t				PrefixLen;				/*!< \brief The len of the IPv6 prefix  */
+	int					AdvOnLinkFlag;			/*!< \brief When set, indicates that this prefix can be used for on-link determination. When not set the advertisement makes no statement about on-link or off-link properties of the prefix. For instance, the prefix might be used for address configuration with some of the addresses belonging to the prefix being on-link and others being off-link.*/
+	int					AdvAutonomousFlag;		/*!< \brief When set, indicates that this prefix can be used for autonomous address configuration as specified in RFC 2462.*/
+	uint32_t			AdvValidLifetime;		/*!< \brief The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.*/
+	uint32_t			AdvPreferredLifetime;	/*!< \brief The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.*/
+	/* Mobile IPv6 extensions */
+	int					AdvRouterAddr;			/*!< \brief When set, indicates that the address of interface is sent instead of network prefix, as is required by Mobile IPv6. When set, minimum limits specified by Mobile IPv6 are used for MinRtrAdvInterval and MaxRtrAdvInterval.*/
+} adv_prefix_t;
+
+
+/*! \struct  home_agent_info_t
+* \brief Data structure to store home agent informations. Used for building a Router Advertisement message.
+*/
+typedef struct HomeAgentInfo_t {
+	uint8_t 		type;			/*!< \brief Always set to ND_OPT_HOME_AGENT_INFO */
+    uint8_t 		length;
+    uint16_t 		flags_reserved;
+	uint16_t 		preference;		/*!< \brief The preference for the Home Agent sending this Router Advertisement. Values greater than 0 indicate more preferable Home Agent, values less than 0 indicate less preferable Home Agent. This option is ignored, if AdvHomeAgentInfo is not set.*/
+	uint16_t 		lifetime;		/*!< \brief The length of time in seconds (relative to the time the packet is sent) that the router is offering Mobile IPv6 Home Agent services. A value 0 must not be used. The maximum lifetime is 65520 seconds (18.2 hours). This option is ignored, if AdvHomeAgentInfo is not set.*/
+} home_agent_info_t;
+
+
+/*! \struct  router_ad_iface_t
+* \brief Data structure to router advertisement informations. Used for building a Router Advertisement message.
+*/
+typedef struct ra_iface_t {
+	int				AdvSendAdvert;			/*!< \brief A flag indicating whether or not the router sends periodic router advertisements and responds to router solicitations. This option no longer has to be specified first, but it needs to be on to enable advertisement on this interface */
+	double			MaxRtrAdvInterval;		/*!< \brief The maximum time allowed between sending unsolicited multicast router advertisements from the interface, in seconds. Must be no less than 4 seconds and no greater than 1800 seconds. Minimum when using Mobile IPv6 extensions: 0.07.*/
+	double			MinRtrAdvInterval;		/*!< \brief The minimum time allowed between sending unsolicited multicast router advertisements from the interface, in seconds. Must be no less than 3 seconds and no greater than 0.75 * MaxRtrAdvInterval. Minimum when using Mobile IPv6 extensions: 0.03.*/
+	uint32_t		AdvReachableTime;		/*!< \brief The time, in milliseconds, that a node assumes a neighbor is reachable after having received a reachability confirmation. Used by the Neighbor Unreachability Detection algorithm (see Section 7.3 of RFC 2461). A value of zero means unspecified (by this router) */
+	uint32_t		AdvRetransTimer;		/*!< \brief The time, in milliseconds, between retransmitted Neighbor Solicitation messages. Used by address resolution and the Neighbor Unreachability Detection algorithm (see Sections 7.2 and 7.3 of RFC 2461). A value of zero means unspecified (by this router). */
+	int32_t			AdvDefaultLifetime;		/*!< \brief The lifetime associated with the default router in units of seconds. The maximum value corresponds to 18.2 hours. A lifetime of 0 indicates that the router is not a default router and should not appear on the default router list. The router lifetime applies only to the router's usefulness as a default router; it does not apply to information contained in other message fields or options. Options that need time limits for their information include their own lifetime fields. */
+	int				AdvMobRtrSupportFlag;		/*!< \brief When set, the Home Agent signals it supports Mobile Router registrations (specified by NEMO Basic). AdvHomeAgentInfo must also be set when using this option.*/
+	uint8_t			AdvCurHopLimit;			/*!< \brief The default value that should be placed in the Hop Count field of the IP header for outgoing (unicast) IP packets. The value should be set to the current diameter of the Internet. The value zero means unspecified (by this router).*/
+    /* Mobile IPv6 extensions */
+	int				AdvIntervalOpt;			/*!< \brief When set, Advertisement Interval Option (specified by Mobile IPv6) is included in Router Advertisements. When set, minimum limits specified by Mobile IPv6 are used for MinRtrAdvInterval and MaxRtrAdvInterval. */
+	int				AdvHomeAgentInfo;		/*!< \brief When set, Home Agent Information Option (specified by Mobile IPv6) is included in Router Advertisements. AdvHomeAgentFlag must also be set when using this option. */
+	int				AdvHomeAgentFlag;		/*!< \brief When set, indicates that sending router is able to serve as Mobile IPv6 Home Agent. When set, minimum limits specified by Mobile IPv6 are used for MinRtrAdvInterval and MaxRtrAdvInterval. */
+	uint16_t		HomeAgentPreference;	/*!< \brief The preference for the Home Agent sending this Router Advertisement. Values greater than 0 indicate more preferable Home Agent, values less than 0 indicate less preferable Home Agent. This option is ignored, if AdvHomeAgentInfo is not set. */
+	int32_t			HomeAgentLifetime;		/*!< \brief The length of time in seconds (relative to the time the packet is sent) that the router is offering Mobile IPv6 Home Agent services. A value 0 must not be used. The maximum lifetime is 65520 seconds (18.2 hours). This option is ignored, if AdvHomeAgentInfo is not set. */
+	int				AdvManagedFlag;			/*!< \brief When set, hosts use the administered (stateful) protocol for address autoconfiguration in addition to any addresses autoconfigured using stateless address autoconfiguration. The use of this flag is described in RFC 2462. */
+	int				AdvOtherConfigFlag;		/*!< \brief When set, hosts use the administered (stateful) protocol for autoconfiguration of other (non-address) information. The use of this flag is described in RFC 2462. */
+	adv_prefix_t	Adv_Prefix;				/*!< \brief see  adv_prefix_t*/
+} router_ad_iface_t;
+
+
+/*! \struct  pmip_entry_t
+* \brief Data structure "binding cache entry", to store all binding informations relative to a mobile node.
+*/
+typedef struct pmip_entry_t {
+	struct in6_addr			mn_prefix;			/*!< \brief Network Address Prefix for MN */
+	struct in6_addr			our_addr;			/*!< \brief Address to which we got BU */
+	struct in6_addr			mn_suffix;			/*!< \brief MN IID */
+	struct in6_addr			mn_hw_address;		/*!< \brief MAC ADDR */
+	struct in6_addr			mn_addr;			/*!< \brief Full MN Address */
+	struct in6_addr			mn_serv_mag_addr;	/*!< \brief Serving MAG Address */
+	struct in6_addr			mn_serv_lma_addr;	/*!< \brief Serving LMA Address (attribute filled only on MAGs)*/
+	struct in6_addr			mn_link_local_addr;	/*!< \brief Link Local Address  for MN */
+	struct timespec			add_time;			/*!< \brief When was the binding added or modified */
+	struct timespec			lifetime;			/*!< \brief Lifetime sent in the Binding Update, in seconds */
+	uint16_t				seqno_in;			/*!< \brief Sequence number for response messages */
+	uint16_t				seqno_out;			/*!< \brief Sequence number for created messages */
+	uint16_t				PBU_flags;			/*!< \brief PBU flags */
+	uint8_t					PBA_flags;			/*!< \brief PBA flags */
+	int 					type;				/*!< \brief Entry type */
+	int						unreach;			/*!< \brief ICMP dest unreach count */
+	int						tunnel;				/*!< \brief Tunnel interface index */
+	int						link;				/*!< \brief Home link interface index */
+	/* PBU/PBRR message for retransmissions */
+    struct iovec 			mh_vec[2 * (IP6_MHOPT_MAX + 1)];          /* was 7 */
+    int 					iovlen;
+	/* info_block status flags */
+	uint8_t 				status;				/*!< \brief Info_block status flag*/
+	ip6ts_t 				timestamp;			/*!< \brief Info_block status timestamp*/
+	uint32_t 				msg_event;			/*!< \brief Info_block status msg_event*/
+
+	struct timespec			br_lastsent;		/*!< \brief BR ratelimit, for internal use only*/
+	int 					br_count;			/*!< \brief BR ratelimit, for internal use only*/
+	int 					n_rets_counter;		/*!< \brief Counter for N retransmissions before deleting the entry, for internal use only*/
+	pthread_rwlock_t 		lock;				/*!< \brief Protects the entry, for internal use only*/
+	struct tq_elem 			tqe;				/*!< \brief Timer queue entry for expire, for internal use only*/
+	void (*cleanup) (struct pmip_entry_t * bce);/*!< \brief Clean up bce data, for internal use only*/
+} pmip_entry_t;
+
+
+//Dedicated to PMIP cache
+/*! \def BCE_NO_ENTRY
+\brief A macro that defines the state of a binding cache entry, the state here is "unknown entry".
+*/
+#    define BCE_NO_ENTRY (-1)
+/*! \def BCE_PMIP
+\brief A macro that defines the state of a binding cache entry, the state here is "registered pmip entry".
+*/
+#    define BCE_PMIP 5
+/*! \def BCE_TEMP
+\brief A macro that defines the state of a binding cache entry, the state here is "binding cache entry waiting for registration".
+* \note This state is possible only on MAG entities, not LMA.
+*/
+#    define BCE_TEMP 6
+
+
+//-GLOBAL VARIABLES----------------------------------------------------------------------------
+/*! \var pthread_rwlock_t pmip_lock
+\brief Global var mutex on the binding cache
+*/
+protected_pmip_cache(pthread_rwlock_t pmip_lock;)
+/*! \var router_ad_iface_t router_ad_iface
+\brief Router advertisement structure containing all information that will be sent in the router advertisement message by MAGs.
+*/
+protected_pmip_cache(router_ad_iface_t router_ad_iface;)
+
+
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn int get_pmip_cache_count(int type)
+* \brief
+* \param[in]  type The type of binding cache entry
+* \return   The number of binding cache entries in the cache.
+*/
+private_pmip_cache(int get_pmip_cache_count(int type);)
+/*! \fn void dump_pbce(void *bce, void *os)
+* \brief Dump in an output stream, the content of a binding cache entry.
+* \param[in]  bce A binding cache entry.
+* \param[in]  os  An output stream.
+*/
+private_pmip_cache(void dump_pbce(void *bce, void *os);)
+/*! \fn int pmip_cache_init(void)
+* \brief Initialize the pmip cache
+* \return   The status of the initialization.
+*/
+protected_pmip_cache(int pmip_cache_init(void);)
+/*! \fn void init_iface_ra(void)
+* \brief Set once the router advertisement parameters
+*/
+protected_pmip_cache(void init_iface_ra(void);)
+/*! \fn pmip_entry_t * pmip_cache_alloc(int type)
+* \brief Allocates a new binding cache entry. Returns allocated space (pmip_entry_t*) for an entry or NULL if errors.
+* \param[in]  type The type of binding cache entry
+* \return   The allocated binding cache entry or NULL if memory space available or if initialization of the binding cache entry failled.
+*/
+protected_pmip_cache(pmip_entry_t * pmip_cache_alloc(int type);)
+/*! \fn int pmip_cache_start(pmip_entry_t *bce)
+* \brief Start a timer on a binding cache entry.
+* \param[in]  bce a binding cache entry
+* \return   Always 0.
+* \note A task queue element (see tqueue.c) is created and managed by a timed thread
+*/
+protected_pmip_cache(int pmip_cache_start(pmip_entry_t * bce);)
+/*! \fn pmip_entry_t * pmip_cache_add(pmip_entry_t *bce)
+* \brief Add an entry in the binding cache.
+* \param[in]  bce a binding cache entry
+* \return   The binding cache entry if success, else NULL.
+* \note If the binding cache entry type is BCE_PMIP, then a timer is started by a call to pmip_cache_start.
+*/
+protected_pmip_cache(pmip_entry_t * pmip_cache_add(pmip_entry_t * bce);)
+/*! \fn pmip_entry_t * pmip_cache_get(const struct in6_addr *our_addr, const struct in6_addr *peer_addr)
+* \brief Add an entry in the binding cache.
+* \param[in]  our_addr  the IPv6 fixed address of the PMIP entity
+* \param[in]  peer_addr peer hardware address (link-layer address)
+* \return   The corresponding cache entry, else NULL.
+* \note 	If a binding cache entry is returned, its mutex is write locked, pmip mutex "pmip_lock" is also read-write locked.
+*/
+protected_pmip_cache(pmip_entry_t * pmip_cache_get(const struct in6_addr *our_addr, const struct in6_addr *peer_addr);)
+/*! \fn void pmipcache_release_entry(pmip_entry_t *bce)
+* \brief Unlocks a binding cache entry.
+* \param[in]  bce  a binding cache entry
+* \note 	"pmip_lock" mutex is also unlocked.
+*/
+protected_pmip_cache(void pmipcache_release_entry(pmip_entry_t * bce);)
+/*! \fn int pmip_cache_exists(const struct in6_addr*, const struct in6_addr*)
+* \brief Check the existence of a binding cache entry for a tuple of addresses in the binding cache.
+* \param[in]  our_addr  the IPv6 fixed address of the PMIP entity
+* \param[in]  peer_addr peer hardware address (link-layer address)
+* \return   The type of the binding cache entry if found, -1 if entry not found.
+* \note 	If a binding cache entry is found, its mutex is unlocked.
+*/
+protected_pmip_cache(int pmip_cache_exists(const struct in6_addr *our_addr, const struct in6_addr *peer_addr);)
+/*! \fn void pmipcache_free(pmip_entry_t *bce)
+* \brief Free the allocated memory of a binding cache entry.
+* \param[in]  bce  a binding cache entry
+*/
+private_pmip_cache(void pmipcache_free(pmip_entry_t * bce);)
+/*! \fn void pmip_bce_delete(pmip_entry_t*)
+* \brief Remove a binding cache entry from the binding cache and free it.
+* \param[in]  bce  a binding cache entry
+*/
+protected_pmip_cache(void pmip_bce_delete(pmip_entry_t * bce);)
+/*! \fn void pmip_cache_delete(const struct in6_addr*, const struct in6_addr*)
+* \brief Search a binding cache entry in the binding cache corresponding to a tupple of addresses and remove this binding cache entry from the binding cache and free it.
+* \param[in]  our_addr  the IPv6 fixed address of the PMIP entity
+* \param[in]  peer_addr peer hardware address (link-layer address)
+*/
+protected_pmip_cache(void pmip_cache_delete(const struct in6_addr *our_addr, const struct in6_addr *peer_addr);)
+/*! \fn int pmip_cache_iterate(int (*func) (void *, void *), void *arg)
+* \brief Apply function to every BC entry. Iterates through proxy binding cache, calling \a func for each entry. Extra data may be passed to \a func in \a arg.\a func takes a bcentry as its first argument and \a arg as second argument.
+* \param[in]  func  the int (*func) (void *, void *) function pointer to apply to every binding cache entry.
+* \param[in]  arg   extra data for func
+* \return	The iterate status.
+*/
+public_pmip_cache(int pmip_cache_iterate(int (*func) (void *, void *), void *arg);)
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip_consts.h umip-pmipv6/src/pmip/pmip_consts.h
--- umip/src/pmip/pmip_consts.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_consts.h	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,95 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_consts.h
+* \brief Describe all constants for pmip
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup CONSTANTS CONSTANTS
+ * \ingroup PMIP6D
+ *  PMIP CONSTANTS
+ *  @{
+ */
+
+#ifndef __pmip_consts_h
+#    define __pmip_consts_h
+#    include <netinet/in.h>
+#    include "conf.h"
+
+#    define MAX_MOBILES 64
+
+/*
+* Mobility Header Message Option Types
+* new mobility header options types defined
+*/
+#    define IP6_MHOPT_MOBILE_NODE_IDENTIFIER            0x08   /* Mobile Node Identifier Option */
+/*
+* Mobility Header Message Option Types
+*/
+#    define IP6_MHOPT_DST_MN_ADDR                       0x0B   /* Source Mobile Node address */
+#    define IP6_MHOPT_SERV_MAG_ADDR                     0x0C   /* Serving MAG address */
+#    define IP6_MHOPT_SERV_LMA_ADDR                     0x0D   /* Source Mobile Node address */
+#    define IP6_MHOPT_SRC_MN_ADDR                       0x0E   /* Source Mobile Node address */
+#    define IP6_MHOPT_SRC_MAG_ADDR                      0x0F   /* Serving MAG address */
+#    define IP6_MHOPT_HOME_NETWORK_PREFIX               0x16   /* Home Network Prefix */
+#    define IP6_MHOPT_HANDOFF_INDICATOR                 0x17   /* Handoff Indicator Option */
+#    define IP6_MHOPT_ACCESS_TECHNOLOGY_TYPE            0x18   /* Access Technology Type Option */
+#    define IP6_MHOPT_MOBILE_NODE_LINK_LAYER_IDENTIFIER 0x19   /* Mobile Node Link Local Identifier Option */
+#    define IP6_MHOPT_LINK_LOCAL_ADDRESS                0x1A   /* link local address */
+#    define IP6_MHOPT_TIME_STAMP                        0x1B   /* Timestamp */
+#    define IP6_MHOPT_PMIP_MAX                          IP6_MHOPT_TIME_STAMP
+
+
+#    define IP6_MHOPT_HI_RESERVED                                                  0
+#    define IP6_MHOPT_HI_ATTACHMENT_OVER_NEW_INTERFACE                             1
+#    define IP6_MHOPT_HI_HANDOFF_BETWEEN_2_DIFF_INTERFACES_OF_SAME_MOBILE_NODE     2
+#    define IP6_MHOPT_HI_HANDOFF_BETWEEN_MAGS_FOR_SAME_INTERFACE                   3
+#    define IP6_MHOPT_HI_HANDOFF_STATE_UNKNOWN                                     4
+#    define IP6_MHOPT_HI_HANDOFF_STATE_NOT_CHANGED                                 5
+
+#    define IP6_MHOPT_ATT_RESERVED                                                 0
+#    define IP6_MHOPT_ATT_VIRTUAL                                                  1
+#    define IP6_MHOPT_ATT_PPP                                                      2
+#    define IP6_MHOPT_ATT_IEEE802_3                                                3
+#    define IP6_MHOPT_ATT_IEEE802_11ABG                                            4
+#    define IP6_MHOPT_ATT_IEEE802_16E                                              5
+
+#    define IP6_MH_TYPE_PBREQ   8   /* Proxy Binding Request */
+#    define IP6_MH_TYPE_PBRES   9   /* Proxy Binding Response */
+
+
+//Define STATUS FLAGS for FSM.
+#    define hasDEREG        0x00000050  /* Has a DEREG */
+/*!< \brief WLCCP message originating from access point, captured on MAG, message informing about wireless association of a mobile node with the access point */
+#    define hasWLCCP        0x00000040  /* Has a WLCCP CISCO protocol */
+#    define hasRS           0x00000030  /* Has a RS */
+#    define hasNA           0x00000020  /* Has a NA */
+#    define hasNS           0x00000010  /* Has a NS */
+#    define hasPBU          0x00000008  /* Has a PBU */
+#    define hasPBA          0x00000004  /* Has a PBA */
+#    define hasPBREQ        0x00000002  /* Has a PBRR */
+#    define hasPBRES        0x00000001  /* Has a PBRE */
+#    define PREFIX_LENGTH   64
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip_fsm.c umip-pmipv6/src/pmip/pmip_fsm.c
--- umip/src/pmip/pmip_fsm.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_fsm.c	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,297 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_fsm.c
+ * \brief
+ * \author OpenAir3 Group
+ * \date 12th of October 2010
+ * \version 1.0
+ * \company Eurecom
+ * \project OpenAirInterface
+ * \email: openair_tech@eurecom.fr
+ */
+#define PMIP
+#define PMIP_FSM_C
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_fsm.h"
+#include "pmip_hnp_cache.h"
+#include "pmip_lma_proc.h"
+#include "pmip_mag_proc.h"
+#include "pmip_handler.h"
+//---------------------------------------------------------------------------------------------------------------------
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//---------------------------------------------------------------------------------------------------------------------
+int mag_init_fsm(void)
+{
+    if (pthread_rwlock_init(&fsm_lock, NULL))
+        return -1;
+    else
+        return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_fsm(msg_info_t * info)
+{
+    int result = 0;
+    int aaa_result = 0;
+    pmip_entry_t *bce;
+    struct in6_addr prefix;
+    struct in6_addr hw_address = EUI64_to_EUI48(info->mn_iid);
+    int type = pmip_cache_exists(&conf.OurAddress, &hw_address);
+    int mutex_return_code;
+
+
+    mutex_return_code = pthread_rwlock_wrlock(&fsm_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&fsm_lock) %s\n", strerror(mutex_return_code));
+    }
+    switch (type) {
+    //--------------------------------------
+    case BCE_NO_ENTRY:
+        dbg("BCE_NO_ENTRY\n");
+        if (info->iif == g_ingress_iif) {
+          if (info->msg_event == hasRS) {
+              dbg("New MN is found sending RS, start new registration ...\n\n");
+              bce = pmip_cache_alloc(BCE_TEMP);
+              prefix = mnid_hnp_map(hw_address, &aaa_result);
+              if (aaa_result >= 0) {
+                  bce->mn_prefix = prefix;
+                  bce->mn_suffix = info->mn_iid;
+                  bce->mn_hw_address = EUI64_to_EUI48(info->mn_iid);
+                  info->mn_prefix = prefix;
+                  result = mag_pmip_md(info, bce);
+                  dbg("Movement detection is finished, now going to add an entry into the cache\n\n");
+                  pmip_cache_add(bce);
+                  dbg("pmip_cache_add is done \n\n");
+              } else {
+                  dbg("Authentication failed\n");
+              }
+              //yet to process
+          } else if (info->msg_event == hasWLCCP) {
+              dbg("Incoming MN is detected by Wireless Access Point, start new registration ...\n\n");
+              bce = pmip_cache_alloc(BCE_TEMP);
+              prefix = mnid_hnp_map(hw_address, &aaa_result);
+              if (aaa_result >= 0) {
+                  bce->mn_prefix = prefix;
+                  bce->mn_suffix = info->mn_iid;
+                  bce->mn_hw_address = hw_address;
+                  info->mn_prefix = prefix;
+                  result = mag_pmip_md(info, bce);
+                  dbg("Movement detection is finished, now going to add an entry into the cache\n\n");
+                  pmip_cache_add(bce);
+                  dbg("pmip_cache_add is done \n\n");
+              } else {
+                  dbg("Authentication failed\n");
+              }
+              //yet to process
+          } else if (info->msg_event == hasDEREG) {
+              dbg("Received DEREG message\n");
+              dbg("No action for this event (%d) at current state (%d) !\n", info->msg_event, type);
+          }
+        } else {
+            dbg("Received Message on wrong interface index (%d instead of %d), ignoring this message\n\n", info->iif,  g_ingress_iif);
+        }
+        break;
+        //--------------------------------------
+    case BCE_TEMP:
+        dbg("BCE_TEMP\n");
+        if (info->msg_event == hasPBA) {
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            if (is_pba_is_response_to_last_pbu_sent(info, bce)) {
+                dbg("Handling PBA. Moving from BCE_TEMP to BCE_PMIP\n");
+                dbg("Finish Location Registration\n");
+                //Modify the entry with additional info.
+                del_task(&bce->tqe);    //Delete timer retransmission PBU (if any)
+                bce->PBA_flags = info->PBA_flags;
+                // trick not to let LMA break the tunnel a few milli-seconds before MAG send a new PBU -> loss of traffic
+                if (info->lifetime.tv_sec > 10) {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec - 8;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) - 8 second = %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                } else if (info->lifetime.tv_sec > 5) {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec - 3;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) - 3 second = %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                } else if (info->lifetime.tv_sec > 1) {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec - 1;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) - 1 second = %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                } else {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) =  %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                }
+                dbg("Prefix before ending registration : %x:%x:%x:%x:%x:%x:%x:%x \n", NIP6ADDR(&bce->mn_prefix));
+                // LG COMMENT GOT PREFIX BY RADIUS - bce->mn_prefix = info->mn_prefix;   //adding the hn prefix value receive in PBA to MAG cache
+                mag_end_registration(bce, info->iif);
+            }
+            pmipcache_release_entry(bce);
+        }
+        break;
+        //--------------------------------------
+    case BCE_PMIP:
+        dbg("BCE_PMIP\n");
+        if (info->msg_event == hasRS) {
+            dbg("Router solicitation received for existing MN\n");
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            dbg("prefix before entering kickoff_ra : %x:%x:%x:%x:%x:%x:%x:%x \n", NIP6ADDR(&bce->mn_prefix));
+            mag_kickoff_ra(bce);
+            pmipcache_release_entry(bce);
+            dbg("RA sent after router solicitation ...\n");
+        } else if (info->msg_event == hasPBA) {
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            if (is_pba_is_response_to_last_pbu_sent(info, bce)) {
+                dbg("Finish Location Registration\n");
+                //Modify the entry with additional info.
+                del_task(&bce->tqe);    //Delete timer retransmission PBU (if any)
+                bce->PBA_flags = info->PBA_flags;
+                // trick not to let LMA break the tunnel a few milli-seconds before MAG send a new PBU -> loss of traffic
+                bce->lifetime.tv_nsec = 0;
+                if (info->lifetime.tv_sec > 10) {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec - 8;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) - 8 second = %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                } else if (info->lifetime.tv_sec > 5) {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec - 3;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) - 3 second = %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                } else if (info->lifetime.tv_sec > 1) {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec - 1;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) - 1 second = %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                } else {
+                    bce->lifetime.tv_sec = info->lifetime.tv_sec;
+                    dbg("Set BCE lifetime to PBA lifetime (%d seconds) =  %d seconds\n", info->lifetime.tv_sec, bce->lifetime.tv_sec);
+                }
+                dbg("Prefix before ending registration : %x:%x:%x:%x:%x:%x:%x:%x \n", NIP6ADDR(&bce->mn_prefix));
+                // LG COMMENT GOT PREFIX BY RADIUS - bce->mn_prefix = info->mn_prefix;   //adding the hn prefix value receive in PBA to MAG cache
+                mag_end_registration_no_new_tunnel(bce, info->iif);
+            }
+            pmipcache_release_entry(bce);
+        } else if (info->msg_event == hasWLCCP) {
+            dbg("Incomming MN is detected by Wireless Access Point, existing MN\n");
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            dbg("Prefix before entering kickoff_ra : %x:%x:%x:%x:%x:%x:%x:%x \n", NIP6ADDR(&bce->mn_prefix));
+            mag_kickoff_ra(bce);
+            // Some case where the access point did not detect the departure of the mobile node
+            // so we have to register again to the LMA
+            mag_force_update_registration(bce, info->iif);
+            pmipcache_release_entry(bce);
+            dbg("RA sent after MN AP detection ...\n");
+        } else if (info->msg_event == hasDEREG) {
+            dbg("Deregistration procedure detected by Wireless Access Point for a registered MN\n");
+            dbg("Start Location Deregistration\n");
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            mag_dereg(bce, 1);
+            pmipcache_release_entry(bce);
+            pmip_bce_delete(bce);
+        } else if (info->msg_event == hasNA) {
+            //Reset counter, Delete task for entry deletion  & Add a new task for NS expiry.
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            bce->n_rets_counter = conf.MaxMessageRetransmissions;    //Reset the Retransmissions Counter.
+            dbg("Reset the Reachability Counter = %d for %x:%x:%x:%x:%x:%x:%x:%x\n", bce->n_rets_counter, NIP6ADDR(&info->mn_iid));
+            del_task(&bce->tqe);
+            mag_force_update_registration(bce, info->iif);
+            //pmip_cache_start(bce);
+            pmipcache_release_entry(bce);
+        }
+        break;
+    default:
+        dbg("No action for this event (%d) at current state (%d) !\n", info->msg_event, type);
+    }
+    mutex_return_code = pthread_rwlock_unlock(&fsm_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&fsm_lock) %s\n", strerror(mutex_return_code));
+    }
+    return result;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int lma_fsm(msg_info_t * info)
+{
+    struct in6_addr r_tmp1;
+    int result = 0;
+    pmip_entry_t *bce = NULL;
+    struct in6_addr hw_address = EUI64_to_EUI48(info->mn_iid);
+    int type = pmip_cache_exists(&conf.OurAddress, &hw_address);
+    switch (type) {
+    //--------------------------------------
+    case BCE_NO_ENTRY:
+        dbg("No PMIP entry found for %x:%x:%x:%x:%x:%x:%x:%x ... \n", NIP6ADDR(&info->mn_iid));
+        if (info->msg_event == hasPBU && (info->lifetime.tv_sec > 0)) {
+            //Create New Proxy Binding Entry storing information
+            dbg("PBU for a new MN ... Location Registration starting now...\n");
+            bce = pmip_cache_alloc(BCE_PMIP);
+            if (bce != NULL) {
+                pmip_insert_into_hnp_cache(hw_address, info->mn_prefix);
+                lma_update_binding_entry(bce, info);   //Save information into bce
+                lma_reg(bce);
+                pmip_cache_add(bce);
+            }
+        } else if ((info->msg_event == hasPBU) && (info->lifetime.tv_sec == 0) && (info->lifetime.tv_nsec == 0)) {
+            dbg("PBU with Lifetime = 0 for a not-registered MN... \n");
+            // LG Comment lma_dereg(bce, info, 0);
+            // LG Comment pmipcache_release_entry(bce);
+        }
+
+        break;
+        //--------------------------------------
+    case BCE_PMIP:
+        if ((info->msg_event == hasPBU) && (info->lifetime.tv_sec > 0)) {
+            dbg("PBU for an existing MN ... update serving MAG\n");
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            memset(&r_tmp1, 0, sizeof(struct in6_addr));
+            if (IN6_ARE_ADDR_EQUAL(&r_tmp1, &bce->mn_serv_mag_addr)) //Received PBU from serving MAG
+            {
+                lma_update_binding_entry(bce, info);
+                lma_reg(bce);
+            }
+            if (IN6_ARE_ADDR_EQUAL(&info->src, &bce->mn_serv_mag_addr) ) //Received PBU from serving MAG
+            {
+                lma_update_binding_entry(bce, info);
+                lma_reg_no_new_tunnel (bce);
+            } else { //Received PBU from an already unregistered MAG
+                dbg("Deregistration for previously registered MAG\n");
+                lma_dereg(bce, info, 0);
+                bce->type = BCE_PMIP;
+                lma_update_binding_entry(bce, info);
+                lma_reg(bce);
+            }
+            pmipcache_release_entry(bce);
+        } else if (info->msg_event == hasPBU && info->lifetime.tv_sec == 0 && info->lifetime.tv_nsec == 0) {
+            dbg("PBU with Lifetime = 0... start Location Deregistration\n");
+            bce = pmip_cache_get(&conf.OurAddress, &hw_address);
+            if (IN6_ARE_ADDR_EQUAL(&info->src, &bce->mn_serv_mag_addr)) //Received PBU from serving MAG
+            {
+                dbg("Deregistration case...\n");
+                lma_dereg(bce, info, 1);
+                pmipcache_release_entry(bce);
+                pmip_bce_delete(bce);
+            } else { //Received PBU from an already unregistered MAG
+                dbg("Deregistration for not registered MAG, doing nothing\n");
+                //lma_dereg(bce, info, 0);
+                pmipcache_release_entry(bce);
+            }
+        }
+        // update bce->mn_addr attribute for vt display
+        get_mn_addr(bce);
+        break;
+        //--------------------------------------
+    default:
+        dbg("No action for this event (%d) at current state (%d) !\n", info->msg_event, type);
+    }
+    return result;
+}
diff -Nur umip/src/pmip/pmip_fsm.h umip-pmipv6/src/pmip/pmip_fsm.h
--- umip/src/pmip/pmip_fsm.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_fsm.h	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,81 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_fsm.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** @defgroup FINITE_STATE_MACHINE FINITE STATE MACHINE
+ * @ingroup PMIP6D
+ *  PMIP Finite State Machine (FSM)
+ *  @{
+ */
+
+#ifndef __PMIP_FSM_H__
+#    define __PMIP_FSM_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_FSM_C
+#        define private_pmip_fsm(x) x
+#        define protected_pmip_fsm(x) x
+#        define public_pmip_fsm(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_fsm(x)
+#            define protected_pmip_fsm(x) extern x
+#            define public_pmip_fsm(x) extern x
+#        else
+#            define private_pmip_fsm(x)
+#            define protected_pmip_fsm(x)
+#            define public_pmip_fsm(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+#    include <pthread.h>
+#    include "pmip_msgs.h"
+//-----------------------------------------------------------------------------
+/*! \fn int mag_init_fsm(void)
+* \brief Initialization of the Finite state machine of the MAG.
+* \return   The status of the initialization, 0 for success, else -1.
+* \note  Initialization of the mutex only.
+*/
+protected_pmip_fsm(int mag_init_fsm(void);)
+
+/*! \fn int mag_fsm(msg_info_t *info)
+* \brief Finite state machine of the MAG.
+* \param[in]  info All informations about the event received.
+* \return   0 for success and -1 if error
+*/
+protected_pmip_fsm(int mag_fsm(msg_info_t *info);)
+/*! \fn int lma_fsm(msg_info_t *info)
+* \brief Finite state machine of the LMA.
+* \param[in]  info All informations about the event received.
+* \return   0 for success and -1 if error
+*/
+protected_pmip_fsm(int lma_fsm(msg_info_t *info);)
+/*! \var pthread_rwlock_t fsm_lock
+\brief Global var mutex on the MAG finite state machine.
+*/
+private_pmip_fsm(pthread_rwlock_t fsm_lock;)
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip.h umip-pmipv6/src/pmip/pmip.h
--- umip/src/pmip/pmip.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip.h	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,95 @@
+/** @file pmip.h
+* @brief Proxy Mobile IPv6 implementation - EURECOM
+*/
+
+/** @defgroup PMIP6D ProxyMobileIPv6
+ *  Proxy Mobile IPv6 EURECOM Implementation
+ *  @{
+ */
+
+/** @mainpage Proxy MobileIPv6 Daemon - OpenAirInterface
+*
+* @authors OpenAir3 - EURECOM
+*
+* @section tablecontent Table of contents
+*
+* 1. Introduction \n
+* 2. PMIPv6 Architecture \n
+* 3. PMIPv6 Message flow scheme \n
+* 4. PMIPv6 Software architecture\n
+* 5. Details of our real PMIPv6 testbed \n
+*
+* @section intro1 1.) Introduction
+*
+* Proxy Mobile IPv6 (PMIPv6) is a network-based mobility management protocol for localized domains, which has been actively standardized by the IETF NETLMM Working Group. PMIPv6 is starting to attract much attention among telecommunication and internet communities due to its salient features and it is expected to expedite the real deployment of IP-based mobility management.
+*
+* PMIPv6 has been chosen by 3GPP and LTE and does not require any IPv6 stack modification in the Mobile Node (MN). Its main idea is to have a unique Home Network Prefix per MN.
+* Moreover, the whole mobility support is managed by Local Mobility Anchor (LMA) and Mobile Access Gateway (MAG) and not from the MN.
+*
+* @section intro2 2.) PMIPv6 Architecture
+*\image html PMIP6D.domain.jpg "Overview of PMIPv6 architecure"
+* In the PMIPv6 architecture, there are two main core functionnal entities :
+* - Local Mobility Anchor (LMA): it is similar to HA in MIPv6. LMA is responsible for maintaining the MN's reachability state and it is the topological anchor point for the MN's Home Network Prefix (HNP). LMA includes a binding cache entry for each currently registered MN with MN-Identifier, the MN's HNP, a flag indicating the proxy registration and the interface identifier of the bidirectional tunnel between the LMA and MAG.
+*
+* - Mobile Access Gateway (MAG): it is the entity that performs the mobility management on behalf of the MN and it resides on the access link where the MN is anchored. The MAG is responsible for detecting the MN's movements to and from the access link and for initiating binding registrations to the MN's LMA. Moreover, the MAG establishes a tunnel with the LMA for enabling the MN to use an address from its HNP and emulates the MN's home network on the access network for each MN.
+*
+*
+* @section intro3 3.) PMIPv6 Message flow scheme
+* The execution of the message flow of the overall operations in PMIPv6 is show in the figure below\n
+*\image html message_flow.jpg "Message flow in PMIPv6"
+* The main steps in the PMIPv6 mobility management scheme are achieved as follows :
+* - MN attachment: once a MN enters a PMIPv6 domain and attaches to an access link, the MAG on that access link performs the access authentication procedure with a policy server using the MN's profile, which contains MN-Identifier, LMA address and other related configuration parameters;
+* - Proxy Binding exchange: the MAG sends to the LMA a Proxy Binding Update (PBU) message on behalf of the MN including the MN-Identifier. Upon accepting the message, the LMA replies with a Proxy Binding Acknowledgment (PBA) message including the MN's HNP. With this procedure the LMA creates a Binding Cache Entry (BCE) for the MN and a bi-directional tunnel between the LMA and the MAG is set up;
+* - Address Configuration procedure: at this point the MAG has all the required information for emulating the MN's home link. It sends Router Advertisement message to the MN on the access link advertising the MN's HNP as the hosted on-link-prefix. On receiving this message, the MN configures its interface either using stateful or stateless address configuration modes. Finally the MN ends up with an address from its HNP that it can use while moving in the PMIPv6 domain.
+*
+* @section intro4 4.) PMIP6D Software Architecture
+* Here is an overview of the PMIP6D Software overview.
+*\image html MIPL.jpg "PMIP6D Software architecture"
+*
+* All the basic bricks of MIPL are reused in an efficient way. In MIPL v2.0, Mobile IPv6 is implemented using multi threads: one for handling the ICMPv6 messages, one for handling Mobility Header messages, and another one for handling tasks and time events.
+To support Proxy Mobile IPv6, we extend these elements and implement handlers for all necessary messages and events. All ICMPv6 messages or Mobility Header messages are parsed as inputs to the finite state machine, which is the heart of the system. This finite state machine makes appropriate decisions and controls all other elements to provide a correct predefined protocol behavior. The PMIPv6 binding cache stores all information about MNs' points of attachment and it is kept up-to-date with the mobility of MNs. As Proxy Mobile IPv6 implementation is built on top of MIPL version 2.0, it could be, in the future, easily integrated in MIPL, growing in line with the standards as well as with MIPL source code
+*
+*
+
+* @section intro5 5.) Details of our real PMIPv6 testbed
+*\image html PMIP_realtestbed.jpg "Our real PMIPv6 testbed details"
+*
+* It is totally based on IPv6. The functionalities developed for LMA and MAGs under MIPL v2.0.2 are used for creating the important entities in the PMIPv6 domain. An unmodified MN, which does not have any specific software for mobility, uses its Netgear wireless card to attach to one of the two Cisco Aironet 1100 series Access Points (APs), which support IEEE 802.11a/g specifications. Each AP is directly connected with a MAG. The implementation of MAG functionalities contains additional features and modifications of MIPL to handle PBU and PBA messages and mobility options, and a modified Router Advertisement daemon (RADVD), which unicasts RAs with a specific HNP per MN. Each MAG is connected to the LMA. The LMA is configured as a modified HA in MIPL which stores the HNP in the BCE for each MN and it is able to handle PBU and PBA messages. Finally, an unmodified CN is connected to the LMA. All the network entities in the test-bed are running Ubuntu with generic Linux kernel.
+*
+* <hr>
+* @section requirements requirements
+* @verbinclude requirements Each Access Point in your testbed should have a SYSLOG client feature and MAC address masquerading feature.
+* <hr>
+*
+*/
+#ifndef __PMIP_H__
+#    define __PMIP_H__
+//-----------------------------------------------------------------------------
+#   include <unistd.h> // for NULL definition
+#   include <linux/types.h>
+//-----------------------------------------------------------------------------
+#   include <netinet/in.h>
+#   include <netinet/ip6.h>
+#   include <netinet/icmp6.h>
+#   include <netinet/ip6mh.h>
+//-----------------------------------------------------------------------------
+#   include "mh.h"
+//-----------------------------------------------------------------------------
+#   include "pmip_cache.h"
+#   include "pmip_consts.h"
+#   include "pmip_fsm.h"
+#   include "pmip_handler.h"
+#   include "pmip_hnp_cache.h"
+#   include "pmip_init.h"
+#   include "pmip_lma_proc.h"
+#   include "pmip_mag_proc.h"
+#   include "pmip_msgs.h"
+#   include "pmip_pcap.h"
+#   include "pmip_tunnel.h"
+#   include "pmip_types.h"
+#   ifdef ENABLE_VT
+#       include "vt.h"
+#   endif
+#   include "conf.h"
+#endif
+/*@}*/
diff -Nur umip/src/pmip/pmip_handler.c umip-pmipv6/src/pmip/pmip_handler.c
--- umip/src/pmip/pmip_handler.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_handler.c	2013-12-22 18:45:06.000000000 +0100
@@ -0,0 +1,376 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_handler.c
+ * \brief
+ * \author OpenAir3 Group
+ * \date 12th of October 2010
+ * \version 1.0
+ * \company Eurecom
+ * \project OpenAirInterface
+ * \email: openair_tech@eurecom.fr
+ */
+#define PMIP
+#define PMIP_HANDLER_C
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_fsm.h"
+#include "pmip_handler.h"
+#include "pmip_lma_proc.h"
+#include "pmip_mag_proc.h"
+#include "pmip_msgs.h"
+//---------------------------------------------------------------------------------------------------------------------
+#include "tunnelctl.h"
+#include "ndisc.h"
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//---------------------------------------------------------------------------------------------------------------------
+struct in6_addr *link_local_addr(struct in6_addr *id)
+{
+    static struct in6_addr ADDR;
+    ADDR = in6addr_any;
+    ADDR.s6_addr32[0] = htonl(0xfe800000);
+    //copy the MN_ID.
+    memcpy(&ADDR.s6_addr32[2], &id->s6_addr32[2], sizeof(ip6mnid_t));
+    return &ADDR;
+}
+//---------------------------------------------------------------------------------------------------------------------
+struct in6_addr *CONVERT_ID2ADDR(struct in6_addr *result, struct in6_addr *prefix, struct in6_addr *id)
+{
+    *result = in6addr_any;
+    memcpy(&result->s6_addr32[0], &prefix->s6_addr32[0], sizeof(ip6mnid_t));
+    memcpy(&result->s6_addr32[2], &id->s6_addr32[2], sizeof(ip6mnid_t));
+    return result;
+}
+//---------------------------------------------------------------------------------------------------------------------
+struct in6_addr *get_mn_addr(pmip_entry_t * bce)
+{
+    CONVERT_ID2ADDR(&bce->mn_addr, &bce->mn_prefix, &bce->mn_suffix);
+    return &bce->mn_addr;
+}
+//---------------------------------------------------------------------------------------------------------------------
+struct in6_addr *solicited_mcast(struct in6_addr *id)
+{
+    //NUD_ADDR converts an ID into a Multicast Address for NS Unreachability!
+    static struct in6_addr ADDR2;
+    ADDR2 = in6addr_any;
+    ADDR2.s6_addr32[0] = htonl(0xff020000);
+    ADDR2.s6_addr32[1] = htonl(0x00000000);
+    ADDR2.s6_addr32[2] = htonl(0x00000001);
+    ADDR2.s6_addr[12] = 0xff;
+    //copy the least 24 bits from the MN_ID.
+    memcpy(&ADDR2.s6_addr[13], &id->s6_addr[13], 3 * sizeof(ADDR2.s6_addr[0]));
+    return &ADDR2;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_timer_retrans_pbu_handler(struct tq_elem *tqe)
+{
+    int mutex_return_code;
+
+    mutex_return_code = pthread_rwlock_wrlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    printf("-------------------------------------\n");
+    if (!task_interrupted()) {
+        pmip_entry_t *e = tq_data(tqe, pmip_entry_t, tqe);
+        mutex_return_code = pthread_rwlock_wrlock(&e->lock);
+        if (mutex_return_code != 0) {
+            dbg("pthread_rwlock_wrlock(&e->lock) %s\n", strerror(mutex_return_code));
+        }
+        dbg("Retransmissions counter : %d\n", e->n_rets_counter);
+        if (e->n_rets_counter == 0) {
+            free_iov_data((struct iovec *) &e->mh_vec, e->iovlen);
+            dbg("No PBA received from LMA....\n");
+            dbg("Abort Trasmitting the PBU....\n");
+            mutex_return_code = pthread_rwlock_unlock(&e->lock);
+            if (mutex_return_code != 0) {
+                dbg("pthread_rwlock_unlock(&e->lock) %s\n", strerror(mutex_return_code));
+            }
+            pmip_bce_delete(e);
+        } else {
+            //Decrement the N trasnmissions counter.
+            e->n_rets_counter--;
+            struct in6_addr_bundle addrs;
+            addrs.src = &conf.OurAddress;
+            addrs.dst = &conf.LmaAddress;
+            //sends a PBU
+            dbg("Send PBU again....\n");
+
+            // INCREMENT SEQ NUMBER OF PBU
+            e->seqno_out        = get_new_pbu_sequence_number();
+            ((struct ip6_mh_binding_update *)(e->mh_vec[0].iov_base))->ip6mhbu_seqno = htons(e->seqno_out);
+
+            pmip_mh_send(&addrs, e->mh_vec, e->iovlen, e->link);
+            //add a new task for PBU retransmission.
+            struct timespec expires;
+            clock_gettime(CLOCK_REALTIME, &e->add_time);
+            tsadd(e->add_time, conf.RetransmissionTimeOut, expires);
+            add_task_abs(&expires, &e->tqe, pmip_timer_retrans_pbu_handler);
+            dbg("PBU Retransmissions timer is triggered again....\n");
+            mutex_return_code = pthread_rwlock_unlock(&e->lock);
+            if (mutex_return_code != 0) {
+                dbg("pthread_rwlock_unlock(&e->lock) %s\n", strerror(mutex_return_code));
+            }
+        }
+    }
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_timer_bce_expired_handler(struct tq_elem *tqe)
+{
+    int mutex_return_code;
+    mutex_return_code = pthread_rwlock_wrlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    printf("-------------------------------------\n");
+    if (!task_interrupted()) {
+        pmip_entry_t *e = tq_data(tqe, pmip_entry_t, tqe);
+        mutex_return_code = pthread_rwlock_wrlock(&e->lock);
+        if (mutex_return_code != 0) {
+            dbg("pthread_rwlock_wrlock(&e->lock) %s\n", strerror(mutex_return_code));
+        }
+        dbg("Retransmissions counter : %d\n", e->n_rets_counter);
+        if (e->n_rets_counter == 0) {
+            dbg("Retransmissions counter expired\n");
+            free_iov_data((struct iovec *) &e->mh_vec, e->iovlen);
+            if (is_mag()) {
+                //++e->seqno_out;
+                dbg("Calling deregistration\n");
+                mag_dereg(e, 1);
+                pmipcache_release_entry(e);
+                pmip_bce_delete(e);
+                return;
+            }
+            //Delete existing route for the deleted MN
+            if (is_ha()) {
+                lma_dereg(e, 0, 0);
+                pmipcache_release_entry(e);
+                pmip_bce_delete(e);
+                return;
+            }
+            mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+            if (mutex_return_code != 0) {
+                dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+            }
+            return;
+        }
+        if (is_mag()) {
+            dbg("Send NS for Neighbour Reachability for:%x:%x:%x:%x:%x:%x:%x:%x iif=%d\n", NIP6ADDR(&e->mn_hw_address), e->link);
+            //Create NS for Reachability test!
+            //ndisc_send_ns(e->link, &conf.MagAddressIngress[0], solicited_mcast(&e->mn_suffix), get_mn_addr(e));
+            ndisc_send_ns(e->link, get_mn_addr(e));
+
+
+            struct timespec expires;
+            clock_gettime(CLOCK_REALTIME, &e->add_time);
+            tsadd(e->add_time, conf.RetransmissionTimeOut, expires);
+            // Add a new task for deletion of entry if No Na is received.
+            add_task_abs(&expires, &e->tqe, pmip_timer_bce_expired_handler);
+            dbg("Start the Timer for Retransmission/Deletion ....\n");
+            //Decrements the Retransmissions counter.
+            e->n_rets_counter--;
+            mutex_return_code = pthread_rwlock_unlock(&e->lock);
+            if (mutex_return_code != 0) {
+                dbg("pthread_rwlock_unlock(&e->lock) %s\n", strerror(mutex_return_code));
+            }
+        }
+        if (is_ha()) {
+            lma_dereg(e, 0, 0);
+            pmipcache_release_entry(e);
+            pmip_bce_delete(e);
+            return;
+        }
+    }
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_timer_tunnel_expired_handler(struct tq_elem *tqe)
+{
+    int mutex_return_code;
+
+    mutex_return_code = pthread_rwlock_wrlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+    printf("-------------------------------------\n");
+    printf("-pmip_timer_tunnel_expired_handler()-\n");
+    printf("-------------------------------------\n");
+    if (!task_interrupted()) {
+        tunnel_timer_t *tt = container_of(tqe, tunnel_timer_t, tqe);
+        tunnel_del(tt->tunnel, 0, 0);
+        tt->lifetime.tv_nsec = 0;
+        tt->lifetime.tv_sec  = 0;
+    }
+    mutex_return_code = pthread_rwlock_unlock(&pmip_lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&pmip_lock) %s\n", strerror(mutex_return_code));
+    }
+}
+
+
+/**
+ * Handlers defined for MH and ICMP messages.
+ **/
+
+/*!
+ * check if address is solicited multicast
+ * \param addr
+ * \return value <> 0 if true
+ */
+static inline int ipv6_addr_is_solicited_mcast(const struct in6_addr *addr)
+{
+    return (addr->s6_addr32[0] == htonl(0xff020000)
+            && addr->s6_addr32[1] == htonl(0x00000000)
+            && addr->s6_addr32[2] == htonl(0x00000001)
+            && addr->s6_addr[12] == 0xff);
+}
+
+/*!
+ * check if address is multicast
+ * \param addr
+ * \return value <> 0 if true
+ */
+static inline int ipv6_addr_is_multicast(const struct in6_addr *addr)
+{
+    return (addr->s6_addr32[0] & htonl(0xFF000000)) == htonl(0xFF000000);
+}
+
+/*!
+ * check if address is linklocal
+ * \param addr
+ * \return value <> 0 if true
+ */
+static inline int ipv6_addr_is_linklocal(const struct in6_addr *addr)
+{
+    return IN6_IS_ADDR_LINKLOCAL(addr);
+}
+
+
+/*!
+ * handler called when receiving a router solicitation
+ */
+//hip
+static void pmip_mag_recv_rs(const struct icmp6_hdr *ih, __attribute__ ((unused)) ssize_t len, const struct in6_addr *saddr, const struct in6_addr *daddr, int iif, int hoplimit)
+{
+    dbg("\n");
+    dbg("Router Solicitation received \n");
+    printf("-------------------------------------\n");
+    dbg("Router Solicitation (RS) Received iif %d\n", iif);
+    dbg("Received RS Src Addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(saddr));
+    dbg("Received RS Dst addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(daddr));
+    msg_info_t rs_info;
+    bzero(&rs_info, sizeof(rs_info));
+    icmp_rs_parse(&rs_info, (struct nd_router_solicit *) ih, saddr, daddr, iif, hoplimit);
+    mag_fsm(&rs_info);
+}
+
+/*!
+ * handler called when receiving a proxy binding acknowledgment
+ */
+static void pmip_mag_recv_pba(const struct ip6_mh *mh, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif)
+{
+    printf("=====================================\n");
+    dbg("Proxy Binding Acknowledgement (PBA) Received\n");
+    dbg("Received PBA Src Addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(in_addrs->src));
+    dbg("Received PBA Dst addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(in_addrs->dst));
+    //define the values for calling the parsing function
+    //call the parsing function
+    struct ip6_mh_binding_ack *pba;
+    //call the fsm function.
+    msg_info_t info;
+    pba = (struct ip6_mh_binding_ack *) ((void *) mh);
+    mh_pba_parse(&info, pba, len, in_addrs, iif);
+    mag_fsm(&info);
+}
+
+
+/*!
+ * handler called when receiving a proxy binding update
+ */
+void pmip_lma_recv_pbu(const struct ip6_mh *mh, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif)
+{
+    printf("=====================================\n");
+    dbg("Proxy Binding Update (PBU) Received\n");
+    dbg("Received PBU Src Addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(in_addrs->src));
+    dbg("Received PBU Dst addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(in_addrs->dst));
+    //define the values for the parsing function
+    //call the parsing function
+    struct ip6_mh_binding_update *pbu = (struct ip6_mh_binding_update *) mh;
+    //call the fsm function.
+    msg_info_t info;
+    bzero(&info, sizeof(info));
+    mh_pbu_parse(&info, pbu, len, in_addrs, iif);
+    lma_fsm(&info);
+}
+
+/*!
+ * handler called when MAG receive a neighbor advertisement
+ */
+static void pmip_mag_recv_na(const struct icmp6_hdr *ih, ssize_t len, const struct in6_addr *saddr, const struct in6_addr *daddr, int iif, int hoplimit)
+{
+    // define the MN identifier
+    //struct in6_addr id = in6addr_any;
+    struct nd_neighbor_advert *msg = (struct nd_neighbor_advert *) ih;
+    //Check target is not link local address.
+    if (ipv6_addr_is_linklocal(&msg->nd_na_target)) {
+        return;
+    }
+    //Check target is not multicast.
+    if (ipv6_addr_is_multicast(&msg->nd_na_target)) {
+        return;
+    }
+    if (len - sizeof(struct nd_neighbor_advert) > 0) {
+        printf("-------------------------------------\n");
+        dbg("Neighbor Advertisement (NA) Received\n");
+        dbg("Received NA Src Addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(saddr));
+        dbg("Received NA Dst addr: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(daddr));
+        msg_info_t na_info;
+        bzero(&na_info, sizeof(na_info));
+        icmp_na_parse(&na_info, (struct nd_neighbor_advert *) ih, saddr, daddr, iif, hoplimit);
+        mag_fsm(&na_info);
+    }
+    return;
+}
+
+
+struct icmp6_handler pmip_mag_rs_handler = {
+        .recv = pmip_mag_recv_rs
+};
+
+struct mh_handler pmip_mag_pba_handler = {
+        .recv = pmip_mag_recv_pba
+};
+struct mh_handler pmip_lma_pbu_handler = {
+        .recv = pmip_lma_recv_pbu
+};
+struct icmp6_handler pmip_mag_recv_na_handler = {
+        .recv = pmip_mag_recv_na
+};
diff -Nur umip/src/pmip/pmip_handler.h umip-pmipv6/src/pmip/pmip_handler.h
--- umip/src/pmip/pmip_handler.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_handler.h	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,116 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_handler.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup HANDLER MESSAGE HANDLER
+ * \ingroup PMIP6D
+ *  PMIP Handler
+ *  @{
+ */
+
+#ifndef __PMIP_HANDLER_H__
+#    define __PMIP_HANDLER_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_HANDLER_C
+#        define private_pmip_handler(x) x
+#        define protected_pmip_handler(x) x
+#        define public_pmip_handler(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_handler(x)
+#            define protected_pmip_handler(x) extern x
+#            define public_pmip_handler(x) extern x
+#        else
+#            define private_pmip_handler(x)
+#            define protected_pmip_handler(x)
+#            define public_pmip_handler(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+#    include <netinet/ip6mh.h>
+#    include "pmip_cache.h"
+#    include "pmip_tunnel.h"
+//-----------------------------------------------------------------------------
+protected_pmip_handler(struct icmp6_handler pmip_mag_rs_handler;)
+protected_pmip_handler(struct mh_handler    pmip_mag_pba_handler;)
+protected_pmip_handler(struct mh_handler    pmip_lma_pbu_handler;)
+protected_pmip_handler(struct icmp6_handler pmip_mag_recv_na_handler;)
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn struct in6_addr  *link_local_addr(struct in6_addr *id)
+* \brief
+* \param[in]  id The "ethernet type" address.
+* \return   The link local address corresponding to the supplied ethernet address.
+*/
+protected_pmip_handler(struct in6_addr  *link_local_addr(struct in6_addr *id);)
+/*! \fn struct in6_addr  *CONVERT_ID2ADDR(struct in6_addr *result, struct in6_addr *prefix, struct in6_addr *id)
+* \brief Converts an ID & a prefix into an address.
+* \param[out] result The final address.
+* \param[in]  prefix The prefix of the address.
+* \param[in]  id     The "ethernet type" address.
+* \return   The final address.
+*/
+protected_pmip_handler(struct in6_addr  *CONVERT_ID2ADDR(struct in6_addr *result, struct in6_addr *prefix, struct in6_addr *id);)
+/*! \fn struct in6_addr  *get_mn_addr(pmip_entry_t * bce)
+* \brief   Computes the address of the mobile node corresponding to the supplied binding cache entry, store it in the binding cache entry and return it.
+* \param[in]  bce A binding cache entry
+* \return   The address of the mobile node.
+* \note		The returned address is returned using CONVERT_ID2ADDR function.
+*/
+protected_pmip_handler(struct in6_addr  *get_mn_addr(pmip_entry_t * bce);)
+/*! \fn struct in6_addr  *solicited_mcast(struct in6_addr *id)
+* \brief  Converts an ethernet address into a Multicast Address for NS Unreachability
+* \param[in]  id The "ethernet type" address of a mobile node.
+* \return   The corresponding multicast address.
+*/
+protected_pmip_handler(struct in6_addr  *solicited_mcast(struct in6_addr *id);)
+/*! \fn  void             pmip_timer_retrans_pbu_handler(struct tq_elem *tqe)
+* \brief  Handler triggered by add_task_abs for entry expiry and deletion, retransmit PBU
+* \param[in]  tqe A task queue element
+*/
+private_pmip_handler(  void             pmip_timer_retrans_pbu_handler(struct tq_elem *tqe);)
+/*! \fn void             pmip_timer_bce_expired_handler(struct tq_elem *tqe)
+* \brief  Handler triggered by add_task_abs for entry expiry and deletion, expire PMIP binding cache entry and NS on MAG
+* \param[in]  tqe A task queue element
+*/
+protected_pmip_handler(void             pmip_timer_bce_expired_handler(struct tq_elem *tqe);)
+/*! \fn void             pmip_timer_tunnel_expired_handler(struct tq_elem *tqe)
+* \brief  Handler triggered by add_task_abs for tunnel expiry and deletion
+* \param[in]  tqe A task queue element
+*/
+protected_pmip_handler(void             pmip_timer_tunnel_expired_handler(struct tq_elem *tqe);)
+
+/*! \fn void pmip_lma_recv_pbu(const struct ip6_mh *mh, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif)
+ * \brief  Handler triggered by the reception of a PBU with P flag set
+ * \param[in]  mh       Mobility header
+ * \param[in]  len      size of message
+ * \param[in]  in_addrs Bundle of address (src and dst)
+ * \param[in]  iif      Interface id
+ */
+public_pmip_handler(void pmip_lma_recv_pbu(const struct ip6_mh *mh, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif);)
+
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip_hnp_cache.c umip-pmipv6/src/pmip/pmip_hnp_cache.c
--- umip/src/pmip/pmip_hnp_cache.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_hnp_cache.c	2013-12-22 18:47:04.000000000 +0100
@@ -0,0 +1,376 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_hnp_cache.c
+* \brief PMIP binding cache functions
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+#define PMIP
+#define PMIP_HNP_CACHE_C
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <stdlib.h>
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_hnp_cache.h"
+#include "pmip_consts.h"
+//---------------------------------------------------------------------------------------------------------------------
+#ifdef USE_RADIUS
+#   include "freeradius-client.h"
+#else
+#   include <ctype.h>
+#endif
+#include "util.h"
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//---------------------------------------------------------------------------------------------------------------------
+/*! \var mnid_hnp_t 			g_mn_hn_map[MAX_MOBILES]
+\brief Global array containing all "network prefix/interface id" known for a MAG.
+*/
+static mnid_hnp_t 			g_mn_hn_map[MAX_MOBILES];
+/*! \var int 					g_mn_count
+\brief Number of elements in g_mn_hn_map.
+*/
+static int 					g_mn_count = 0;
+#ifdef USE_RADIUS
+#	define CACHE_RADIUS
+#	define RADIUS_MSG_MAX_SIZE      4096
+#	define RADIUS_USERNAME_MAX_SIZE 256
+/*! \var rc_handle*			g_rh
+\brief Handle on free radius client.
+*/
+static rc_handle*			g_rh       = NULL;
+static char*				g_default_realm = NULL;
+/*! \var char 				msg[RADIUS_MSG_MAX_SIZE]
+\brief Array of bytes potentialy containing a message received from radius server.
+*/
+static char 				msg[RADIUS_MSG_MAX_SIZE];
+/*! \var char					g_username[RADIUS_USERNAME_MAX_SIZE]
+\brief String containing the username for authenticating on the radius server.
+*/
+static char					g_username[RADIUS_USERNAME_MAX_SIZE];
+/*! \var char					g_username_realm[RADIUS_USERNAME_MAX_SIZE]
+\brief String containing the username realm for authenticating on the radius server.
+*/
+static char					g_username_realm[RADIUS_USERNAME_MAX_SIZE];
+/*! \var char					g_passwd[AUTH_PASS_LEN + 1]
+\brief String containing the password for authenticating on the radius server.
+*/
+static char					g_passwd[AUTH_PASS_LEN + 1];
+#endif
+//-----------------------------------------------------------------------------
+struct in6_addr EUI64_to_EUI48(struct in6_addr iid)
+{
+	struct in6_addr macaddr;
+	macaddr.s6_addr[0]  = 0;
+	macaddr.s6_addr[1]  = 0;
+	macaddr.s6_addr[2]  = 0;
+	macaddr.s6_addr[3]  = 0;
+	macaddr.s6_addr[4]  = 0;
+	macaddr.s6_addr[5]  = 0;
+	macaddr.s6_addr[6]  = 0;
+	macaddr.s6_addr[7]  = 0;
+	macaddr.s6_addr[8]  = 0;
+	macaddr.s6_addr[9]  = 0;
+	macaddr.s6_addr[10] = iid.s6_addr[8] ^ 0x02;
+	macaddr.s6_addr[11] = iid.s6_addr[9];
+	macaddr.s6_addr[12] = iid.s6_addr[10];
+	macaddr.s6_addr[13] = iid.s6_addr[13];
+	macaddr.s6_addr[14] = iid.s6_addr[14];
+	macaddr.s6_addr[15] = iid.s6_addr[15];
+	return macaddr;
+}
+//-----------------------------------------------------------------------------
+struct in6_addr EUI48_to_EUI64(struct in6_addr macaddr)
+{
+	struct in6_addr iid;
+	iid.s6_addr[0]  = 0;
+	iid.s6_addr[1]  = 0;
+	iid.s6_addr[2]  = 0;
+	iid.s6_addr[3]  = 0;
+	iid.s6_addr[4]  = 0;
+	iid.s6_addr[5]  = 0;
+	iid.s6_addr[6]  = 0;
+	iid.s6_addr[7]  = 0;
+	iid.s6_addr[8]  = macaddr.s6_addr[10] ^ 0x02;
+	iid.s6_addr[9]  = macaddr.s6_addr[11];
+	iid.s6_addr[10] = macaddr.s6_addr[12];
+	iid.s6_addr[11] = 0xFF;
+	iid.s6_addr[12] = 0xFE;
+	iid.s6_addr[13] = macaddr.s6_addr[13];
+	iid.s6_addr[14] = macaddr.s6_addr[14];
+	iid.s6_addr[15] = macaddr.s6_addr[15];
+	return iid;
+}
+//-----------------------------------------------------------------------------
+void pmip_insert_into_hnp_cache(struct in6_addr mn_iid, struct in6_addr addr)
+{
+    int j = 0;
+    while (j < g_mn_count) {
+        if (IN6_ARE_ADDR_EQUAL(&g_mn_hn_map[j].mn_iid, &mn_iid)) {
+            dbg("mnid %x:%x:%x:%x:%x:%x:%x:%x already in cache, updating addr %x:%x:%x:%x:%x:%x:%x:%x -> %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&g_mn_hn_map[j].mn_iid), NIP6ADDR(&g_mn_hn_map[j].mn_prefix), NIP6ADDR(&addr));
+            g_mn_hn_map[j].mn_prefix = addr;
+            return;
+        }
+        j++;
+    }
+    if (g_mn_count < MAX_MOBILES) {
+        g_mn_hn_map[g_mn_count].mn_prefix = addr;
+        g_mn_hn_map[g_mn_count].mn_iid = mn_iid;
+        dbg("new entry in cache %x:%x:%x:%x:%x:%x:%x:%x -> %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&g_mn_hn_map[g_mn_count].mn_prefix), NIP6ADDR(&g_mn_hn_map[g_mn_count].mn_iid));
+        g_mn_count = g_mn_count + 1;
+    } else {
+        dbg("ERROR COULD NOT PUT NEW ENTRY IN CACHE %x:%x:%x:%x:%x:%x:%x:%x -> %x:%x:%x:%x:%x:%x:%x:%x MAX ENTRIES REACHED\n", NIP6ADDR(&addr), NIP6ADDR(&mn_iid));
+    }
+}
+//-----------------------------------------------------------------------------
+void pmip_lma_mn_to_hnp_cache_init(void)
+{
+    memset((void*)g_mn_hn_map, 0, sizeof(mnid_hnp_t) * MAX_MOBILES);
+}
+//-----------------------------------------------------------------------------
+struct in6_addr lma_mnid_hnp_map(struct in6_addr mnid, int *result)
+{
+    int j = 0;
+    dbg("Entering the address match . . ");
+    dbg("Searching for MNID  %x:%x:%x:%x:%x:%x:%x:%x  \n", NIP6ADDR(&mnid));
+    while (j < g_mn_count) {
+        dbg("Comparing with MNID  %x:%x:%x:%x:%x:%x:%x:%x  \n", NIP6ADDR(&g_mn_hn_map[j].mn_iid));
+        if (IN6_ARE_ADDR_EQUAL(&g_mn_hn_map[j].mn_iid, &mnid)) {
+            *result = 1;
+            dbg("%x:%x:%x:%x:%x:%x:%x:%x found the prefix \n", NIP6ADDR(&g_mn_hn_map[j].mn_prefix));
+            return (g_mn_hn_map[j].mn_prefix);
+        }
+        j++;
+    }
+    dbg("mnid not found ");
+
+    struct in6_addr tmp;
+    memset(&tmp, 0, sizeof(struct in6_addr));
+    *result = -1;
+    return tmp;
+}
+//-----------------------------------------------------------------------------
+
+#ifdef USE_RADIUS
+int pmip_mn_to_hnp_cache_init(void)
+{
+    dbg ("\n");
+    memset(g_mn_hn_map, 0, sizeof(mnid_hnp_t) * MAX_MOBILES);
+    rc_openlog("pmip_radius_client");
+    if ((g_rh = rc_read_config(conf.RadiusClientConfigFile)) == NULL) {
+       dbg ("ERROR INIT CLIENT RADIUS\n");
+        return ERROR_RC;
+    } else {
+        dbg ("RADIUS client radius read config file OK\n");
+    }
+
+    if (rc_read_dictionary(g_rh, rc_conf_str(g_rh, "dictionary")) != 0) {
+        dbg ("ERROR INIT CLIENT RADIUS DICTIONNARY\n");
+        return ERROR_RC;
+    } else {
+        dbg ("client radius read dictionnary file OK\n");
+    }
+    g_default_realm = rc_conf_str(g_rh, "default_realm");
+    return 0;
+}
+#else
+static void trim(char * s) {
+    char * p = s;
+    int l = strlen(p);
+
+    while(isspace(p[l - 1])) p[--l] = 0;
+    while(* p && isspace(* p)) ++p, --l;
+
+    memmove(s, p, l + 1);
+}
+
+int pmip_mn_to_hnp_cache_init (void)
+{
+    FILE               *fp;
+
+    char                line [256];
+    char                str_addr[40], str_addr_iid[40];
+
+    struct in6_addr     addr, addr1;
+
+    unsigned int        ap, ap1;
+
+    int                 i, j;
+
+    memset(g_mn_hn_map, 0, sizeof(mnid_hnp_t) * MAX_MOBILES);
+    j = 0;
+    if ((fp = fopen ("/etc/pmip/mac-mapping.auth", "r")) == NULL) {
+        printf ("can't open %s:", "/etc/pmip/mac-mapping.auth");
+        exit (0);
+    }
+    while ( fgets ( line, sizeof line, fp ) != NULL ) {
+        trim(line);
+        // if line is not a comment
+        if (strncmp("#", line, 1) != 0) {
+            //while ((fscanf (fp, "%32s %16s\n", str_addr, str_addr_iid) != EOF) && (j < MAX_MOBILES)) {
+            if ((sscanf (line, "%32s %16s\n", str_addr, str_addr_iid) != EOF) && (j < MAX_MOBILES)) {
+                for (i = 0; i < 16; i++) {
+                    sscanf (str_addr + i * 2, "%02x", &ap);
+                    addr.s6_addr[i] = (unsigned char) ap;
+                    g_mn_hn_map[j].mn_prefix = addr;
+
+                    addr1.s6_addr[i] = 0;
+                }
+                for (i = 0; i < 8; i++) {
+                    sscanf (str_addr_iid + i * 2, "%02x", &ap1);
+                    addr1.s6_addr[i+8] = (unsigned char) ap1;
+                    g_mn_hn_map[j].mn_iid = addr1;
+                }
+                dbg ("%x:%x:%x:%x:%x:%x:%x:%x\t<->\t%x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR (&g_mn_hn_map[j].mn_prefix), NIP6ADDR (&g_mn_hn_map[j].mn_iid));
+                j++;
+                g_mn_count = g_mn_count + 1;
+            }
+        }
+    }
+    fclose (fp);
+    if (j >= MAX_MOBILES) {
+        dbg ("ERROR TOO MANY MAPPINGS DEFINED IN CONFIG FILE\n");
+        exit (0);
+    }
+    return 0;
+}
+#endif
+//-----------------------------------------------------------------------------
+
+/*!
+*  Search if the mobile node id is already associated with a prefix in the hnp map
+* \param mnid Mobile node ID
+* \return a valid prefix if the mobile node id is already associated with a prefix in the hnp map
+*/
+struct in6_addr mnid_hnp_map(struct in6_addr mnid, int *aaa_result)
+{
+    //int l_flag = 0;
+#if !defined (USE_RADIUS) || defined(CACHE_RADIUS)
+    int j = 0;
+    dbg("Entering the address match . . \n");
+    dbg("Searching for MNID  %x:%x:%x:%x:%x:%x:%x:%x  \n", NIP6ADDR(&mnid));
+    while (j < g_mn_count) {
+        dbg("Comparing with MNID  %x:%x:%x:%x:%x:%x:%x:%x  \n", NIP6ADDR(&g_mn_hn_map[j].mn_iid));
+        if (IN6_ARE_ADDR_EQUAL(&g_mn_hn_map[j].mn_iid, &mnid)) {
+            //l_flag = 1;
+            dbg("%x:%x:%x:%x:%x:%x:%x:%x found the prefix \n", NIP6ADDR(&g_mn_hn_map[j].mn_prefix));
+            *aaa_result = 10;
+            return (g_mn_hn_map[j].mn_prefix);
+        }
+        j++;
+    }
+    #ifdef CACHE_RADIUS
+    dbg("MNID not in cache  %x:%x:%x:%x:%x:%x:%x:%x  \n", NIP6ADDR(&mnid));
+    #endif
+#endif
+
+#if defined (USE_RADIUS)
+
+    VALUE_PAIR *send, *received;
+    VALUE_PAIR *vp;
+    struct in6_addr prefix;
+    uint32_t service;
+
+    *aaa_result = 0;
+     send = NULL;
+
+    sprintf(g_username, "%04x%04x%04x%04x", ntohs(mnid.s6_addr16[4]), ntohs(mnid.s6_addr16[5]), ntohs(mnid.s6_addr16[6]), ntohs(mnid.s6_addr16[7]));
+    g_username[16] = 0;
+    memset(g_passwd, '\0', AUTH_PASS_LEN + 1);
+    strncpy(g_passwd, conf.RadiusPassword, strlen(conf.RadiusPassword));
+    g_passwd[strlen(conf.RadiusPassword)] = '\0';
+// Fill in User-Name
+
+    strncpy(g_username_realm, g_username, sizeof(g_username_realm));
+// Append default realm
+    if ((strchr(g_username_realm, '@') == NULL) && g_default_realm && (*g_default_realm != '\0')) {
+        strncat(g_username_realm, "@", sizeof(g_username_realm) - strlen(g_username_realm) - 1);
+        strncat(g_username_realm, g_default_realm, sizeof(g_username_realm) - strlen(g_username_realm) - 1);
+    }
+    dbg("RADIUS USER NAME %s\n", g_username_realm);
+    dbg("RADIUS PASSWORD  %s\n", g_passwd);
+    if (rc_avpair_add(g_rh, &send, PW_USER_NAME, g_username_realm, -1, 0) == NULL) {
+        fprintf(stderr, "[RADIUS] ERROR rc_avpair_add PW_USER_NAME\n");
+    } else {
+//
+// Fill in User-Password
+
+    if (rc_avpair_add(g_rh, &send, PW_USER_PASSWORD, g_passwd, -1, 0) == NULL) {
+        fprintf(stderr, "[RADIUS] ERROR rc_avpair_add PW_USER_PASSWORD\n");
+    } else {
+
+// Fill in Service-Type
+
+        service = PW_AUTHENTICATE_ONLY;
+        if (rc_avpair_add(g_rh, &send, PW_SERVICE_TYPE, &service, -1, 0) == NULL) {
+            fprintf(stderr, "[RADIUS] ERROR rc_avpair_add PW_SERVICE_TYPE\n");
+        } else {
+            // result = RESULT always < 0 !!!
+            rc_auth(g_rh, 0, send, &received, msg);
+            {
+                *aaa_result = 0;
+                if (received != NULL) {
+                    if ((vp = rc_avpair_get(received, PW_FRAMED_IPV6_PREFIX, 0)) != NULL) {
+                        *aaa_result += 1;
+                        int netmask = vp->strvalue[1];
+                        int num_bytes = netmask / 8;
+                        int i;
+                        for (i = 0; i < num_bytes; i++) {
+                            prefix.s6_addr[i] = vp->strvalue[2 + i];
+                        }
+                        for (i = num_bytes; i < 16; i++) {
+                            prefix.s6_addr[i] = 0;
+                        }
+                    }
+                    if ((vp = rc_avpair_get(received, PW_FRAMED_INTERFACE_ID, 0)) != NULL) {
+                        *aaa_result += 1;
+                        int i;
+                        for (i = 0; i < 8; i++) {
+                            prefix.s6_addr[8 + i] = prefix.s6_addr[8 + i] | vp->strvalue[i];
+                        }
+                    }
+                    rc_avpair_free(received);
+                }
+                if (*aaa_result >= 2) {
+                    //l_flag = 1;
+                    dbg("[RADIUS] Assigned IPv6 @ for MN UID %x:%x:%x:%x:%x:%x:%x:%x <=> %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&mnid), NIP6ADDR(&prefix));
+                    dbg("[RADIUS] \"%s\" Authentication OK\n", g_username);
+                    pmip_insert_into_hnp_cache(mnid, prefix);
+                    return prefix;
+                }
+            }
+        }
+    }
+    }
+#endif
+    dbg("mnid not found\n");
+    struct in6_addr tmp;
+    memset(&tmp, 0, sizeof(struct in6_addr));
+    *aaa_result = -1;
+    return tmp;
+}
+
diff -Nur umip/src/pmip/pmip_hnp_cache.h umip-pmipv6/src/pmip/pmip_hnp_cache.h
--- umip/src/pmip/pmip_hnp_cache.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_hnp_cache.h	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,108 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_hnp_cache.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/**
+ * \ingroup PMIP6D
+ * \defgroup HNP_CACHE HOME NETWORK PREFIX CACHE
+ *  PMIP HNP Cache
+ *  @{
+ */
+
+#ifndef __PMIP_HNP_CACHE_H__
+#    define __PMIP_HNP_CACHE_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_HNP_CACHE_C
+#        define private_pmip_hnp_cache(x) x
+#        define protected_pmip_hnp_cache(x) x
+#        define public_pmip_hnp_cache(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_hnp_cache(x)
+#            define protected_pmip_hnp_cache(x) extern x
+#            define public_pmip_hnp_cache(x) extern x
+#        else
+#            define private_pmip_hnp_cache(x)
+#            define protected_pmip_hnp_cache(x)
+#            define public_pmip_hnp_cache(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+#include <netinet/ip6.h>
+//-----------------------------------------------------------------------------
+/*! \struct  mnid_hnp_t
+* \brief Data structure to store the association of a network prefix and a mobile interface identifier.
+*/typedef struct mnid_hnp_t {
+    struct in6_addr mn_prefix;  /*!< \brief Network Address Prefix for mobile node */
+    struct in6_addr mn_iid;     /*!< \brief Mobile node MAC address (IID) */
+} mnid_hnp_t;
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn struct in6_addr EUI64_to_EUI48(struct in6_addr )
+* \brief Translate an interface id (ipv6 suffix of 8 bytes) into a MAC address (6 bytes)
+* \param[in]  iid A IPV6 interface id
+* \return   The computed MAC address.
+*/
+protected_pmip_hnp_cache(struct in6_addr EUI64_to_EUI48(struct in6_addr iid);)
+/*! \fn struct in6_addr EUI48_to_EUI64(struct in6_addr )
+* \brief Translate a MAC address (6 bytes) into an interface id (ipv6 suffix of 8 bytes).
+* \param[in]  macaddr A MAC address.
+* \return   The IPV6 interface id.
+*/
+protected_pmip_hnp_cache(struct in6_addr EUI48_to_EUI64(struct in6_addr macaddr);)
+/*! \fn void pmip_insert_into_hnp_cache(struct in6_addr mn_iid, struct in6_addr addr)
+* \brief Insert into the cache, the mapping between the mobile node iid and the assigned ipv6 address.
+* \param[in]  mn_iid Mobile node interface identifier (MAC address).
+* \param[in]  addr   Network Address Prefix for the mobile node
+* \note This function check for duplicates
+*/
+protected_pmip_hnp_cache(void pmip_insert_into_hnp_cache(struct in6_addr mn_iid, struct in6_addr addr);)
+/*! \fn void pmip_lma_mn_to_hnp_cache_init(void)
+* \brief Initialize the home network prefix cache in the LMA.
+*/
+protected_pmip_hnp_cache(void pmip_lma_mn_to_hnp_cache_init(void);)
+/*! \fn struct in6_addr lma_mnid_hnp_map(struct in6_addr mnid, int *result)
+* \brief Search if the mobile node id is already associated with a prefix in the hnp map.
+* \param[in]  mn_iid     Mobile node interface identifier (MAC address).
+* \param[in]  result     Status of the search, 0 if success, else -1
+* \return   A valid prefix if the mobile node id is already associated with a prefix in the hnp map.
+*/
+protected_pmip_hnp_cache(struct in6_addr lma_mnid_hnp_map(struct in6_addr mnid, int *aaa_result);)
+/*! \fn int pmip_mn_to_hnp_cache_init(void)
+* \brief Initialize the home network prefix cache, if RADIUS is not configured the matching between MAC addresse and prefixes is read from a FILE "match".
+* \return   Zero if success, else other values.
+*/
+protected_pmip_hnp_cache(int pmip_mn_to_hnp_cache_init(void);)
+/*! \fn struct in6_addr mnid_hnp_map(struct in6_addr mnid, int *aaa_result)
+* \brief Search if the mobile node id is already associated with a prefix in the hnp map.
+* \param[in]  mn_iid     Mobile node interface identifier (MAC address).
+* \param[in]  aaa_result Status of the search, greater than, or equal to zero if success, else -1.
+* \return   A valid prefix if the mobile node id is already associated with a prefix in the hnp map.
+* \note   Called in MAG only. If the association is not found in the map, then the radius server is queried for a network prefix, once the response has been received, if successful, the association is stored in the cach, so the radius server will not be queried for this mobile node on this MAG, even if the mobile node leaves the geographical area covered by the MAG and re-enter again.
+*/
+protected_pmip_hnp_cache(struct in6_addr mnid_hnp_map(struct in6_addr mnid, int *aaa_result);)
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip_init.c umip-pmipv6/src/pmip/pmip_init.c
--- umip/src/pmip/pmip_init.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_init.c	2013-12-22 17:16:41.000000000 +0100
@@ -0,0 +1,249 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip6d.c
+* \brief The main PMIP6D file
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+#define PMIP
+#define PMIP_INIT_C
+//---------------------------------------------------------------------------------------------------------------------
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <unistd.h>
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_cache.h"
+#include "pmip_fsm.h"
+#include "pmip_handler.h"
+#include "pmip_hnp_cache.h"
+#include "pmip_init.h"
+#include "pmip_lma_proc.h"
+#include "pmip_mag_proc.h"
+#include "pmip_msgs.h"
+#include "pmip_pcap.h"
+#include "pmip_tunnel.h"
+#include "pmip_types.h"
+//---------------------------------------------------------------------------------------------------------------------
+#include "rtnl.h"
+#include "tunnelctl.h"
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+
+#define IPV6_ALL_SOLICITED_MCAST_ADDR 68
+//---------------------------------------------------------------------------------------------------------------------
+extern struct sock icmp6_sock;
+//---------------------------------------------------------------------------------------------------------------------
+void init_mag_icmp_sock(void)
+//---------------------------------------------------------------------------------------------------------------------
+{
+    if (0) {
+        int on = 1;
+        dbg("Set SOLRAW, IPV6_ALL_SOLICTED_MCAST_ADDR = %d\n", IPV6_ALL_SOLICITED_MCAST_ADDR);
+        if (setsockopt(icmp6_sock.fd, SOL_RAW, IPV6_ALL_SOLICITED_MCAST_ADDR, &on, sizeof(on)) < 0) {
+            perror("allow all solicited mcast address\n");
+        }
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+static int pmip_cache_delete_each(void *data, __attribute__ ((unused)) void *arg)
+//---------------------------------------------------------------------------------------------------------------------
+{
+    pmip_entry_t *bce = (pmip_entry_t *) data;
+    if (is_mag()) {
+        //Delete existing route & rule for the deleted MN
+        mag_remove_route(&bce->mn_addr, bce->link);
+        int usercount = tunnel_getusers(bce->tunnel);
+        dbg("# of binding entries %d \n", usercount);
+        if (usercount == 1) {
+            route_del(bce->tunnel, RT6_TABLE_PMIP, IP6_RT_PRIO_MIP6_FWD, &in6addr_any, 0, &in6addr_any, 0, NULL);
+        }
+        //decrement users of old tunnel.
+        pmip_tunnel_del(bce->tunnel);
+    }
+    //Delete existing route for the deleted MN
+    if (is_ha()) {
+        lma_remove_route(&bce->mn_addr, bce->tunnel);
+        //decrement users of old tunnel.
+        pmip_tunnel_del(bce->tunnel);
+    }
+    //Delete the Entry.
+    free_iov_data((struct iovec *) &bce->mh_vec, bce->iovlen);
+    pmip_bce_delete(bce);
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_cleanup(void)
+//---------------------------------------------------------------------------------------------------------------------
+{
+    //Release the pmip cache ==> deletes the routes and rules and "default route on PMIP" and tunnels created.
+    dbg("Release all occupied resources...\n");
+    //delete the default rule.
+    dbg("Remove default rule...\n");
+    rule_del(NULL, RT6_TABLE_MIP6, IP6_RULE_PRIO_MIP6_FWD, RTN_UNICAST, &in6addr_any, 0, &in6addr_any, 0, 0);
+
+    dbg("Release pmip_cache...\n");
+    pmip_cache_iterate(pmip_cache_delete_each, NULL);
+
+    if (is_mag()) {
+        pmip_pcap_loop_stop();
+    }
+    dbg("pmip_cleanup end\n");
+}
+
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_common_init(void)
+//---------------------------------------------------------------------------------------------------------------------
+{
+    /**
+    * Probe for the local address
+	**/
+    int probe_fd = socket(AF_INET6, SOCK_DGRAM, 0);
+    if (probe_fd < 0) {
+        perror("socket");
+        exit(2);
+    }
+    unsigned int alen;
+    struct sockaddr_in6 host;
+    struct sockaddr_in6 firsthop;
+
+    memset(&firsthop, 0, sizeof(firsthop));
+    firsthop.sin6_port = htons(1025);
+    firsthop.sin6_family = AF_INET6;
+    if (connect(probe_fd, (struct sockaddr *) &firsthop, sizeof(firsthop)) == -1) {
+        perror("connect");
+        return -1;;
+    }
+    alen = sizeof(host);
+    if (getsockname(probe_fd, (struct sockaddr *) &host, &alen) == -1) {
+        perror("probe getsockname");
+        return -1;;
+    }
+    close(probe_fd);
+
+
+    /**
+    * Initializes PMIP cache.
+    **/
+    if (pmip_cache_init() < 0) {
+        dbg("PMIP Binding Cache initialization failed! \n");
+        return -1;
+    } else {
+        dbg("PMIP Binding Cache is initialized!\n");
+    }
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_mag_init(void)
+//---------------------------------------------------------------------------------------------------------------------
+{
+    pmip_common_init();
+    /**
+     * Adds a default rule for RT6_TABLE_MIP6.
+     */
+    dbg("Add default rule for RT6_TABLE_MIP6\n");
+    if (rule_add(NULL, RT6_TABLE_MIP6, IP6_RULE_PRIO_MIP6_FWD, RTN_UNICAST, &in6addr_any, 0, &in6addr_any, 0, 0) < 0) {
+        dbg("Add default rule for RT6_TABLE_MIP6 failed, insufficient privilege/kernel options missing!\n");
+        return -1;
+    }
+
+    /**
+     * Initialize timers of tunnels (tunnels between LMA and MAGs).
+     */
+    if (pmip_tunnels_init() < 0) {
+        dbg("PMIP Tunnels initialization failed! \n");
+        return -1;
+    } else {
+        dbg("PMIP Tunnels are initialized!\n");
+    }
+
+    /**
+    *  Get iif of MN messages
+    */
+    mag_get_ingress_info(&g_ingress_iif, NULL);
+
+    conf.OurAddress = conf.MagAddressEgress[0];
+    conf.HomeNetworkPrefix = get_node_prefix(&conf.MagAddressIngress[0]); //copy Home network prefix.
+    dbg("Running as MAG entity\n");
+    dbg("Entity Egress Address: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&conf.OurAddress));
+    dbg("Entity Ingress Address: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&conf.MagAddressIngress[0]));
+    dbg("Home Network Prefix Address: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&conf.HomeNetworkPrefix));
+    if (mag_init_fsm() < 0) {
+        dbg("Initialization of FSM failed...exit\n");
+        exit(-1);
+    }
+
+    init_pbu_sequence_number();
+
+    init_iface_ra();
+    init_mag_icmp_sock();
+    dbg("Initializing the NA handler\n");
+    // to capture NA message
+    icmp6_handler_reg(ND_NEIGHBOR_ADVERT, &pmip_mag_recv_na_handler);
+    dbg("Initializing the RS handler\n");
+    // to capture RS message
+    icmp6_handler_reg(ND_ROUTER_SOLICIT, &pmip_mag_rs_handler);
+    dbg("Initializing the PBA handler\n");
+    //To capture PBA message.
+    mh_handler_reg(IP6_MH_TYPE_BACK, &pmip_mag_pba_handler);
+
+    /**
+    * Deletes the default route for MN prefix so routing is per unicast MN address!
+    **/
+    //route_del((int) NULL, RT6_TABLE_MAIN, IP6_RT_PRIO_ADDRCONF, &in6addr_any, 0, &conf.HomeNetworkPrefix, 64, NULL);
+    dbg("Initializing the HNP cache\n");
+    if (pmip_mn_to_hnp_cache_init() < 0) {
+        exit (-1);
+    }
+
+    dbg("Starting capturing AP messages for incoming MNs detection\n");
+    pmip_pcap_loop_start();
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_lma_init(void)
+//---------------------------------------------------------------------------------------------------------------------
+{
+    if (pmip_common_init() < 0) return -1;
+
+    /**
+     * Initialize timers of tunnels (tunnels between LMA and MAGs).
+     */
+    if (pmip_tunnels_init() < 0) {
+        dbg("PMIP Tunnels initialization failed! \n");
+        return -1;
+    } else {
+        dbg("PMIP Tunnels are initialized!\n");
+    }
+
+    pmip_lma_mn_to_hnp_cache_init();
+    conf.OurAddress = conf.LmaAddress;
+    dbg("Entity Address: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&conf.OurAddress));
+    dbg("Initializing the PBU handler\n");
+    //To capture PBU message.
+    //mh_handler_reg(IP6_MH_TYPE_BU, &pmip_lma_pbu_handler);
+    return 0;
+}
diff -Nur umip/src/pmip/pmip_init.h umip-pmipv6/src/pmip/pmip_init.h
--- umip/src/pmip/pmip_init.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_init.h	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,69 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+#ifndef __PMIP_INIT_H__
+#    define __PMIP_INIT_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_C
+#        define private_pmip_init(x) x
+#        define protected_pmip_init(x) x
+#        define public_pmip_init(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_init(x)
+#            define protected_pmip_init(x) extern x
+#            define public_pmip_init(x) extern x
+#        else
+#            define private_pmip_init(x)
+#            define protected_pmip_init(x)
+#            define public_pmip_init(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn void  init_mag_icmp_sock(void)
+* \brief Set necessary option on the icmpv6 socket.
+* @ingroup  PMIP6D
+*/
+private_pmip_init(void  init_mag_icmp_sock(void);)
+/*! \fn void  pmip_cleanup      (void)
+* \brief Release all resources handled by the LMA or MAG entity.
+* @ingroup  PMIP6D
+*/
+public_pmip_init( void  pmip_cleanup      (void);)
+/*! \fn int   pmip_common_init  (void)
+* \brief Initialization common to LMA and MAGs.
+* \return   Status of the initialization, zero if success, else -1.
+* @ingroup  PMIP6D
+*/
+private_pmip_init(int   pmip_common_init  (void);)
+/*! \fn int   pmip_mag_init  (void)
+* \brief Initialization of the MAG.
+* \return   Status of the initialization, zero if success, else -1.
+* \note   This function has to be called after pmip_common_init().
+* @ingroup  PMIP6D
+*/
+public_pmip_init( int   pmip_mag_init     (void);)
+/*! \fn int   pmip_lma_init  (void)
+* \brief Initialization of the LMA.
+* \return   Status of the initialization, zero if success, else -1.
+* \note   This function has to be called after pmip_common_init().
+* @ingroup  PMIP6D
+*/
+public_pmip_init( int   pmip_lma_init     (void);)
+#endif
diff -Nur umip/src/pmip/pmip_lma_proc.c umip-pmipv6/src/pmip/pmip_lma_proc.c
--- umip/src/pmip/pmip_lma_proc.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_lma_proc.c	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,211 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_lma_proc.c
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+#define PMIP
+#define PMIP_LMA_PROC_C
+#ifdef HAVE_CONFIG_H
+#    include <config.h>
+#endif
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_handler.h"
+#include "pmip_hnp_cache.h"
+#include "pmip_lma_proc.h"
+#include "pmip_tunnel.h"
+//---------------------------------------------------------------------------------------------------------------------
+#include "rtnl.h"
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//---------------------------------------------------------------------------------------------------------------------
+int lma_setup_route(struct in6_addr *pmip6_addr, int tunnel)
+{
+    int res = 0;
+    if (conf.TunnelingEnabled) {
+        dbg("Forward: Add new route for %x:%x:%x:%x:%x:%x:%x:%x in table %d\n", NIP6ADDR(pmip6_addr), RT6_TABLE_MIP6);
+        res = route_add(tunnel, RT6_TABLE_MIP6, RTPROT_MIP, 0, IP6_RT_PRIO_MIP6_FWD, &in6addr_any, 0, pmip6_addr, 128, NULL);
+    }
+    return res;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int lma_remove_route(struct in6_addr *pmip6_addr, int tunnel)
+{
+    int res = 0;
+    if (conf.TunnelingEnabled) {
+        //Delete existing rule for the deleted MN
+        dbg("Delete old route for: %x:%x:%x:%x:%x:%x:%x:%x from table %d\n", NIP6ADDR(pmip6_addr), RT6_TABLE_MIP6);
+        res = route_del(tunnel, RT6_TABLE_MIP6, IP6_RT_PRIO_MIP6_FWD, &in6addr_any, 0, pmip6_addr, 128, NULL);
+    }
+    return res;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int lma_reg(pmip_entry_t * bce)
+{
+    if (bce != NULL) {
+        //create a tunnel between MAG and LMA && add a route for peer address.
+        bce->tunnel = pmip_tunnel_add(&conf.OurAddress, &bce->mn_serv_mag_addr, bce->link);
+        lma_setup_route(get_mn_addr(bce), bce->tunnel);
+        bce->status = 0;        //PBU was Accepted!
+        //Add task for entry expiry.
+        pmip_cache_start(bce);
+        //Send a PBA to ack new serving MAG
+        dbg("Create PBA to new Serving MAG...\n");
+        struct in6_addr_bundle addrs;
+        addrs.src = &conf.OurAddress;
+        addrs.dst = &bce->mn_serv_mag_addr;
+        mh_send_pba(&addrs, bce, &bce->lifetime, 0);
+        return 0;
+    } else {
+        dbg("WARNING parameter pmip_entry_t * bce is NULL\n");
+        return -1;
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+int lma_reg_no_new_tunnel(pmip_entry_t * bce)
+{
+    if (bce != NULL) {
+        bce->status = 0;        //PBU was Accepted!
+        //Add task for entry expiry.
+        pmip_cache_start(bce);
+        //Send a PBA to ack new serving MAG
+        dbg("Create PBA to new Serving MAG...\n");
+        struct in6_addr_bundle addrs;
+        addrs.src = &conf.OurAddress;
+        addrs.dst = &bce->mn_serv_mag_addr;
+        mh_send_pba(&addrs, bce, &bce->lifetime, 0);
+        return 0;
+    } else {
+        dbg("WARNING parameter pmip_entry_t * bce is NULL\n");
+        return -1;
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+int lma_dereg(pmip_entry_t * bce, msg_info_t * info, int propagate)
+{
+    if (bce != NULL) {
+        //Delete the Task
+        del_task(&bce->tqe);
+        //delete old route to old tunnel.
+        lma_remove_route(get_mn_addr(bce), bce->tunnel);
+        //decrement users of old tunnel.
+        pmip_tunnel_del(bce->tunnel);
+        if (propagate) {
+            dbg("Create PBA for deregistration for MAG (%x:%x:%x:%x:%x:%x:%x:%x)\n", NIP6ADDR(&bce->mn_serv_mag_addr));
+            struct in6_addr_bundle addrs;
+            struct timespec lifetime = { 0, 0 };
+            addrs.src = &conf.LmaAddress;
+            addrs.dst = &bce->mn_serv_mag_addr;
+            bce->seqno_in = info->seqno;
+            mh_send_pba(&addrs, bce, &lifetime, 0);
+        } else {
+            dbg("Doing nothing....\n");
+        }
+        bce->type = BCE_NO_ENTRY;
+    } else {
+        dbg("WARNING parameter pmip_entry_t * bce is NULL\n");
+        return -1;
+    }
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int lma_update_binding_entry(pmip_entry_t * bce, msg_info_t * info)
+{
+	int result = 0;
+    if (bce != NULL) {
+        if (info != NULL) {
+            int result;
+            struct in6_addr r_tmp, r_tmp1;
+            memset(&r_tmp1, 0, sizeof(struct in6_addr));
+            dbg("Store Binding Entry\n");
+            bce->our_addr = conf.OurAddress;
+            bce->mn_suffix = info->mn_iid;
+            bce->mn_hw_address = EUI64_to_EUI48(info->mn_iid);
+            dbg("searching for the prefix for a new BCE entry...\n");
+            r_tmp = lma_mnid_hnp_map(bce->mn_hw_address, &result);
+            if (result >= 0) {
+                if (IN6_ARE_ADDR_EQUAL(&r_tmp, &info->mn_prefix)) {
+                    bce->mn_prefix = r_tmp;
+                    dbg("found the prefix  %x:%x:%x:%x:%x:%x:%x:%x in lma_update_binding entry \n", NIP6ADDR(&bce->mn_prefix));
+
+                    if (IN6_ARE_ADDR_EQUAL(&bce->mn_serv_mag_addr, &r_tmp1)) {
+                        dbg("First new serving MAG:  %x:%x:%x:%x:%x:%x:%x:%x  \n", NIP6ADDR(&info->src));
+                        result = 1;
+                    } else if (!(IN6_ARE_ADDR_EQUAL(&bce->mn_serv_mag_addr, &info->src))) {
+                        dbg("New serving MAG:  %x:%x:%x:%x:%x:%x:%x:%x  (Old MAG: %x:%x:%x:%x:%x:%x:%x:%x)\n", NIP6ADDR(&info->src), NIP6ADDR(&bce->mn_serv_mag_addr));
+                        //delete old route to old tunnel.
+                        lma_remove_route(get_mn_addr(bce), bce->tunnel);
+                        //decrement users of old tunnel.
+                        dbg("Deleting the old tunnel \n");
+                        pmip_tunnel_del(bce->tunnel);
+                        result = 1;
+                    } else {
+                        dbg("Same serving MAG: %x:%x:%x:%x:%x:%x:%x:%x, No need to delete tunnel\n", NIP6ADDR(&info->src));
+                        // to do here in future: cancel possible delete timer on this tunnel
+                        result = 0;
+                    }
+                } else {
+                    dbg("Mobine node prefix changed, delete route, tunnel\n");
+                    //delete old route to old tunnel.
+                    lma_remove_route(get_mn_addr(bce), bce->tunnel);
+                    //decrement users of old tunnel.
+                    pmip_tunnel_del(bce->tunnel);
+                    dbg("Deleting the old tunnel \n");
+                    result = 1;
+                }
+
+
+            }
+            bce->timestamp.first    = info->timestamp.first;
+            bce->timestamp.second   = info->timestamp.second;
+            bce->mn_prefix          = info->mn_prefix;
+            //bce->mn_addr            = info->mn_addr;
+            bce->mn_link_local_addr = info->mn_link_local_addr;
+            bce->mn_serv_mag_addr   = info->src;
+            bce->lifetime.tv_sec    = info->lifetime.tv_sec;
+            bce->lifetime.tv_nsec   = 0;
+            bce->n_rets_counter     = conf.MaxMessageRetransmissions;
+            bce->seqno_in           = info->seqno;
+
+			// update bce->mn_addr with bce->mn_prefix and bce->mn_suffix
+			get_mn_addr(bce);
+			
+            dbg("bce->link %d => %d\n", bce->link, info->iif);
+            bce->link               = info->iif;
+            dbg("Finished updating the binding cache\n");
+            return result;
+        } else {
+            dbg("WARNING parameter msg_info_t* info is NULL\n");
+            result = -1;
+            return result;
+        }
+    } else {
+        dbg("WARNING parameter pmip_entry_t * bce is NULL\n");
+        result = -1;
+        return result;
+    }
+}
diff -Nur umip/src/pmip/pmip_lma_proc.h umip-pmipv6/src/pmip/pmip_lma_proc.h
--- umip/src/pmip/pmip_lma_proc.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_lma_proc.h	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_lma_proc.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup LMA_Processing LMA_Processing
+ * \ingroup PMIP6D
+ *  PMIP Processing for LMA
+ *  @{
+ */
+
+#ifndef __PMIP_LMA_PROC_H__
+#    define __PMIP_LMA_PROC_H__
+//-----------------------------------------------------------------------------
+#   ifdef PMIP_LMA_PROC_C
+#       define private_pmip_lma_proc(x) x
+#       define protected_pmip_lma_proc(x) x
+#       define public_pmip_lma_proc(x) x
+#   else
+#       ifdef PMIP
+#           define private_pmip_lma_proc(x)
+#           define protected_pmip_lma_proc(x) extern x
+#           define public_pmip_lma_proc(x) extern x
+#       else
+#           define private_pmip_lma_proc(x)
+#           define protected_pmip_lma_proc(x)
+#           define public_pmip_lma_proc(x) extern x
+#       endif
+#   endif
+//-----------------------------------------------------------------------------
+#   include <netinet/ip6.h>
+#   include "pmip_cache.h"
+#   include "pmip_msgs.h"
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn int lma_setup_route(struct in6_addr *, int )
+* \brief Set a route by establishing a tunnel.
+* \param[in]  pmip6_addr Destination address
+* \param[in]  tunnel     Tunnel identifier
+* \return    Returns zero on success, negative otherwise.
+*/
+private_pmip_lma_proc(int lma_setup_route(struct in6_addr *pmip6_addr, int tunnel);)
+/*! \fn int lma_remove_route(struct in6_addr *pmip6_addr, int tunnel)
+* \brief  Remove a route established by a tunnel
+* \param[in]  pmip6_addr Destination address
+* \param[in]  tunnel     Tunnel identifier
+* \return   Returns zero on success, negative otherwise.
+*/
+protected_pmip_lma_proc(int lma_remove_route(struct in6_addr *pmip6_addr, int tunnel);)
+/*! \fn int lma_reg(pmip_entry_t * bce)
+* \brief  Register a binding cache entry, then create a tunnel between LMA and MAG (LMA->MAG) for this mobile node and add a route for peer address.
+* \param[in]  bce A binding cache entry
+* \return    Zero if bce is not NULL, else -1
+*/
+protected_pmip_lma_proc(int lma_reg(pmip_entry_t * bce);)
+/*! \fn int lma_reg_no_new_tunnel(pmip_entry_t * bce)
+* \brief  Register a binding cache entry.
+* \param[in]  bce A binding cache entry
+* \return    Zero if bce is not NULL, else -1
+*/
+protected_pmip_lma_proc(int lma_reg_no_new_tunnel(pmip_entry_t * bce);)
+/*! \fn int lma_dereg(pmip_entry_t * bce, msg_info_t * info, int propagate)
+* \brief  Deregister a binding cache entry
+* \param[in]  bce A binding cache entry
+* \param[in]  info Informations contained in the message received
+* \param[in]  propagate Deregistration to MAG
+* \return   the number of binding cache entries in the cache.
+*/
+protected_pmip_lma_proc(int lma_dereg(pmip_entry_t * bce, msg_info_t * info, int propagate);)
+/*! \fn int lma_update_binding_entry(pmip_entry_t * bce, msg_info_t * info)
+* \brief Update a binding cache entry with received message informations
+* \param[in]  bce A binding cache entry
+* \param[in]  info Informations contained in the message received
+* \return   1 if a new tunnel must br created, else 0, if error in parameters return -1.
+*/
+protected_pmip_lma_proc(int lma_update_binding_entry(pmip_entry_t * bce, msg_info_t * info);)
+#endif
+/** @}*/
+
diff -Nur umip/src/pmip/pmip_mag_proc.c umip-pmipv6/src/pmip/pmip_mag_proc.c
--- umip/src/pmip/pmip_mag_proc.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_mag_proc.c	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,495 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_mag_proc.c
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+#define PMIP
+#define PMIP_MAG_PROC_C
+#ifdef HAVE_CONFIG_H
+#	include <config.h>
+#endif
+#include <sys/sysctl.h>
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_mag_proc.h"
+#include "pmip_handler.h"
+#include "pmip_hnp_cache.h"
+#include "pmip_tunnel.h"
+//---------------------------------------------------------------------------------------------------------------------
+#include "rtnl.h"
+#include "tunnelctl.h"
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_timer_retrans_pbu_handler(struct tq_elem *tqe);
+//---------------------------------------------------------------------------------------------------------------------
+int mag_setup_route(struct in6_addr *pmip6_addr, int downlink)
+{
+    int res = 0;
+    dbg("Downlink(MAG local traffic also): Add new rule for dest=%x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(pmip6_addr));
+    res = rule_add(NULL, RT6_TABLE_MIP6, IP6_RULE_PRIO_PMIP6_FWD-1, RTN_UNICAST, &in6addr_any, 0, pmip6_addr, 128, 0);
+    if (res < 0) {
+        dbg("ERROR Add new rule for downlink, MAG local traffic also");
+    }
+    if (conf.TunnelingEnabled) {
+        //add a rule for MN for uplink traffic from MN must query the TABLE for PMIP --> tunneled
+        dbg("Uplink: Add new rule for tunneling src=%x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(pmip6_addr));
+        res = rule_add(NULL, RT6_TABLE_PMIP, IP6_RULE_PRIO_PMIP6_FWD, RTN_UNICAST, pmip6_addr, 128, &in6addr_any, 0, 0);
+        if (res < 0) {
+            dbg("ERROR Add new rule for tunneling");
+        }
+    } else {
+        dbg("WARNING CANNOT ADD new rule for tunneling src=%x:%x:%x:%x:%x:%x:%x:%x SINCE TUNNELING DISABLED IN CONFIG\n", NIP6ADDR(pmip6_addr));
+    }
+    //add a route for downlink traffic through LMA (any src) ==> MN
+    dbg("Downlink: Add new route for %x:%x:%x:%x:%x:%x:%x:%x in table %d\n", NIP6ADDR(pmip6_addr), RT6_TABLE_MIP6);
+    res |= route_add(downlink, RT6_TABLE_MIP6, RTPROT_MIP, 0, IP6_RT_PRIO_MIP6_FWD, &in6addr_any, 0, pmip6_addr, 128, NULL);
+    if (res < 0) {
+        dbg("ERROR Add new rule for tunneling");
+    }
+    return res;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_remove_route(struct in6_addr *pmip6_addr, int downlink)
+{
+    int res = 0;
+    //Delete existing rule for the deleted MN
+    dbg("Downlink(MAG local traffic also): Delete new rule for dest=%x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(pmip6_addr));
+    res = rule_del(NULL, RT6_TABLE_MIP6, IP6_RULE_PRIO_PMIP6_FWD-1, RTN_UNICAST, &in6addr_any, 0, pmip6_addr, 128, 0);
+    if (res < 0) {
+        dbg("ERROR Del old rule for downlink, MAG local traffic also");
+    }
+    if (conf.TunnelingEnabled) {
+        dbg("Uplink: Delete old rule for tunneling src=%x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(pmip6_addr));
+        res = rule_del(NULL, RT6_TABLE_PMIP, IP6_RULE_PRIO_PMIP6_FWD, RTN_UNICAST, pmip6_addr, 128, &in6addr_any, 0, 0);
+        if (res < 0) {
+            dbg("ERROR Del old rule for tunneling ");
+        }
+    } else {
+        dbg("WARNING CANNOT DELETE old rule for tunneling src=%x:%x:%x:%x:%x:%x:%x:%x SINCE TUNNELING DISABLED IN CONFIG\n", NIP6ADDR(pmip6_addr));
+    }
+    //Delete existing route for the deleted MN
+    dbg("Downlink: Delete old routes for: %x:%x:%x:%x:%x:%x:%x:%x from table %d\n", NIP6ADDR(pmip6_addr), RT6_TABLE_MIP6);
+    res |= route_del(downlink, RT6_TABLE_MIP6, IP6_RT_PRIO_MIP6_FWD, &in6addr_any, 0, pmip6_addr, 128, NULL);
+    if (res < 0) {
+        dbg("ERROR Del old rule for tunneling ");
+    }
+    return res;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_dereg(pmip_entry_t * bce, int propagate)
+{
+    //Delete existing route & rule for the deleted MN
+    int res = 0;
+    bce->type = BCE_NO_ENTRY;
+    res = mag_remove_route(get_mn_addr(bce), bce->link);
+    int usercount = tunnel_getusers(bce->tunnel);
+    dbg("# of binding entries %d \n", usercount);
+    if (usercount == 1) {
+        route_del(bce->tunnel, RT6_TABLE_PMIP, IP6_RT_PRIO_MIP6_FWD, &in6addr_any, 0, &in6addr_any, 0, NULL);
+    }
+    //decrement users of old tunnel.
+    pmip_tunnel_del(bce->tunnel);
+    if (propagate) {
+        dbg("Propagate the deregistration... \n");
+        struct in6_addr_bundle addrs;
+        addrs.src = &conf.OurAddress;
+        addrs.dst = &conf.LmaAddress;
+        struct timespec Lifetime = { 0, 0 };
+        dbg("Create PBU for LMA for deregistration....\n");
+        mh_send_pbu(&addrs, bce, &Lifetime, 0);
+    }
+    //Delete PBU cache entry
+    dbg("Delete PBU entry....\n");
+    return res;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_start_registration(pmip_entry_t * bce)
+{
+    //Create PBU and send to the LMA
+    struct in6_addr_bundle addrs;
+    addrs.src = &conf.MagAddressEgress[0];
+    addrs.dst = &conf.LmaAddress;
+
+    // min 4 seconds, because lifetime is sent over the network in PBU divided by 4
+    struct timespec lifetime = { 10, 0 };
+    mh_send_pbu(&addrs, bce, &lifetime, 0);
+    //mh_send_pbu(&addrs, bce, &conf.PBULifeTime, 0);
+    //add a new task for PBU retransmission.
+    struct timespec expires;
+    clock_gettime(CLOCK_REALTIME, &bce->add_time);
+    tsadd(bce->add_time, conf.RetransmissionTimeOut, expires);
+    add_task_abs(&expires, &bce->tqe, pmip_timer_retrans_pbu_handler);
+    dbg("PBU Retransmissions Timer is registered....\n");
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_end_registration(pmip_entry_t * bce, int iif)
+{
+    //Change the BCE type.
+    bce->type = BCE_PMIP;
+    dbg("New PMIP cache entry type: %d\n", bce->type);
+    //Reset the Retransmissions counter.
+    bce->n_rets_counter = conf.MaxMessageRetransmissions;
+    //Add task for entry expiry.
+    dbg("Timer for Expiry is initialized: %d(s)!\n", bce->lifetime.tv_sec);
+    pmip_cache_start(bce);
+    //create a tunnel between MAG and LMA.
+    bce->tunnel = pmip_tunnel_add(&conf.OurAddress, &conf.LmaAddress, iif);
+    int usercount = tunnel_getusers(bce->tunnel);
+    dbg("# of binding entries %d\n", usercount);
+    if (usercount == 1) {
+        dbg("Add routing entry for uplink traffic\n");
+        route_add(bce->tunnel, RT6_TABLE_PMIP, RTPROT_MIP, 0, IP6_RT_PRIO_MIP6_FWD, &in6addr_any, 0, &in6addr_any, 0, NULL);
+    }
+    mag_kickoff_ra(bce);
+    dbg("Adding route for : %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(get_mn_addr(bce)));
+    mag_setup_route(get_mn_addr(bce), bce->link);
+    dbg("Out of setup route\n");
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_end_registration_no_new_tunnel(pmip_entry_t * bce, __attribute__ ((unused)) int iif)
+{
+    //Force the BCE type.
+    bce->type = BCE_PMIP;
+    dbg("PMIP cache entry type: %d\n", bce->type);
+    //Reset the Retransmissions counter.
+    bce->n_rets_counter = conf.MaxMessageRetransmissions;
+    //Add task for entry expiry.
+    dbg("Timer for Expiry is initialized: %d(s)!\n", bce->lifetime.tv_sec);
+    pmip_cache_start(bce);
+    mag_kickoff_ra(bce);
+    //dbg("Adding route for : %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(get_mn_addr(bce)));
+    //mag_setup_route(get_mn_addr(bce), bce->link);
+    //dbg("Out of setup route\n");
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_force_update_registration(pmip_entry_t * bce, __attribute__ ((unused)) int iif)
+{
+    //int mutex_return_code;
+
+    // first delete current task
+    /*mutex_return_code = pthread_rwlock_wrlock(&bce->lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_wrlock(&bce->lock) %s\n", strerror(mutex_return_code));
+    }*/
+    if (bce->tqe.task != NULL) {
+        dbg("Deleting current BCE task\n");
+        del_task(&bce->tqe);
+    }
+    /*mutex_return_code = pthread_rwlock_unlock(&bce->lock);
+    if (mutex_return_code != 0) {
+        dbg("pthread_rwlock_unlock(&bce->lock) %s\n", strerror(mutex_return_code));
+    }*/
+
+    //Create PBU and send to the LMA
+    struct in6_addr_bundle addrs;
+    addrs.src = &conf.MagAddressEgress[0];
+    addrs.dst = &conf.LmaAddress;
+
+    //struct timespec lifetime = { 3, 0 };
+    mh_send_pbu(&addrs, bce, &conf.PBULifeTime, 0);
+    //add a new task for PBU retransmission.
+    struct timespec expires;
+    clock_gettime(CLOCK_REALTIME, &bce->add_time);
+    tsadd(bce->add_time, conf.RetransmissionTimeOut, expires);
+    add_task_abs(&expires, &bce->tqe, pmip_timer_retrans_pbu_handler);
+    dbg("PBU Retransmissions Timer is registered....\n");
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_kickoff_ra(pmip_entry_t * bce)
+{
+    struct in6_addr *src;
+    src = malloc(sizeof(struct in6_addr));
+    memset(src, 0, sizeof(struct in6_addr));
+    struct iovec iov;
+    struct nd_router_advert *radvert;
+    adv_prefix_t prefix;
+    unsigned char buff[MSG_SIZE];
+    size_t len = 0;
+    memset(&buff, 0, sizeof(buff));
+    radvert = (struct nd_router_advert *) buff;
+    radvert->nd_ra_type = ND_ROUTER_ADVERT;
+    radvert->nd_ra_code = 0;
+    radvert->nd_ra_cksum = 0;
+    radvert->nd_ra_curhoplimit = router_ad_iface.AdvCurHopLimit;
+    radvert->nd_ra_flags_reserved = (router_ad_iface.AdvManagedFlag) ? ND_RA_FLAG_MANAGED : 0;
+    radvert->nd_ra_flags_reserved |= (router_ad_iface.AdvOtherConfigFlag) ? ND_RA_FLAG_OTHER : 0;
+    /* Mobile IPv6 ext */
+    radvert->nd_ra_flags_reserved |= (router_ad_iface.AdvHomeAgentFlag) ? ND_RA_FLAG_HOME_AGENT : 0;
+    /* if forwarding is disabled, send zero router lifetime */
+    radvert->nd_ra_router_lifetime = !check_ip6_forwarding()? htons(router_ad_iface.AdvDefaultLifetime) : 0;
+    radvert->nd_ra_reachable = htonl(router_ad_iface.AdvReachableTime); //ask giuliana
+    radvert->nd_ra_retransmit = htonl(router_ad_iface.AdvRetransTimer); // ask giuliana
+    len = sizeof(struct nd_router_advert);
+    prefix = router_ad_iface.Adv_Prefix;
+    /*
+     *  add prefix options
+    */
+    struct nd_opt_prefix_info *pinfo;
+    pinfo = (struct nd_opt_prefix_info *) (buff + len);
+    pinfo->nd_opt_pi_type = ND_OPT_PREFIX_INFORMATION;
+    pinfo->nd_opt_pi_len = 4;
+    pinfo->nd_opt_pi_prefix_len = prefix.PrefixLen;
+    pinfo->nd_opt_pi_flags_reserved = (prefix.AdvOnLinkFlag) ? ND_OPT_PI_FLAG_ONLINK : 0;
+    pinfo->nd_opt_pi_flags_reserved |= (prefix.AdvAutonomousFlag) ? ND_OPT_PI_FLAG_AUTO : 0;
+    /* Mobile IPv6 ext */
+    pinfo->nd_opt_pi_flags_reserved |= (prefix.AdvRouterAddr) ? ND_OPT_PI_FLAG_RADDR : 0;
+    pinfo->nd_opt_pi_valid_time = htonl(prefix.AdvValidLifetime);
+    pinfo->nd_opt_pi_preferred_time = htonl(prefix.AdvPreferredLifetime);
+    pinfo->nd_opt_pi_reserved2 = 0;
+    memcpy(&pinfo->nd_opt_pi_prefix, &bce->mn_prefix, sizeof(struct in6_addr));
+    len += sizeof(*pinfo);
+    //mobile ip extension
+    if (router_ad_iface.AdvHomeAgentInfo
+    && (router_ad_iface.AdvMobRtrSupportFlag || router_ad_iface.HomeAgentPreference != 0 || router_ad_iface.HomeAgentLifetime != router_ad_iface.AdvDefaultLifetime)) {
+    home_agent_info_t ha_info;
+    ha_info.type = ND_OPT_HOME_AGENT_INFO;
+    ha_info.length = 1;
+    ha_info.flags_reserved = (router_ad_iface.AdvMobRtrSupportFlag) ? ND_OPT_HAI_FLAG_SUPPORT_MR : 0;
+    ha_info.preference = htons(router_ad_iface.HomeAgentPreference);
+    ha_info.lifetime = htons(router_ad_iface.HomeAgentLifetime);
+    memcpy(buff + len, &ha_info, sizeof(ha_info));
+    len += sizeof(ha_info);
+    }
+    iov.iov_len = len;
+    iov.iov_base = (caddr_t) buff;
+    int err;
+    err = icmp6_send(bce->link, 255, src, &bce->mn_link_local_addr, &iov, 1);
+    if (err < 0) {
+        dbg("Error: couldn't send a RA message ...\n");
+    } else {
+        dbg("RA LL ADDRESS sent on bce link %d\n", bce->link);
+    }
+    return err;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int check_ip6_forwarding(void)
+{
+    int forw_sysctl[] = { SYSCTL_IP6_FORWARDING };
+    int value;
+    int rc;
+    size_t size = sizeof(value);
+    FILE *fp = NULL;
+#ifdef __linux__
+    fp = fopen(PROC_SYS_IP6_FORWARDING, "r");
+    if (fp) {
+        rc = fscanf(fp, "%d", &value);
+        fclose(fp);
+        if (rc <= 0) {
+             dbg("ERROR reading %s" ,PROC_SYS_IP6_FORWARDING);
+        }
+    } else
+        dbg("Correct IPv6 forwarding procfs entry not found, " "perhaps the procfs is disabled, " "or the kernel interface has changed?");
+#endif              /* __linux__ */
+    if (!fp && sysctl(forw_sysctl, sizeof(forw_sysctl) / sizeof(forw_sysctl[0]), &value, &size, NULL, 0) < 0) {
+        dbg("Correct IPv6 forwarding sysctl branch not found, " "perhaps the kernel interface has changed?");
+        return (0);     /* this is of advisory value only */
+    }
+    if (value != 1) {
+        dbg("IPv6 forwarding setting is: %u, should be 1", value);
+        return (-1);
+    }
+    return (0);
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_get_ingress_info(int *if_index, char *dev_name_mn_link)
+{
+    FILE *fp;
+    char str_addr[INET6_ADDRSTRLEN];
+    unsigned int plen, scope, dad_status, if_idx;
+    struct in6_addr addr;
+    unsigned int ap;
+    int i;
+
+    char devname[32];
+    if ((fp = fopen("/proc/net/if_inet6", "r")) == NULL) {
+        dbg("you don't have root previleges, please logon as root, can't open %s:", "/proc/net/if_inet6");
+        return -1;
+    }
+    // first find the device name
+    while (fscanf(fp, "%32s %x %02x %02x %02x %15s\n", str_addr, &if_idx, &plen, &scope, &dad_status, devname) != EOF) {
+        for (i = 0; i < 16; i++) {
+            sscanf(str_addr + i * 2, "%02x", &ap);
+            addr.s6_addr[i] = (unsigned char) ap;
+        }
+        if (memcmp(&conf.MagAddressIngress[0], &addr, sizeof(struct in6_addr)) == 0) {
+            if (dev_name_mn_link != NULL) {
+                strncpy(dev_name_mn_link, devname, 32);
+                dbg("The interface name of the device that is used for communicate with MNs is %s\n", dev_name_mn_link);
+            }
+            if ( if_index != NULL) {
+                *if_index = if_idx;
+                dbg("The interface index of the device that is used for communicate with MNs is %d\n", *if_index);
+            }
+            fclose(fp);
+            return 1;
+        }
+    }
+    fclose(fp);
+    dbg("No interface name of the device that is used for communicate with MNs found");
+    return -1;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_get_egress_info(int *if_index, char *dev_name_mn_link)
+{
+    FILE *fp;
+    char str_addr[INET6_ADDRSTRLEN];
+    unsigned int plen, scope, dad_status, if_idx;
+    struct in6_addr addr;
+    unsigned int ap;
+    int i;
+
+    char devname[32];
+    if ((fp = fopen("/proc/net/if_inet6", "r")) == NULL) {
+        dbg("you don't have root previleges, please logon as root, can't open %s:", "/proc/net/if_inet6");
+        return -1;
+    }
+    // first find the device name
+    while (fscanf(fp, "%32s %x %02x %02x %02x %15s\n", str_addr, &if_idx, &plen, &scope, &dad_status, devname) != EOF) {
+        for (i = 0; i < 16; i++) {
+            sscanf(str_addr + i * 2, "%02x", &ap);
+            addr.s6_addr[i] = (unsigned char) ap;
+        }
+        if (memcmp(&conf.MagAddressEgress[0], &addr, sizeof(struct in6_addr)) == 0) {
+            if (dev_name_mn_link != NULL) {
+                strncpy(dev_name_mn_link, devname, 32);
+                dbg("The interface name of the device that is used for communicate with LMA is %s\n", dev_name_mn_link);
+            }
+            if ( if_index != NULL) {
+                *if_index = if_idx;
+                dbg("The interface index of the device that is used for communicate with LMA is %d\n", *if_index);
+            }
+            fclose(fp);
+            return 1;
+        }
+    }
+    fclose(fp);
+    dbg("No interface name of the device that is used for communicate with LMA found");
+    return -1;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int setup_linklocal_addr(struct in6_addr *src)
+{
+    FILE *fp;
+    char str_addr[INET6_ADDRSTRLEN];
+    unsigned int plen, scope, dad_status, if_idx;
+    struct in6_addr addr;
+    unsigned int ap;
+    int i;
+    int flagy = 0;
+    char devname[32];
+    char dev_name_mn_link[32];
+    if ((fp = fopen("/proc/net/if_inet6", "r")) == NULL) {
+        dbg("you don't have root previleges, please logon as root, can't open %s:", "/proc/net/if_inet6");
+        return -1;
+    }
+    // first find the device name
+    while (fscanf(fp, "%32s %x %02x %02x %02x %15s\n", str_addr, &if_idx, &plen, &scope, &dad_status, devname) != EOF) {
+        for (i = 0; i < 16; i++) {
+            sscanf(str_addr + i * 2, "%02x", &ap);
+            addr.s6_addr[i] = (unsigned char) ap;
+        }
+        if (memcmp(&conf.MagAddressIngress[0], &addr, sizeof(struct in6_addr)) == 0) {
+            strncpy(dev_name_mn_link, devname, 32);
+            flagy = 1;
+            dbg("The interface name of the device that is used for communicate with MNs is %s\n", dev_name_mn_link);
+            break;
+        }
+    }
+    fclose(fp);
+    if ((fp = fopen("/proc/net/if_inet6", "r")) == NULL) {
+        dbg("can't open %s:", "/proc/net/if_inet6");
+        return -1;
+    }
+    while (fscanf(fp, "%32s %x %02x %02x %02x %15s\n", str_addr, &if_idx, &plen, &scope, &dad_status, devname) != EOF) {
+    if (scope == IPV6_ADDR_LINKLOCAL && strcmp(devname, dev_name_mn_link) == 0) //we have to store the interface name from which we get the router solicitation
+    {
+        dbg("entered the if to get %s iface ll address ", dev_name_mn_link);
+        flagy = 1;
+        for (i = 0; i < 16; i++) {
+        sscanf(str_addr + i * 2, "%02x", &ap);
+        addr.s6_addr[i] = (unsigned char) ap;
+        }
+        dbg("PMIP cache entry is found for: %x:%x:%x:%x:%x:%x:%x:%x \n", NIP6ADDR(&addr));
+        *src = addr;
+    }
+    }
+    if (flagy == 0) {
+        dbg("no link local address configured ");
+        fclose(fp);
+        return -1;
+    } else {
+        fclose(fp);
+        return 1;
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_update_binding_entry(pmip_entry_t * bce, msg_info_t * info)
+{
+    dbg("Update binding entry\n");
+    bce->our_addr           = conf.OurAddress;
+    bce->mn_suffix          = info->mn_iid;
+    bce->mn_hw_address      = EUI64_to_EUI48(info->mn_iid);
+    bce->mn_prefix          = info->mn_prefix;
+    bce->mn_addr            = info->mn_addr;
+    bce->mn_link_local_addr = info->mn_link_local_addr;
+    bce->mn_serv_mag_addr   = info->src;
+    bce->lifetime           = info->lifetime;
+    bce->n_rets_counter     = conf.MaxMessageRetransmissions;
+    bce->seqno_in           = info->seqno;
+    bce->link               = info->iif;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mag_pmip_md(msg_info_t * info, pmip_entry_t * bce)
+{
+    if (bce != NULL) {
+        bce->our_addr           = conf.OurAddress;
+        bce->mn_suffix          = info->mn_iid;
+        bce->mn_prefix          = info->mn_prefix;
+        bce->mn_serv_mag_addr   = conf.OurAddress;
+        bce->mn_serv_lma_addr   = conf.LmaAddress;
+        bce->seqno_out          = 0;
+        bce->PBU_flags          = IP6_MH_BU_ACK | IP6_MH_BU_PR;
+        bce->link               = info->iif;
+        struct in6_addr *link_local = link_local_addr(&bce->mn_suffix);
+        bce->mn_link_local_addr = *link_local;  // link local address of MN
+        bce->type               = BCE_TEMP;
+        dbg("Making BCE entry in MAG with HN prefix        %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->mn_prefix));
+        dbg("                             Suffix           %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->mn_suffix));
+        dbg("                             Link local addr  %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->mn_link_local_addr));
+        dbg("                             Serv mag addr    %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->mn_serv_mag_addr));
+        dbg("                             Serv lma addr    %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->mn_serv_lma_addr));
+        dbg("New attachment detected! Start Location Registration procedure...\n");
+        mag_start_registration(bce);
+    }
+    return 0;
+}
diff -Nur umip/src/pmip/pmip_mag_proc.h umip-pmipv6/src/pmip/pmip_mag_proc.h
--- umip/src/pmip/pmip_mag_proc.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_mag_proc.h	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,179 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_mag_proc.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup MAG_Processing MAG_Processing
+ * \ingroup PMIP6D
+ *  PMIP PROCessing for MAG
+ *  @{
+ */
+
+#ifndef __PMIP_MAG_PROC_H__
+#    define __PMIP_MAG_PROC_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_MAG_PROC_C
+#        define private_pmip_mag_proc(x) x
+#        define protected_pmip_mag_proc(x) x
+#        define public_pmip_mag_proc(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_mag_proc(x)
+#            define protected_pmip_mag_proc(x) extern x
+#            define public_pmip_mag_proc(x) extern x
+#        else
+#            define private_pmip_mag_proc(x)
+#            define protected_pmip_mag_proc(x)
+#            define public_pmip_mag_proc(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+#    define SYSCTL_IP6_FORWARDING CTL_NET, NET_IPV6, NET_IPV6_CONF, NET_PROTO_CONF_ALL, NET_IPV6_FORWARDING
+#    define PROC_SYS_IP6_FORWARDING "/proc/sys/net/ipv6/conf/all/forwarding"
+#    define PROC_SYS_IP6_LINKMTU "/proc/sys/net/ipv6/conf/%s/mtu"
+#    define PROC_SYS_IP6_CURHLIM "/proc/sys/net/ipv6/conf/%s/hop_limit"
+#    define PROC_SYS_IP6_BASEREACHTIME_MS "/proc/sys/net/ipv6/neigh/%s/base_reachable_time_ms"
+#    define PROC_SYS_IP6_BASEREACHTIME "/proc/sys/net/ipv6/neigh/%s/base_reachable_time"
+#    define PROC_SYS_IP6_RETRANSTIMER_MS "/proc/sys/net/ipv6/neigh/%s/retrans_time_ms"
+#    define PROC_SYS_IP6_RETRANSTIMER "/proc/sys/net/ipv6/neigh/%s/retrans_time"
+
+#    ifndef IPV6_ADDR_LINKLOCAL
+#        define IPV6_ADDR_LINKLOCAL 0x0020U
+#    endif
+//-----------------------------------------------------------------------------
+#	include <netinet/ip6.h>
+#	include "pmip_cache.h"
+#	include "pmip_msgs.h"
+
+//-VARS----------------------------------------------------------------------------
+/*! \var int  g_ingress_iif
+\brief Ingress interface index that is delivered by kernel in /proc/net/if_inet6 .
+*/
+protected_pmip_mag_proc(int   g_ingress_iif;)
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn int mag_setup_route(struct in6_addr *pmip6_addr, int downlink)
+* \brief	Set a route on a MAG for reaching a mobile node.
+* \param[in]  pmip6_addr Mobile node destination address
+* \param[in]  downlink Outgoing downlink interface id
+* \return   Returns zero on success, negative otherwise.
+*/
+private_pmip_mag_proc(int mag_setup_route(struct in6_addr *pmip6_addr, int downlink);)
+/*! \fn int mag_remove_route(struct in6_addr *, int )
+* \brief  Remove a route on a MAG
+* \param[in]  pmip6_addr Mobile node destination address
+* \param[in]  downlink Outgoing downlink interface id
+* \return   Returns zero on success, negative otherwise.
+*/
+protected_pmip_mag_proc(int mag_remove_route(struct in6_addr *pmip6_addr, int downlink);)
+/*! \fn int mag_dereg(pmip_entry_t * bce, int propagate)
+* \brief  Deregister a binding cache entry and its associated network configuration.
+* \param[in]  bce       A binding cache entry
+* \param[in]  propagate Propagate deregistration to LMA
+* \return   Returns zero on success, negative otherwise.
+*/
+protected_pmip_mag_proc(int mag_dereg(pmip_entry_t * bce, int propagate);)
+/*! \fn int mag_start_registration(pmip_entry_t *)
+* \brief  Start the Location Registration Procedure for a mobile node by sending a PBU to the LMA.
+* \param[in]  bce A binding cache entry
+* \return   Always Zero.
+*/
+protected_pmip_mag_proc(int mag_start_registration(pmip_entry_t * bce);)
+/*! \fn int mag_end_registration(pmip_entry_t * bce, int )
+* \brief   End the Location Registration Procedure
+* \param[in]  bce A binding cache entry
+* \param[in]  iif Interface id used to communicate with the LMA
+* \return   Always Zero.
+* \note     Creates a tunnel between MAG and LMA, set a route for uplink traffic towards LMA if the route does not exist, send a router advertisement to the mobile node, and finally set the route to reach the mobile node.
+*/
+protected_pmip_mag_proc(int mag_end_registration(pmip_entry_t * bce, int iif);)
+/*! \fn int mag_end_registration_no_new_tunnel(pmip_entry_t * bce, int )
+* \brief   End the Location Registration Procedure
+* \param[in]  bce A binding cache entry
+* \param[in]  iif Interface id used to communicate with the LMA
+* \return   Always Zero.
+* \note     Does not create a tunnel between MAG and LMA, does not set a route for uplink traffic towards LMA, send a router advertisement to the mobile node, and finally set the route to reach the mobile node.
+*/
+protected_pmip_mag_proc(int mag_end_registration_no_new_tunnel(pmip_entry_t * bce, __attribute__ ((unused)) int iif);)
+/*! \fn int mag_force_update_registration(pmip_entry_t * bce, int )
+* \brief   Start the Location Registration Procedure for a mobile node by sending a PBU to the LMA.
+* \param[in]  bce A binding cache entry
+* \param[in]  iif Interface id used to communicate with the LMA
+* \return   Always Zero.
+* \note     Sometimes appear the case where the access point did not detect the departure of the mobile node,
+*           so when the mobile come back again, we have to register again to the LMA, in order to let LMA build
+*           a tunnel between LMA and this MAG.
+*/
+protected_pmip_mag_proc(int mag_force_update_registration(pmip_entry_t * bce, __attribute__ ((unused)) int iif);)
+/*! \fn int mag_kickoff_ra(pmip_entry_t * bce)
+* \brief  Start sendind router advertisements to a mobile node.
+* \param[in]  bce A binding cache entry
+* \return   Returns zero on success, negative otherwise.
+*/
+protected_pmip_mag_proc(int mag_kickoff_ra(pmip_entry_t * bce);)
+/*! \fn int check_ip6_forwarding(void)
+* \brief  Check if IPv6 forwarding is set in the kernel
+* \return   Zero if forwarding is set, else -1.
+*/
+private_pmip_mag_proc(int check_ip6_forwarding(void);)
+/*! \fn int mag_get_ingress_info(int *, char *)
+* \brief Retrieve the link local address of the MAG interface accessible to mobile nodes.
+* \param[out]  if_index         The interface identifier
+* \param[out]  dev_name_mn_link The name of the interface
+* \return   1 if success, else -1.
+* \note The informations are retrieved by comparing /proc/net/if_inet6 with the configuration variable MagAddressIngress.
+*/
+protected_pmip_mag_proc(int mag_get_ingress_info(int *if_index, char *dev_name_mn_link);)
+/*! \fn int mag_get_egress_info(int *, char *)
+* \brief Retrieve the link local address of the MAG interface connected to LMA.
+* \param[out]  if_index         The interface identifier
+* \param[out]  dev_name_mn_link The name of the interface
+* \return   1 if success, else -1.
+* \note The informations are retrieved by comparing /proc/net/if_inet6 with the configuration variable MagAddressEgress.
+*/
+protected_pmip_mag_proc(int mag_get_egress_info(int *if_index, char *dev_name_mn_link);)
+/*! \fn int setup_linklocal_addr(struct in6_addr *)
+* \brief Retrieve the link local address of the MAG interface accessible to mobile nodes.
+* \param[out]  src The link local address.
+* \return    1 if success, else -1.
+*/
+protected_pmip_mag_proc(int setup_linklocal_addr(struct in6_addr *src);)
+/*! \fn int mag_update_binding_entry(pmip_entry_t * bce, msg_info_t * info)
+* \brief  Update a binding cache entry with received message informations.
+* \param[in]  bce A binding cache entry
+* \param[in]  info Informations contained in the message received
+* \return   Always Zero.
+*/
+private_pmip_mag_proc(int mag_update_binding_entry(pmip_entry_t * bce, msg_info_t * info);)
+/*! \fn int mag_pmip_md(msg_info_t * info, pmip_entry_t * bce)
+* \brief   Start movement detection for a mobile node.
+* \param[in]  info Informations contained in the message received
+* \param[in]  bce A binding cache entry
+* \return   Always Zero.
+* \note   Initiate registration (send PBU) to the LMA.
+*/
+protected_pmip_mag_proc(int mag_pmip_md(msg_info_t * info, pmip_entry_t * bce);)
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip_msgs.c umip-pmipv6/src/pmip/pmip_msgs.c
--- umip/src/pmip/pmip_msgs.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_msgs.c	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,1167 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_msgs.c
+ * \brief creates new options and sends and parses PBU/PBA
+ * \author OpenAir3 Group
+ * \date 12th of October 2010
+ * \version 1.0
+ * \company Eurecom
+ * \project OpenAirInterface
+ * \email: openair_tech@eurecom.fr
+ */
+#define PMIP
+#define PMIP_MSGS_C
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <time.h>
+#include <sys/time.h>
+#include <errno.h>
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_msgs.h"
+//---------------------------------------------------------------------------------------------------------------------
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//---------------------------------------------------------------------------------------------------------------------
+/*! \var struct sock mh_sock
+\brief Global var declared in mipl component
+ */
+extern struct sock mh_sock;
+/* We can use these safely, since they are only read and never change */
+static const uint8_t _pad1[1] = { 0x00 };
+static const uint8_t _pad2[2] = { 0x01, 0x00 };
+static const uint8_t _pad3[3] = { 0x01, 0x01, 0x00 };
+static const uint8_t _pad4[4] = { 0x01, 0x02, 0x00, 0x00 };
+static const uint8_t _pad5[5] = { 0x01, 0x03, 0x00, 0x00, 0x00 };
+static const uint8_t _pad6[6] = { 0x01, 0x04, 0x00, 0x00, 0x00, 0x00 };
+static const uint8_t _pad7[7] = { 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00 };
+//---------------------------------------------------------------------------------------------------------------------
+static int create_opt_pad(struct iovec *iov, int pad)
+{
+    if (pad == 2) {
+        //iov->iov_base = (void *) _pad2;
+        iov->iov_base = malloc(sizeof(_pad2));
+        memcpy(iov->iov_base, _pad2, sizeof(_pad2));
+    }
+    else if (pad == 4) {
+        //iov->iov_base = (void *) _pad4;
+        iov->iov_base = malloc(sizeof(_pad4));
+        memcpy(iov->iov_base, _pad4, sizeof(_pad4));
+    }
+    else if (pad == 6) {
+        //iov->iov_base = (void *) _pad6;
+        iov->iov_base = malloc(sizeof(_pad6));
+        memcpy(iov->iov_base, _pad6, sizeof(_pad6));
+    }
+    /* Odd pads do not occur with current spec, so test them last */
+    else if (pad == 1) {
+        iov->iov_base = (void *) _pad1;
+        iov->iov_base = malloc(sizeof(_pad1));
+        memcpy(iov->iov_base, _pad1, sizeof(_pad1));
+    }
+    else if (pad == 3) {
+        //iov->iov_base = (void *) _pad3;
+        iov->iov_base = malloc(sizeof(_pad3));
+        memcpy(iov->iov_base, _pad3, sizeof(_pad3));
+    }
+    else if (pad == 5) {
+        //iov->iov_base = (void *) _pad5;
+        iov->iov_base = malloc(sizeof(_pad5));
+        memcpy(iov->iov_base, _pad5, sizeof(_pad5));
+    }
+    else if (pad == 7) {
+        //iov->iov_base = (void *) _pad7;
+        iov->iov_base = malloc(sizeof(_pad7));
+        memcpy(iov->iov_base, _pad7, sizeof(_pad7));
+    }
+    iov->iov_len = pad;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+static inline int optpad(int xn, int y, int offset)
+{
+    return ((y - offset) & (xn - 1));
+}
+//---------------------------------------------------------------------------------------------------------------------
+static int mh_try_pad(const struct iovec *in, struct iovec *out, int count)
+{
+    size_t len = 0;
+    int m, n = 1, pad = 0;
+    struct ip6_mh_opt *opt;
+    out[0].iov_len = in[0].iov_len;
+    out[0].iov_base = in[0].iov_base;
+    len += in[0].iov_len;
+    for (m = 1; m < count; m++) {
+        opt = (struct ip6_mh_opt *) in[m].iov_base;
+        switch (opt->ip6mhopt_type) {
+        case IP6_MHOPT_BREFRESH:
+            pad = optpad(2, 0, len);    /* 2n */
+            break;
+        case IP6_MHOPT_ALTCOA:
+            pad = optpad(8, 6, len);    /* 8n+6 */
+            break;
+        case IP6_MHOPT_NONCEID:
+            pad = optpad(2, 0, len);    /* 2n */
+            break;
+        case IP6_MHOPT_BAUTH:
+            pad = optpad(8, 2, len);    /* 8n+2 */
+            break;
+        case IP6_MHOPT_MOBILE_NODE_IDENTIFIER:
+            pad = 0;    /* This option does not have any alignment requirements. */
+            break;
+        case IP6_MHOPT_HOME_NETWORK_PREFIX:
+            pad = optpad(8, 4, len);    /* 8n+4 */
+            break;
+        case IP6_MHOPT_HANDOFF_INDICATOR:
+            pad = 0;    /* The Handoff Indicator option has no alignment requirement. */
+            break;
+        case IP6_MHOPT_ACCESS_TECHNOLOGY_TYPE:
+            pad = 0;    /* The Access Technology Type Option has no alignment requirement. */
+            break;
+        case IP6_MHOPT_MOBILE_NODE_LINK_LAYER_IDENTIFIER:
+            pad = optpad(8, 0, len);    /* 8n */
+            break;
+        case IP6_MHOPT_LINK_LOCAL_ADDRESS:
+            pad = optpad(8, 6, len);    /* 8n+6 */
+            break;
+        case IP6_MHOPT_TIME_STAMP:
+            pad = optpad(8, 2, len);    /* 8n+2 */
+            break;
+
+
+        }
+        if (pad > 0) {
+            create_opt_pad(&out[n++], pad);
+            len += pad;
+        }
+        len += in[m].iov_len;
+        out[n].iov_len = in[m].iov_len;
+        out[n].iov_base = in[m].iov_base;
+        n++;
+    }
+    if (count == 1) {
+        pad = optpad(8, 0, len);
+        create_opt_pad(&out[n++], pad);
+    }
+    return n;
+}
+//---------------------------------------------------------------------------------------------------------------------
+static size_t mh_length(struct iovec *vec, int count)
+{
+    size_t len = 0;
+    int i;
+    for (i = 0; i < count; i++) {
+        len += vec[i].iov_len;
+    }
+    return len;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void init_pbu_sequence_number(void) {
+    g_mag_sequence_number = 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int get_new_pbu_sequence_number(void)
+{
+    // TO DO: should be thread protected
+    int seq = g_mag_sequence_number;
+    g_mag_sequence_number = g_mag_sequence_number + 1;
+    return seq;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int is_pba_is_response_to_last_pbu_sent(msg_info_t * pba_info, pmip_entry_t *bce)
+{
+    if ( pba_info->seqno == bce->seqno_out) {
+        if ((pba_info->timestamp.first == bce->timestamp.first) && (pba_info->timestamp.second == bce->timestamp.second)) {
+            if (IN6_ARE_ADDR_EQUAL(&pba_info->mn_prefix, &bce->mn_prefix)) {
+                if (IN6_ARE_ADDR_EQUAL(&pba_info->mn_iid, &bce->mn_suffix)) {
+                    return 1;
+                } else {
+                    dbg("Not identical Mobile Node Link-layer Identifier Option: PBU:%x:%x:%x:%x:%x:%x:%x:%x  PBA:%x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->mn_suffix), NIP6ADDR(&pba_info->mn_iid));
+                }
+            } else {
+                dbg("Not identical Home Network Prefix option: PBU:%x:%x:%x:%x:%x:%x:%x:%x  PBA:%x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&bce->mn_prefix), NIP6ADDR(&pba_info->mn_prefix));
+            }
+        } else {
+            dbg("Not identical Timestamp option: PBU:%08X%08X  PBA:%08X%08X\n", bce->timestamp.first, bce->timestamp.second, pba_info->timestamp.first, pba_info->timestamp.second);
+        }
+    } else {
+        dbg("Not identical Sequence Number: PBU:%d  PBA:%d\n", bce->seqno_out, pba_info->seqno);
+    }
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+struct in6_addr get_node_id(struct in6_addr *mn_addr)
+{
+    struct in6_addr result;
+    result = in6addr_any;
+    memcpy(&result.s6_addr32[2], &mn_addr->s6_addr32[2], sizeof(ip6mnid_t));
+    return result;
+}
+//---------------------------------------------------------------------------------------------------------------------
+struct in6_addr get_node_prefix(struct in6_addr *mn_addr)
+{
+    struct in6_addr result;
+    result = in6addr_any;
+    memcpy(&result.s6_addr32[0], &mn_addr->s6_addr32[0], PREFIX_LENGTH / 8);
+    return result;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_home_net_prefix(struct iovec *iov, struct in6_addr *Home_Network_Prefix)
+{
+    /* From RFC 5213
+     * 8.3. Home Network Prefix Option
+
+
+        A new option, Home Network Prefix option is defined for use with the
+        Proxy Binding Update and Proxy Binding Acknowledgement messages
+        exchanged between a local mobility anchor and a mobile access
+        gateway.  This option is used for exchanging the mobile node's home
+        network prefix information.  There can be multiple Home Network
+        Prefix options present in the message.
+
+        The Home Network Prefix Option has an alignment requirement of 8n+4.
+        Its format is as follows:
+
+       0                   1                   2                   3
+       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      |      Type     |   Length      |   Reserved    | Prefix Length |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      |                                                               |
+      +                                                               +
+      |                                                               |
+      +                    Home Network Prefix                        +
+      |                                                               |
+      +                                                               +
+      |                                                               |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+       Type
+           22
+
+       Length
+
+           8-bit unsigned integer indicating the length of the option
+           in octets, excluding the type and length fields.  This field
+           MUST be set to 18.
+
+       Reserved (R)
+
+           This 8-bit field is unused for now.  The value MUST be
+           initialized to 0 by the sender and MUST be ignored by the
+           receiver.
+
+       Prefix Length
+
+           8-bit unsigned integer indicating the prefix length of the
+           IPv6 prefix contained in the option.
+
+       Home Network Prefix
+
+           A sixteen-byte field containing the mobile node's IPv6 Home
+           Network Prefix.
+     */
+    ip6_mh_opt_home_net_prefix_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_home_net_prefix_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_home_net_prefix_t *) iov->iov_base;
+    opt->ip6hnp_type       = IP6_MHOPT_HOME_NETWORK_PREFIX;
+    opt->ip6hnp_len        = 18;
+    opt->ip6hnp_reserved   = 0;
+    opt->ip6hnp_prefix_len = 128;   //128 bits
+    opt->ip6hnp_prefix     = *Home_Network_Prefix;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_handoff_indicator(struct iovec *iov, int handoff_indicator)
+{
+    /* From RFC 5213
+8.4. Handoff Indicator Option
+
+
+   A new option, Handoff Indicator option is defined for use with the
+   Proxy Binding Update and Proxy Binding Acknowledgement messages
+   exchanged between a local mobility anchor and a mobile access
+   gateway.  This option is used for exchanging the mobile node's
+   handoff-related hints.
+
+   The Handoff Indicator option has no alignment requirement.  Its
+   format is as follows:
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |      Type     |   Length      |  Reserved (R) |       HI      |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+    Type
+        23
+
+    Length
+
+        8-bit unsigned integer indicating the length of the option
+        in octets, excluding the type and length fields.  This field
+        MUST be set to 2.
+
+    Reserved (R)
+
+        This 8-bit field is unused for now.  The value MUST be
+        initialized to 0 by the sender and MUST be ignored by the
+        receiver.
+
+    Handoff Indicator (HI)
+
+        An 8-bit field that specifies the type of handoff.  The values
+        (0 - 255) will be allocated and managed by IANA.  The following
+        values are currently defined.
+
+        0: Reserved
+        1: Attachment over a new interface
+        2: Handoff between two different interfaces of the mobile node
+        3: Handoff between mobile access gateways for the same interface
+        4: Handoff state unknown
+        5: Handoff state not changed (Re-registration)
+
+     */
+    ip6_mh_opt_handoff_indicator_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_handoff_indicator_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_handoff_indicator_t *) iov->iov_base;
+    opt->ip6hi_type     = IP6_MHOPT_HANDOFF_INDICATOR;
+    opt->ip6hi_len      = 2;  //set to 2 bytes
+    opt->ip6hi_reserved = 0;
+    opt->ip6hi_hi       = (__u8)handoff_indicator;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_access_technology_type(struct iovec *iov, int att)
+{
+    /* From RFC 5213
+8.5. Access Technology Type Option
+
+
+   A new option, Access Technology Type option is defined for use with
+   the Proxy Binding Update and Proxy Binding Acknowledgement messages
+   exchanged between a local mobility anchor and a mobile access
+   gateway.  This option is used for exchanging the type of the access
+   technology by which the mobile node is currently attached to the
+   mobile access gateway.
+
+
+   The Access Technology Type Option has no alignment requirement.  Its
+   format is as follows:
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |      Type     |   Length      |  Reserved (R) |      ATT      |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+    Type
+        24
+
+    Length
+
+        8-bit unsigned integer indicating the length of the option
+        in octets, excluding the type and length fields.  This field
+        MUST be set to 2.
+
+    Reserved (R)
+
+        This 8-bit field is unused for now.  The value MUST be
+        initialized to 0 by the sender and MUST be ignored by the
+        receiver.
+
+    Access Technology Type (ATT)
+
+        An 8-bit field that specifies the access technology through
+        which the mobile node is connected to the access link on the
+        mobile access gateway.
+
+        The values (0 - 255) will be allocated and managed by IANA.  The
+        following values are currently reserved for the below specified
+        access technology types.
+
+        0: Reserved         ("Reserved")
+        1: Virtual          ("Logical Network Interface")
+        2: PPP              ("Point-to-Point Protocol")
+        3: IEEE 802.3       ("Ethernet")
+        4: IEEE 802.11a/b/g ("Wireless LAN")
+        5: IEEE 802.16e     ("WIMAX")
+*/
+    ip6_mh_opt_access_technology_type_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_access_technology_type_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_access_technology_type_t *) iov->iov_base;
+    opt->ip6att_type     = IP6_MHOPT_ACCESS_TECHNOLOGY_TYPE;
+    opt->ip6att_len      = 2;  //set to 2 bytes
+    opt->ip6att_reserved = 0;
+    opt->ip6att_att      = (__u8)att;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_mobile_node_identifier(struct iovec *iov, int subtype, ip6mnid_t * MN_ID)
+{
+    /* From RFC 4283
+    3. Mobile Node Identifier Option
+
+
+       The Mobile Node Identifier option is a new optional data field that
+       is carried in the Mobile IPv6-defined messages that includes the
+       Mobility header.  Various forms of identifiers can be used to
+       identify a Mobile Node (MN).  Two examples are a Network Access
+       Identifier (NAI) [RFC4282] and an opaque identifier applicable to a
+       particular application.  The Subtype field in the option defines the
+       specific type of identifier.
+
+       This option can be used in mobility messages containing a mobility
+       header.  The subtype field in the option is used to interpret the
+       specific type of identifier.
+
+           0                   1                   2                   3
+           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+                                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                           |  Option Type  | Option Length |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+           |  Subtype      |          Identifier ...
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+          Option Type:
+             MN-ID-OPTION-TYPE has been assigned value 8 by the IANA.  It is
+             an  8-bit identifier of the type mobility option.
+
+          Option Length:
+             8-bit unsigned integer, representing the length in octets of
+             the Subtype and Identifier fields.
+
+          Subtype:
+             Subtype field defines the specific type of identifier included
+             in the Identifier field.
+
+          Identifier:
+             A variable length identifier of type, as specified by the
+             Subtype field of this option.
+
+
+       This option does not have any alignment requirements.
+
+     */
+    ip6_mh_opt_mobile_node_identifier_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_mobile_node_identifier_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_mobile_node_identifier_t *) iov->iov_base;
+    opt->ip6mnid_type    = IP6_MHOPT_MOBILE_NODE_IDENTIFIER;
+    opt->ip6mnid_len     = 9;  //set to 9 bytes.
+    opt->ip6mnid_subtype = subtype;
+    opt->ip6mnid_id      = *MN_ID;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_mobile_node_link_layer_identifier(struct iovec *iov, ip6mnid_t * mnlli)
+{
+    /* From RFC 5213
+     * 8.6. Mobile Node Link-layer Identifier Option
+
+
+   A new option, Mobile Node Link-layer Identifier option is defined for
+   use with the Proxy Binding Update and Proxy Binding Acknowledgement
+   messages exchanged between a local mobility anchor and a mobile
+   access gateway.  This option is used for exchanging the mobile node's
+   link-layer identifier.
+
+   The format of the Link-layer Identifier option is shown below.  Based
+   on the size of the identifier, the option MUST be aligned
+   appropriately, as per mobility option alignment requirements
+   specified in [RFC3775].
+
+     0                   1                   2                   3
+     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |   Type        |    Length     |          Reserved             |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    |                                                               |
+    +                        Link-layer Identifier                  +
+    .                              ...                              .
+    |                                                               |
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+     Type
+         25
+
+     Length
+         8-bit unsigned integer indicating the length of the option
+         in octets, excluding the type and length fields.
+
+     Reserved
+
+         This field is unused for now.  The value MUST be initialized to
+         0 by the sender and MUST be ignored by the receiver.
+
+     Link-layer Identifier
+
+         A variable length field containing the mobile node's link-layer
+         identifier.
+
+         The content and format of this field (including byte and bit
+         ordering) is as specified in Section 4.6 of [RFC4861] for
+         carrying link-layer addresses.  On certain access links, where
+         the link-layer address is not used or cannot be determined,
+         this option cannot be used.
+
+
+     */
+    ip6_mh_opt_mobile_node_link_layer_identifier_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_mobile_node_link_layer_identifier_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_mobile_node_link_layer_identifier_t *) iov->iov_base;
+    opt->ip6mnllid_type     = IP6_MHOPT_MOBILE_NODE_LINK_LAYER_IDENTIFIER;
+    opt->ip6mnllid_len      = 10;  //set to 10 bytes.
+    opt->ip6mnllid_reserved = 0;
+    opt->ip6mnllid_lli      = *mnlli;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_time_stamp(struct iovec *iov, ip6ts_t * Timestamp)
+{
+    /* From RFC 5213
+     8.8. Timestamp Option
+
+
+        A new option, Timestamp option is defined for use in the Proxy
+        Binding Update and Proxy Binding Acknowledgement messages.
+
+        The Timestamp option has an alignment requirement of 8n+2.  Its
+        format is as follows:
+
+          0                   1                   2                   3
+          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+                                          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                          |      Type     |   Length      |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+          |                                                               |
+          +                          Timestamp                            +
+          |                                                               |
+          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+           Type
+               27
+
+           Length
+
+               8-bit unsigned integer indicating the length in octets of
+               the option, excluding the type and length fields.  The value
+               for this field MUST be set to 8.
+
+           Timestamp
+
+               A 64-bit unsigned integer field containing a timestamp.  The
+               value indicates the number of seconds since January 1, 1970,
+               00:00 UTC, by using a fixed point format.  In this format, the
+               integer number of seconds is contained in the first 48 bits of
+               the field, and the remaining 16 bits indicate the number of
+               1/65536 fractions of a second.
+     */
+    ip6_mh_opt_time_stamp_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_time_stamp_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len  = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_time_stamp_t *) iov->iov_base;
+    opt->ip6mots_type = IP6_MHOPT_TIME_STAMP;
+    opt->ip6mots_len  = 8;   // set to 8 bytes.
+    opt->time_stamp   = *Timestamp;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_link_local_address(struct iovec *iov, struct in6_addr *lla)
+{
+    /* From RFC 5213
+     8.7. Link-local Address Option
+
+
+        A new option, Link-local Address option is defined for use with the
+        Proxy Binding Update and Proxy Binding Acknowledgement messages
+        exchanged between a local mobility anchor and a mobile access
+        gateway.  This option is used for exchanging the link-local address
+        of the mobile access gateway.
+
+        The Link-local Address option has an alignment requirement of 8n+6.
+        Its format is as follows:
+
+            0                   1                   2                   3
+            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+                                           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                           |   Type        |    Length     |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+           |                                                               |
+           +                                                               +
+           |                                                               |
+           +                  Link-local Address                           +
+           |                                                               |
+           +                                                               +
+           |                                                               |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+            Type
+                26
+
+            Length
+
+                8-bit unsigned integer indicating the length of the option
+                in octets, excluding the type and length fields.  This field
+                MUST be set to 16.
+
+            Link-local Address
+
+                A sixteen-byte field containing the link-local address.
+     */
+    ip6_mh_opt_link_local_address_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_link_local_address_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_link_local_address_t *) iov->iov_base;
+    opt->ip6link_type = IP6_MHOPT_LINK_LOCAL_ADDRESS;
+    opt->ip6link_len  = 16;  //set to 16 bytes
+    opt->ip6link_addr = *lla;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_dst_mn_addr(struct iovec *iov, struct in6_addr *dst_mn_addr)
+{
+    ip6_mh_opt_dst_mn_addr_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_dst_mn_addr_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_dst_mn_addr_t *) iov->iov_base;
+    opt->ip6dma_type = IP6_MHOPT_DST_MN_ADDR;
+    opt->ip6dma_len = 16;
+    opt->dst_mn_addr = *dst_mn_addr;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_serv_mag_addr(struct iovec *iov, struct in6_addr *Serv_MAG_addr)
+{
+    ip6_mh_opt_serv_mag_addr_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_serv_mag_addr_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_serv_mag_addr_t *) iov->iov_base;
+    opt->ip6sma_type = IP6_MHOPT_SERV_MAG_ADDR;
+    opt->ip6sma_len = 16;   //16 bytes
+    opt->serv_mag_addr = *Serv_MAG_addr;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_serv_lma_addr(struct iovec *iov, struct in6_addr *serv_lma_addr)
+{
+    ip6_mh_opt_serv_lma_addr_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_serv_lma_addr_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_serv_lma_addr_t *) iov->iov_base;
+    opt->ip6sla_type = IP6_MHOPT_SERV_LMA_ADDR;
+    opt->ip6sla_len = 16;   //16 bytes
+    opt->serv_lma_addr = *serv_lma_addr;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_src_mn_addr(struct iovec *iov, struct in6_addr *src_mn_addr)
+{
+    struct ip6_mh_opt_src_mn_addr *opt;
+    size_t optlen = sizeof(struct ip6_mh_opt_src_mn_addr);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (struct ip6_mh_opt_src_mn_addr *) iov->iov_base;
+    opt->ip6sma_type = IP6_MHOPT_SRC_MN_ADDR;
+    opt->ip6sma_len = 16;   //16 bytes
+    opt->src_mn_addr = *src_mn_addr;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_create_opt_src_mag_addr(struct iovec *iov, struct in6_addr *src_mag_addr)
+{
+    ip6_mh_opt_src_mag_addr_t *opt;
+    size_t optlen = sizeof(ip6_mh_opt_src_mag_addr_t);
+    iov->iov_base = malloc(optlen);
+    iov->iov_len = optlen;
+    if (iov->iov_base == NULL)
+        return -ENOMEM;
+    opt = (ip6_mh_opt_src_mag_addr_t *) iov->iov_base;
+    opt->ip6sma_type = IP6_MHOPT_SRC_MAG_ADDR;
+    opt->ip6sma_len = 16;   //16 bytes
+    opt->src_mag_addr = *src_mag_addr;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_pbu_parse(msg_info_t * info, struct ip6_mh_binding_update *pbu, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif)
+{
+    static struct mh_options mh_opts;
+    ip6_mh_opt_home_net_prefix_t                     *home_net_prefix_opt;
+    ip6_mh_opt_mobile_node_identifier_t              *mobile_node_identifier_opt;
+    ip6_mh_opt_mobile_node_link_layer_identifier_t   *mobile_node_link_layer_identifier_opt;
+    ip6_mh_opt_time_stamp_t                          *time_stamp_opt;
+    ip6_mh_opt_handoff_indicator_t                   *handoff_indicator_opt;
+    ip6_mh_opt_access_technology_type_t              *access_technology_type_opt;
+    struct in6_addr                                  mn_identifier;
+    int                                              return_code;
+    bzero(&mh_opts, sizeof(mh_opts));
+    info->src = *in_addrs->src;
+    info->dst = *in_addrs->dst;
+    info->iif = iif;
+    info->addrs.src = &info->src;
+    info->addrs.dst = &info->dst;
+    if (len < (ssize_t)sizeof(struct ip6_mh_binding_update)) {
+        dbg("Bad len of PBU mobility header   : %d versus sizeof(struct ip6_mh_binding_update)= %d\n", len, sizeof(struct ip6_mh_binding_update));
+        return 0;
+    }
+    if ((return_code = mh_opt_parse(&pbu->ip6mhbu_hdr, len, sizeof(struct ip6_mh_binding_update), &mh_opts)) < 0) {
+        dbg("Error %d in parsing PBU options\n", return_code);
+        return 0;
+    }
+    info->PBU_flags = ntohs(pbu->ip6mhbu_flags);
+    info->lifetime.tv_sec = (ntohs(pbu->ip6mhbu_lifetime) << 2);
+    info->seqno = ntohs(pbu->ip6mhbu_seqno);
+    dbg("Serving MAG Address: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&info->src));
+    dbg("Our Address        : %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&info->dst));
+    dbg("PBU FLAGS          : %04X\n", info->PBU_flags);
+    dbg("PBU Lifetime       : %d (%d seconds)\n", pbu->ip6mhbu_lifetime, info->lifetime.tv_sec);
+    dbg("PBU Sequence No    : %d\n", info->seqno);
+
+    mobile_node_identifier_opt = mh_opt(&pbu->ip6mhbu_hdr, &mh_opts, IP6_MHOPT_MOBILE_NODE_IDENTIFIER);
+    if (mobile_node_identifier_opt) {
+        //copy
+        mn_identifier = in6addr_any;
+        memcpy(&mn_identifier.s6_addr32[2], &mobile_node_identifier_opt->ip6mnid_id, sizeof(ip6mnid_t));
+        dbg("Mobile Node Identifier Option: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&mn_identifier));
+    }
+
+    home_net_prefix_opt = mh_opt(&pbu->ip6mhbu_hdr, &mh_opts, IP6_MHOPT_HOME_NETWORK_PREFIX);
+    if (home_net_prefix_opt)
+    {
+        //copy
+        info->mn_prefix = home_net_prefix_opt->ip6hnp_prefix;
+        dbg("Mobile Node Home Network Prefix option: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&info->mn_prefix));
+    }
+
+    mobile_node_link_layer_identifier_opt = mh_opt(&pbu->ip6mhbu_hdr, &mh_opts, IP6_MHOPT_MOBILE_NODE_LINK_LAYER_IDENTIFIER);
+    if (mobile_node_link_layer_identifier_opt) {
+        //copy
+        info->mn_iid = in6addr_any;
+        memcpy(&info->mn_iid.s6_addr32[2], &mobile_node_link_layer_identifier_opt->ip6mnllid_lli, sizeof(ip6mnid_t));
+        dbg("Mobile Node Link-layer Identifier Option: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&info->mn_iid));
+    }
+
+    time_stamp_opt = mh_opt(&pbu->ip6mhbu_hdr, &mh_opts, IP6_MHOPT_TIME_STAMP);
+    if (time_stamp_opt) {
+        //copy
+        info->timestamp.first = time_stamp_opt->time_stamp.first;
+        info->timestamp.second = time_stamp_opt->time_stamp.second;
+        unsigned long long int seconds = info->timestamp.first << 16;
+        seconds = seconds | ((info->timestamp.second & 0xFFFF0000) >> 16);
+        unsigned int useconds = (info->timestamp.second & 0x0000FFFF) * 1000000 / 65536;
+        dbg("Timestamp option: %ld sec %d usec\n", seconds, useconds);
+    }
+
+    handoff_indicator_opt = mh_opt(&pbu->ip6mhbu_hdr, &mh_opts, IP6_MHOPT_HANDOFF_INDICATOR);
+    if (handoff_indicator_opt) {
+        dbg("Handoff Indicator option: %d\n", handoff_indicator_opt->ip6hi_hi);
+    }
+
+    access_technology_type_opt = mh_opt(&pbu->ip6mhbu_hdr, &mh_opts, IP6_MHOPT_ACCESS_TECHNOLOGY_TYPE);
+    if (access_technology_type_opt) {
+        dbg("Access Technology Type option: %d\n", access_technology_type_opt->ip6att_att);
+    }
+
+    info->msg_event = hasPBU;
+    dbg("FSM Message Event: %d\n", info->msg_event);
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_pba_parse(msg_info_t * info, struct ip6_mh_binding_ack *pba, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif)
+{
+    static struct mh_options mh_opts;
+    ip6_mh_opt_home_net_prefix_t                     *home_net_prefix_opt;
+    ip6_mh_opt_mobile_node_identifier_t              *mobile_node_identifier_opt;
+    ip6_mh_opt_mobile_node_link_layer_identifier_t   *mobile_node_link_layer_identifier_opt;
+    ip6_mh_opt_time_stamp_t                          *time_stamp_opt;
+    ip6_mh_opt_handoff_indicator_t                   *handoff_indicator_opt;
+    ip6_mh_opt_access_technology_type_t              *access_technology_type_opt;
+    struct in6_addr                                  mn_identifier;
+
+    bzero(&mh_opts, sizeof(mh_opts));
+    info->src = *in_addrs->src;
+    info->dst = *in_addrs->dst;
+    info->iif = iif;
+    info->addrs.src = &info->src;
+    info->addrs.dst = &info->dst;
+
+    mobile_node_identifier_opt = mh_opt(&pba->ip6mhba_hdr, &mh_opts, IP6_MHOPT_MOBILE_NODE_IDENTIFIER);
+    if (mobile_node_identifier_opt) {
+        //copy
+        mn_identifier = in6addr_any;
+        memcpy(&mn_identifier.s6_addr32[2], &mobile_node_identifier_opt->ip6mnid_id, sizeof(ip6mnid_t));
+        dbg("Mobile Node Identifier Option: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&mn_identifier));
+    }
+
+    if ((len < (ssize_t)sizeof(struct ip6_mh_binding_ack)
+            || mh_opt_parse(&pba->ip6mhba_hdr, len, sizeof(struct ip6_mh_binding_ack), &mh_opts) < 0)) {
+        return 0;
+    }
+    home_net_prefix_opt = mh_opt(&pba->ip6mhba_hdr, &mh_opts, IP6_MHOPT_HOME_NETWORK_PREFIX);
+    if (home_net_prefix_opt) {
+        info->mn_prefix = home_net_prefix_opt->ip6hnp_prefix;
+        dbg("Mobile Node Home Network Prefix option: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&info->mn_prefix));
+    }
+
+    mobile_node_link_layer_identifier_opt = mh_opt(&pba->ip6mhba_hdr, &mh_opts, IP6_MHOPT_MOBILE_NODE_LINK_LAYER_IDENTIFIER);
+    if (mobile_node_link_layer_identifier_opt) {
+        //copy
+        info->mn_iid = in6addr_any;
+        memcpy(&info->mn_iid.s6_addr32[2], &mobile_node_link_layer_identifier_opt->ip6mnllid_lli, sizeof(ip6mnid_t));
+        dbg("Mobile Node Link-layer Identifier Option: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&info->mn_iid));
+    }
+
+    time_stamp_opt = mh_opt(&pba->ip6mhba_hdr, &mh_opts, IP6_MHOPT_TIME_STAMP);
+    if (time_stamp_opt) {
+        //copy
+        info->timestamp.first = time_stamp_opt->time_stamp.first;
+        info->timestamp.second = time_stamp_opt->time_stamp.second;
+        unsigned long long int seconds = info->timestamp.first << 16;
+        seconds = seconds | ((info->timestamp.second & 0xFFFF0000) >> 16);
+        unsigned int useconds = (info->timestamp.second & 0x0000FFFF) * 1000000 / 65536;
+        dbg("Timestamp option: %ld sec %d usec\n", seconds, useconds);
+    }
+
+    handoff_indicator_opt = mh_opt(&pba->ip6mhba_hdr, &mh_opts, IP6_MHOPT_HANDOFF_INDICATOR);
+    if (handoff_indicator_opt) {
+        dbg("Handoff Indicator option: %d\n", handoff_indicator_opt->ip6hi_hi);
+    }
+
+    access_technology_type_opt = mh_opt(&pba->ip6mhba_hdr, &mh_opts, IP6_MHOPT_ACCESS_TECHNOLOGY_TYPE);
+    if (access_technology_type_opt) {
+        dbg("Access Technology Type option: %d\n", access_technology_type_opt->ip6att_att);
+    }
+
+    info->seqno = ntohs(pba->ip6mhba_seqno);
+    info->PBA_flags = ntohs(pba->ip6mhba_flags);
+    info->lifetime.tv_sec = ntohs(pba->ip6mhba_lifetime) << 2;
+    dbg("PBA FLAGS      : %04X\n", info->PBA_flags);
+    dbg("PBA Lifetime   : %d (%d seconds)\n", pba->ip6mhba_lifetime, info->lifetime.tv_sec);
+    dbg("PBA Sequence No: %d\n", info->seqno);
+    info->msg_event = hasPBA;
+    dbg("FSM Message Event: %d\n", info->msg_event);
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int icmp_rs_parse(msg_info_t * info, __attribute__ ((unused)) struct nd_router_solicit *rs, const struct in6_addr *saddr, const struct in6_addr *daddr, int iif, int hoplimit)
+{
+    bzero(info, sizeof(msg_info_t));
+    //info->ns_target = ns->nd_ns_target;
+    info->hoplimit = hoplimit;
+    info->msg_event = hasRS;
+    info->src = *saddr;
+    info->dst = *daddr;
+    info->iif = iif;
+    info->addrs.src = &info->src;
+    info->addrs.dst = &info->dst;
+    //Calculated fields
+    info->mn_iid = get_node_id(&info->src);
+    dbg("MN IID: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&info->mn_iid));
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int icmp_na_parse(msg_info_t * info, struct nd_neighbor_advert *na, const struct in6_addr *saddr, const struct in6_addr *daddr, int iif, int hoplimit)
+{
+    bzero(info, sizeof(msg_info_t));
+    info->na_target = na->nd_na_target;
+    info->hoplimit = hoplimit;
+    info->msg_event = hasNA;
+    info->src = *saddr;
+    info->dst = *daddr;
+    info->iif = iif;
+    info->addrs.src = &info->src;
+    info->addrs.dst = &info->dst;
+    //Calculated fields
+    info->mn_iid = get_node_id(&info->na_target);
+    info->mn_addr = info->na_target;
+    info->mn_prefix = get_node_prefix(&info->na_target);
+    dbg("NA Target: %x:%x:%x:%x:%x:%x:%x:%x\n", NIP6ADDR(&na->nd_na_target));
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_mh_send(const struct in6_addr_bundle *addrs, const struct iovec *mh_vec, int iovlen, int oif)
+{
+    struct sockaddr_in6 daddr;
+    struct iovec iov[2 * (IP6_MHOPT_MAX + 1)];
+    struct msghdr msg;
+    struct cmsghdr *cmsg;
+    int cmsglen;
+    struct in6_pktinfo pinfo;
+    int ret = 0, on = 1;
+    struct ip6_mh *mh;
+    int iov_count;
+
+    iov_count = mh_try_pad(mh_vec, iov, iovlen);
+
+    mh = (struct ip6_mh *) iov[0].iov_base;
+    mh->ip6mh_hdrlen = (mh_length(iov, iov_count) >> 3) - 1;
+    dbg("Sending MH type %d\n" "from %x:%x:%x:%x:%x:%x:%x:%x\n" "to %x:%x:%x:%x:%x:%x:%x:%x\n", mh->ip6mh_type, NIP6ADDR(addrs->src), NIP6ADDR(addrs->dst));
+
+    memset(&daddr, 0, sizeof(struct sockaddr_in6));
+    daddr.sin6_family = AF_INET6;
+    daddr.sin6_addr = *addrs->dst;
+    daddr.sin6_port = htons(IPPROTO_MH);
+
+    memset(&pinfo, 0, sizeof(pinfo));
+    pinfo.ipi6_addr = *addrs->src;
+    pinfo.ipi6_ifindex = oif;
+
+    cmsglen = CMSG_SPACE(sizeof(pinfo));
+    cmsg = malloc(cmsglen);
+
+    if (cmsg == NULL) {
+        dbg("malloc failed\n");
+        return -ENOMEM;
+    }
+    memset(cmsg, 0, cmsglen);
+    memset(&msg, 0, sizeof(msg));
+    msg.msg_control = cmsg;
+    msg.msg_controllen = cmsglen;
+    msg.msg_iov = iov;
+    msg.msg_iovlen = iov_count;
+    msg.msg_name = (void *) &daddr;
+    msg.msg_namelen = sizeof(daddr);
+
+    cmsg = CMSG_FIRSTHDR(&msg);
+    cmsg->cmsg_len = CMSG_LEN(sizeof(pinfo));
+    cmsg->cmsg_level = IPPROTO_IPV6;
+    cmsg->cmsg_type = IPV6_PKTINFO;
+    memcpy(CMSG_DATA(cmsg), &pinfo, sizeof(pinfo));
+
+    pthread_mutex_lock(&mh_sock.send_mutex);
+    setsockopt(mh_sock.fd, IPPROTO_IPV6, IPV6_PKTINFO, &on, sizeof(int));
+    ret = sendmsg(mh_sock.fd, &msg, 0);
+    if (ret < 0) {
+        dbg("sendmsg: %s\n", strerror(errno));
+    }
+    pthread_mutex_unlock(&mh_sock.send_mutex);
+    free(msg.msg_control);
+    dbg("MH is sent....\n");
+    return ret;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_send_pbu(const struct in6_addr_bundle *addrs, pmip_entry_t * bce, struct timespec *lifetime, int oif)
+{
+    /*  FROM RFC 5213
+     *
+     * 6.9.1.5. Constructing the Proxy Binding Update Message
+
+       o  The mobile access gateway, when sending the Proxy Binding Update
+          message to the local mobility anchor, MUST construct the message
+          as specified below.
+
+              IPv6 header (src=Proxy-CoA, dst=LMAA)
+                Mobility header
+                   - BU  P & A flags MUST be set to value 1
+                  Mobility Options
+                   - Mobile Node Identifier option            (mandatory)
+                   - Home Network Prefix option(s)            (mandatory)
+                   - Handoff Indicator option                 (mandatory)
+                   - Access Technology Type option            (mandatory)
+                   - Timestamp option                         (optional)
+                   - Mobile Node Link-layer Identifier option (optional)
+                   - Link-local Address option                (optional)
+
+                    Figure 12: Proxy Binding Update Message Format
+
+
+       o  The Source Address field in the IPv6 header of the message MUST be
+          set to the global address configured on the egress interface of
+          the mobile access gateway.  When there is no Alternate Care-of
+          Address option present in the request, this address will be
+          considered as the Proxy-CoA for this Proxy Binding Update message.
+          However, when there is an Alternate Care-of Address option present
+          in the request, this address will be not be considered as the
+          Proxy-CoA, but the address in the Alternate Care-of Address option
+          will be considered as the Proxy-CoA.
+
+       o  The Destination Address field in the IPv6 header of the message
+          MUST be set to the local mobility anchor address.
+
+       o  The Mobile Node Identifier option [RFC4283] MUST be present.
+
+       o  At least one Home Network Prefix option MUST be present.
+
+       o  The Handoff Indicator option MUST be present.
+
+       o  The Access Technology Type option MUST be present.
+
+       o  The Timestamp option MAY be present.
+
+       o  The Mobile Node Link-layer Identifier option MAY be present.
+
+       o  The Link-local Address option MAY be present.
+
+       o  If IPsec is used for protecting the signaling messages, the
+          message MUST be protected, using the security association existing
+          between the local mobility anchor and the mobile access gateway.
+
+       o  Unlike in Mobile IPv6 [RFC3775], the Home Address option [RFC3775]
+          MUST NOT be present in the IPv6 Destination Options extension
+          header of the Proxy Binding Update message.
+    */
+
+    int                           iovlen = 1;
+    struct ip6_mh_binding_update *pbu;
+    static struct iovec           mh_vec[2 * (IP6_MHOPT_MAX + 1)];
+    static struct iovec           dummy_mh_vec[2 * (IP6_MHOPT_MAX + 1)];
+    struct timeval                tv;
+    struct timezone               tz;
+    ip6mnid_t                     mn_id;
+    ip6mnid_t                     mn_hardware_address;
+    uint16_t                      p_flag = 1;
+    int                           iov_count;
+
+    memset((void*)mh_vec       , 0, (2 * (IP6_MHOPT_MAX + 1))*sizeof(struct iovec));
+    memset((void*)dummy_mh_vec , 0, (2 * (IP6_MHOPT_MAX + 1))*sizeof(struct iovec));
+
+    pbu = mh_create(&mh_vec[0], IP6_MH_TYPE_BU);
+    if (!pbu) {
+        dbg("mh_create(&mh_vec[0], IP6_MH_TYPE_BU) failed\n");
+        return -ENOMEM;
+    }
+    bce->seqno_out        = get_new_pbu_sequence_number();
+    pbu->ip6mhbu_seqno    = htons(bce->seqno_out);
+    pbu->ip6mhbu_flags    = bce->PBU_flags; // no htons since endianess already taken in account in ip6mh.h
+    pbu->ip6mhbu_lifetime = htons(lifetime->tv_sec >> 2);
+    dbg("Create PBU with lifetime = %d seconds (config = %d seconds)\n", lifetime->tv_sec, conf.PBULifeTime);
+    memcpy(&mn_id, &bce->mn_suffix.s6_addr32[2], sizeof(ip6mnid_t));
+    memcpy(&mn_hardware_address, &bce->mn_hw_address.s6_addr32[2], sizeof(ip6mnid_t));
+
+    dbg("Create PBU options...\n");
+    mh_create_opt_mobile_node_identifier(&mh_vec[iovlen++], p_flag, &mn_hardware_address);
+    mh_create_opt_home_net_prefix(&mh_vec[iovlen++], &bce->mn_prefix);
+    mh_create_opt_handoff_indicator(&mh_vec[iovlen++], IP6_MHOPT_HI_HANDOFF_BETWEEN_MAGS_FOR_SAME_INTERFACE);
+    mh_create_opt_access_technology_type(&mh_vec[iovlen++], IP6_MHOPT_ATT_IEEE802_11ABG);
+    mh_create_opt_mobile_node_link_layer_identifier(&mh_vec[iovlen++], &mn_id);
+
+    tz.tz_minuteswest = 0;          /* minutes west of Greenwich */
+    tz.tz_dsttime     = 3; //DST_WET;    /* type of DST correction */
+    if (gettimeofday(&tv, &tz) == 0) {
+        bce->timestamp.first  = tv.tv_sec >> 16;
+        bce->timestamp.second = (tv.tv_sec & 0x0000FFFF) << 16;
+        bce->timestamp.second += (((tv.tv_usec * 65536)/1000000) & 0x0000FFFF);
+        mh_create_opt_time_stamp(&mh_vec[iovlen++], &bce->timestamp);
+    } else {
+        bce->timestamp.first  = 0;
+        bce->timestamp.second = 0;
+        dbg("Timestamp option failed to get time, discard option\n");
+    }
+
+    iov_count = mh_try_pad(mh_vec, dummy_mh_vec, iovlen);
+
+
+    //calculate the length of the message.
+    pbu->ip6mhbu_hdr.ip6mh_hdrlen = mh_length(dummy_mh_vec, iov_count);
+
+    dbg("Send PBU....\n");
+    pmip_mh_send(addrs, dummy_mh_vec, iov_count, oif);
+
+    dbg("Copy PBU message into TEMP PMIP entry iovec....\n");
+    //copy the PBU message into the mh_vector for the entry for future retransmissions.
+    memcpy((void*)(bce->mh_vec), (void*)mh_vec, 2 * (IP6_MHOPT_MAX + 1)* sizeof(struct iovec));
+    bce->iovlen = iovlen;
+    //do not free, keep for retransmission free_iov_data(dummy_mh_vec, iov_count);
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int mh_send_pba(const struct in6_addr_bundle *addrs, pmip_entry_t * bce, struct timespec *lifetime, int oif)
+{
+    static struct iovec           mh_vec[2 * (IP6_MHOPT_MAX + 1)];
+    static struct iovec           dummy_mh_vec[2 * (IP6_MHOPT_MAX + 1)];
+    volatile int                  iovlen = 1;
+    struct ip6_mh_binding_ack    *pba;
+    uint16_t                      p_flag = 1;
+    ip6mnid_t                     mn_id;
+    ip6mnid_t                     mn_hardware_address;
+    int                           iov_count;
+
+    //bzero(mh_vec, sizeof(mh_vec));
+    memset((void*)mh_vec       , 0, (2 * (IP6_MHOPT_MAX + 1))*sizeof(struct iovec));
+    memset((void*)dummy_mh_vec , 0, (2 * (IP6_MHOPT_MAX + 1))*sizeof(struct iovec));
+
+    pba = mh_create(&mh_vec[0], IP6_MH_TYPE_BACK);
+    if (!pba) {
+        dbg("mh_create() failed\n");
+        return -ENOMEM;
+    }
+    dbg("Create PBA with lifetime = %d seconds\n", lifetime->tv_sec);
+    pba->ip6mhba_status = bce->status;
+    pba->ip6mhba_flags  = bce->PBA_flags;
+    pba->ip6mhba_seqno  = htons(bce->seqno_in);
+
+    bce->seqno_out      = bce->seqno_in;
+
+    pba->ip6mhba_lifetime = htons(lifetime->tv_sec >> 2);
+    dbg("Create PBA options....\n");
+    memcpy(&mn_id, &bce->mn_suffix.s6_addr32[2], sizeof(ip6mnid_t));
+    memcpy(&mn_hardware_address, &bce->mn_hw_address.s6_addr32[2], sizeof(ip6mnid_t));
+    mh_create_opt_mobile_node_identifier(&mh_vec[iovlen++], p_flag, &mn_hardware_address);
+    mh_create_opt_home_net_prefix(&mh_vec[iovlen++], &bce->mn_prefix);
+    mh_create_opt_mobile_node_link_layer_identifier(&mh_vec[iovlen++], &mn_id);
+    mh_create_opt_time_stamp(&mh_vec[iovlen++], &bce->timestamp);
+
+    iov_count = mh_try_pad(mh_vec, dummy_mh_vec, iovlen);
+
+    //calculate the length of the message.
+    pba->ip6mhba_hdr.ip6mh_hdrlen = mh_length(dummy_mh_vec, iov_count);
+    dbg("Send PBA...\n");
+    pmip_mh_send(addrs, dummy_mh_vec, iov_count, oif);
+    free_iov_data(dummy_mh_vec, iov_count);
+    return 0;
+}
diff -Nur umip/src/pmip/pmip_msgs.h umip-pmipv6/src/pmip/pmip_msgs.h
--- umip/src/pmip/pmip_msgs.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_msgs.h	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,249 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_msgs.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup MESSAGES MESSAGES
+ * \ingroup PMIP6D
+ *  PMIP Messages (MSGs)
+ *  @{
+ */
+
+#ifndef __PMIP_MSGS_H__
+#    define __PMIP_MSGS_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_MSGS_C
+#        define private_pmip_msgs(x) x
+#        define protected_pmip_msgs(x) x
+#        define public_pmip_msgs(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_msgs(x)
+#            define protected_pmip_msgs(x) extern x
+#            define public_pmip_msgs(x) extern x
+#        else
+#            define private_pmip_msgs(x)
+#            define protected_pmip_msgs(x)
+#            define public_pmip_msgs(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+#include <netinet/ip6mh.h>
+#include "icmp6.h"
+#include "mh.h"
+//-----------------------------------------------------------------------------
+#include "pmip_cache.h"
+//-GLOBAL VARIABLES----------------------------------------------------------------------------
+/*! \var int g_mag_sequence_number
+\brief Sequence number to be used for constructing PBU messages on a MAG.
+*/
+private_pmip_msgs(int g_mag_sequence_number;)
+
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn void init_pbu_sequence_number(void)
+* \brief Initialize the sequence number generator for PBU messages.
+*/
+protected_pmip_msgs(void init_pbu_sequence_number(void);)
+
+/*! \fn int get_new_pbu_sequence_number(void)
+* \brief Return a valid sequence number to be used for constructing PBU messages on a MAG.
+* \return   A valid sequence number.
+*/
+protected_pmip_msgs(int get_new_pbu_sequence_number(void);)
+
+/*! \fn int is_pba_is_response_to_last_pbu_sent(msg_info_t * , pmip_entry_t *)
+* \brief Check if a PBA response is the response to the last sent PBU, this function can be called only on a MAG.
+* \param[in]  pba_info The message information structure
+* \param[in]  bce      The binding cache entry
+* \return   1 if true, 0 if false.
+*/
+protected_pmip_msgs(int is_pba_is_response_to_last_pbu_sent(msg_info_t * pba_info, pmip_entry_t *bce);)
+
+/*! \fn struct in6_addr get_node_id(struct in6_addr *)
+* \brief Translate a IPv6 address into a mobile interface identifier
+* \param[in]  mn_addr The mobile address
+* \return   The mobile interface identifier in a struct in6_addr.
+*/
+private_pmip_msgs(struct in6_addr get_node_id(struct in6_addr *mn_addr);)
+/*! \fn struct in6_addr get_node_prefix(struct in6_addr *)
+* \brief Retrieve the prefix of a IPv6 address
+* \param[in]  mn_addr A mobile IPv6 address
+* \return   The prefix.
+* \note The prefix len is 64 bits
+*/
+protected_pmip_msgs(struct in6_addr get_node_prefix(struct in6_addr *mn_addr);)
+/*! \fn int mh_create_opt_home_net_prefix(struct iovec *, struct in6_addr *)
+* \brief Creates the Home Network Prefix option.
+* \param[in,out]  iov Storage
+* \param[in]  Home_Network_Prefix Option home network prefix value
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_home_net_prefix(struct iovec *iov, struct in6_addr *Home_Network_Prefix);)
+
+/*! \fn int mh_create_opt_handoff_indicator(struct iovec *, int handoff_indicator)
+* \brief Creates the Home Network Prefix option.
+* \param[in,out]  iov Storage
+* \param[in]  handoff_indicator Type of handoff
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_handoff_indicator(struct iovec *iov, int handoff_indicator);)
+
+/*! \fn int mh_create_opt_access_technology_type(struct iovec *iov, int att))
+* \brief Creates the Access Technology Type option.
+* \param[in,out]  iov Storage
+* \param[in]  att Access technology through which the mobile node is connected to the access link on the mobile access gateway
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_access_technology_type(struct iovec *iov, int att);)
+
+/*! \fn int mh_create_opt_mobile_node_link_layer_identifier(struct iovec *, int, ip6mnid_t *)
+* \brief Creates the mobile interface identifier option.
+* \param[in-out]  iov Storage
+* \param[in]  mnlli  Option mobile node link layer identifier value
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_mobile_node_link_layer_identifier(struct iovec *iov, ip6mnid_t * mnlli);)
+/*! \fn int mh_create_opt_time_stamp(struct iovec *iov, ip6ts_t *)
+* \brief Creates the timestamp option.
+* \param[in-out]  iov Storage
+* \param[in]  Timestamp  Option timestamp value
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_time_stamp(struct iovec *iov, ip6ts_t * Timestamp);)
+/*! \fn int mh_create_opt_link_local_address(struct iovec *, struct in6_addr *)
+* \brief Creates the link local address option.
+* \param[in-out]  iov Storage
+* \param[in]  LinkLocal Option link local address value
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_link_local_address(struct iovec *iov, struct in6_addr *LinkLocal);)
+/*! \fn int mh_create_opt_dst_mn_addr(struct iovec *, struct in6_addr *)
+* \brief Creates the Destination MN address option.
+* \param[in-out]  iov Storage
+* \param[in]  dst_mn_addr  Destinantion mobile node address option value
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_dst_mn_addr(struct iovec *iov, struct in6_addr *dst_mn_addr);)
+
+/*! \fn int mh_create_opt_serv_mag_addr(struct iovec *, struct in6_addr *)
+* \brief Creates the Serving MAG address option.
+* \param[in-out]  iov Storage
+* \param[in]  serv_MAG_addr  Serving MAG address option value
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_serv_mag_addr(struct iovec *iov, struct in6_addr *serv_MAG_addr);)
+/*! \fn int mh_create_opt_serv_lma_addr(struct iovec *iov, struct in6_addr *)
+* \brief Creates the Serving LMA address option.
+* \param[in-out]  iov Storage
+* \param[in]  serv_lma_addr  Serving LMA address option value.
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_serv_lma_addr(struct iovec *iov, struct in6_addr *serv_lma_addr);)
+/*! \fn int mh_create_opt_src_mn_addr(struct iovec *, struct in6_addr *)
+* \brief Creates the source mobile node address option.
+* \param[in-out]  iov Storage
+* \param[in]  src_mn_addr  Source mobile node address option value.
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_src_mn_addr(struct iovec *iov, struct in6_addr *src_mn_addr);)
+/*! \fn int mh_create_opt_src_mag_addr(struct iovec *, struct in6_addr *)
+* \brief Creates the mobile interface identifier option.
+* \param[in-out]  iov Storage
+* \param[in]  src_mag_addr  Source MAG address option value.
+* \return   Zero if success, negative value otherwise.
+*/
+private_pmip_msgs(int mh_create_opt_src_mag_addr(struct iovec *iov, struct in6_addr *src_mag_addr);)
+/*! \fn int mh_pbu_parse(msg_info_t * info, struct ip6_mh_binding_update *pbu, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif)
+* \brief Parse PBU message.
+* \param[in-out]   info Storage containing all necessary informations about the message received.
+* \param[in]  pbu  Mobility header "Binding Update".
+* \param[in]  len  Length of pbu.
+* \param[in]  in_addrs  Source and Destination address of PBU message.
+* \param[in]  iif  Interface identifier.
+* \return   Zero.
+*/
+protected_pmip_msgs(int mh_pbu_parse(msg_info_t * info, struct ip6_mh_binding_update *pbu, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif);)
+/*! \fn int mh_pba_parse(msg_info_t * , struct ip6_mh_binding_ack *, ssize_t , const struct in6_addr_bundle *, int)
+* \brief Parse PBA message.
+* \param[in-out]   info Storage containing all necessary informations about the message received.
+* \param[in]  pba  Mobility header "Binding Acknowledgment".
+* \param[in]  len  Length of pbu.
+* \param[in]  in_addrs  Source and Destination address of PBU message.
+* \param[in]  iif  Interface identifier.
+* \return   Zero.
+*/
+protected_pmip_msgs(int mh_pba_parse(msg_info_t * info, struct ip6_mh_binding_ack *pba, ssize_t len, const struct in6_addr_bundle *in_addrs, int iif);)
+/*! \fn int icmp_rs_parse(msg_info_t * , struct nd_router_solicit *, const struct in6_addr *, const struct in6_addr *, int , int )
+* \brief Parse ICMPv6 RS message.
+* \param[in-out]   info Storage containing all necessary informations about the message received.
+* \param[in]  rs  Router sollicitation infos.
+* \param[in]  saddr  Source address of the message.
+* \param[in]  daddr  Destination address of the message.
+* \param[in]  iif  Interface identifier.
+* \param[in]  hoplimit  Hop limit value found in RS message.
+* \return   Zero.
+*/
+protected_pmip_msgs(int icmp_rs_parse(msg_info_t * info, __attribute__ ((unused)) struct nd_router_solicit *rs, const struct in6_addr *saddr, const struct in6_addr *daddr, int iif, int hoplimit);)
+/*! \fn int icmp_na_parse(msg_info_t *, struct nd_neighbor_advert *, const struct in6_addr *, const struct in6_addr *, int , int )
+* \brief Parse ICMPv6 NA message.
+* \param[in-out]   info Storage containing all necessary informations about the message received.
+* \param[in]  na  Neighbour advertisement infos.
+* \param[in]  saddr  Source address of the message.
+* \param[in]  daddr  Destination address of the message.
+* \param[in]  iif  Interface identifier.
+* \param[in]  hoplimit  Hop limit value found in NA message.
+* \return   Zero.
+*/
+protected_pmip_msgs(int icmp_na_parse(msg_info_t * info, struct nd_neighbor_advert *na, const struct in6_addr *saddr, const struct in6_addr *daddr, int iif, int hoplimit);)
+/*! \fn int pmip_mh_send(const struct in6_addr_bundle *, const struct iovec *, int , int )
+* \brief Send MH message.
+* \param[in]  addrs  Source and destination address of the message.
+* \param[in]  mh_vec  Storage of the message.
+* \param[in]  iovlen  Len of the storage.
+* \param[in]  oif  Outgoing interface identifier.
+* \return   Zero if success, negative value otherwise.
+*/
+protected_pmip_msgs(int pmip_mh_send(const struct in6_addr_bundle *addrs, const struct iovec *mh_vec, int iovlen, int oif);)
+/*! \fn int mh_send_pbu(const struct in6_addr_bundle *, pmip_entry_t *, struct timespec *lifetime, int oif)
+* \brief Send PBU message.
+* \param[in]  addrs  Source and destination address of the message.
+* \param[in]  bce  Binding cache entry corresponding to the binding.
+* \param[in]  lifetime  Lifetime of the binding.
+* \param[in]  oif  Outgoing interface identifier.
+* \return   Zero if success, negative value otherwise.
+*/
+protected_pmip_msgs(int mh_send_pbu(const struct in6_addr_bundle *addrs, pmip_entry_t * bce, struct timespec *lifetime, int oif);)
+/*! \fn int mh_send_pba(const struct in6_addr_bundle *, pmip_entry_t *, struct timespec *, int)
+* \brief Send PBA message.
+* \param[in]  addrs  Source and destination address of the message.
+* \param[in]  bce  Binding cache entry corresponding to the binding.
+* \param[in]  lifetime  Lifetime of the binding.
+* \param[in]  oif  Outgoing interface identifier.
+* \return   Zero if success, negative value otherwise.
+*/
+protected_pmip_msgs(int mh_send_pba(const struct in6_addr_bundle *addrs, pmip_entry_t * bce, struct timespec *lifetime, int oif);)
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip_pcap.c umip-pmipv6/src/pmip/pmip_pcap.c
--- umip/src/pmip/pmip_pcap.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_pcap.c	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,317 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_pcap.c
+* \brief Analyse of captured packets
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+#define PMIP
+#define PMIP_PCAP_C
+#ifdef HAVE_CONFIG_H
+#       include <config.h>
+#endif
+#include <string.h>
+#include <ctype.h>
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_fsm.h"
+#include "pmip_hnp_cache.h"
+#include "pmip_pcap.h"
+#include "pmip_msgs.h"
+#include "pmip_mag_proc.h"
+//---------------------------------------------------------------------------------------------------------------------
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+
+static pthread_t pcap_listener;
+
+//---------------------------------------------------------------------------------------------------------------------
+/*
+ * print data in rows of 16 bytes: offset   hex   ascii
+ *
+ * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
+ */
+void
+pmip_pcap_print_hex_ascii_line(const u_char *payload, int len, int offset)
+{
+
+    int i;
+    int gap;
+    const u_char *ch;
+
+    /* offset */
+    printf("%05d   ", offset);
+
+    /* hex */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        printf("%02x ", *ch);
+        ch++;
+        /* print extra space after 8th byte for visual aid */
+        if (i == 7)
+            printf(" ");
+    }
+    /* print space to handle line less than 8 bytes */
+    if (len < 8)
+        printf(" ");
+
+    /* fill hex gap with spaces if not full line */
+    if (len < 16) {
+        gap = 16 - len;
+        for (i = 0; i < gap; i++) {
+            printf("   ");
+        }
+    }
+    printf("   ");
+
+    /* ascii (if printable) */
+    ch = payload;
+    for(i = 0; i < len; i++) {
+        if (isprint(*ch))
+            printf("%c", *ch);
+        else
+            printf(".");
+        ch++;
+    }
+    printf("\n");
+}
+//---------------------------------------------------------------------------------------------------------------------
+/*
+ * print packet payload data (avoid printing binary data)
+ */
+void
+pmip_pcap_print_payload(const u_char *payload, int len)
+{
+
+    int len_rem = len;
+    int line_width = 16;                        /* number of bytes per line */
+    int line_len;
+    int offset = 0;                                     /* zero-based offset counter */
+    const u_char *ch = payload;
+
+    if (len <= 0)
+        return;
+
+    /* data fits on one line */
+    if (len <= line_width) {
+        pmip_pcap_print_hex_ascii_line(ch, len, offset);
+        return;
+    }
+
+    /* data spans multiple lines */
+    for ( ;; ) {
+        /* compute current line length */
+        line_len = line_width % len_rem;
+        /* print line */
+        pmip_pcap_print_hex_ascii_line(ch, line_len, offset);
+        /* compute total remaining */
+        len_rem = len_rem - line_len;
+        /* shift pointer to remaining bytes to print */
+        ch = ch + line_len;
+        /* add offset */
+        offset = offset + line_width;
+        /* check if we have line width chars or less */
+        if (len_rem <= line_width) {
+            /* print last line and get out */
+            pmip_pcap_print_hex_ascii_line(ch, len_rem, offset);
+            break;
+        }
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+
+/*!
+*  Construct message event and send it to the MAG FSM
+* \param
+*/
+void pmip_pcap_msg_handler_associate(struct in6_addr mn_iidP, int iifP)
+{
+    dbg("pmip_pcap_msg_handler_associate()\n");
+    msg_info_t msg;
+    memset(&msg, 0, sizeof(msg_info_t));
+    msg.mn_iid = EUI48_to_EUI64(mn_iidP);
+    msg.iif = iifP;
+    msg.msg_event = hasWLCCP;
+    mag_fsm(&msg);
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_pcap_msg_handler_deassociate(struct in6_addr mn_iidP, int iifP)
+{
+    dbg("pmip_pcap_msg_handler_desassociate()\n");
+    msg_info_t msg;
+    memset(&msg, 0, sizeof(msg_info_t));
+    msg.mn_iid = EUI48_to_EUI64(mn_iidP);
+    msg.iif = iifP;
+    msg.msg_event = hasDEREG;
+    mag_fsm(&msg);
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_pcap_loop_start(void)
+{
+    dbg("Getting ingress informations\n");
+    mag_get_ingress_info(&g_pcap_iif, g_pcap_devname);
+
+    if (pthread_create(&pcap_listener, NULL, pmip_pcap_loop, NULL))
+                return -1;
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+void pmip_pcap_loop_stop(void)
+{
+#undef HAVE_PCAP_BREAKLOOP
+//#define HAVE_PCAP_BREAKLOOP
+#ifdef HAVE_PCAP_BREAKLOOP
+    /*
+    * We have "pcap_breakloop()"; use it, so that we do as little
+    * as possible in the signal handler (it's probably not safe
+    * to do anything with standard I/O streams in a signal handler -
+    * the ANSI C standard doesn't say it is).
+    */
+    pcap_breakloop(pcap_descr);
+#endif
+
+    pthread_cancel(pcap_listener);
+    pthread_join(pcap_listener, NULL);
+}
+//---------------------------------------------------------------------------------------------------------------------
+void* pmip_pcap_loop(__attribute__ ((unused)) void *arg)
+{
+    bpf_u_int32 netaddr = 0, mask = 0;  // To store network address and netmask
+    struct bpf_program filter;  // Place to store the BPF filter program
+    char errbuf[PCAP_ERRBUF_SIZE];  // Error buffer
+    struct pcap_pkthdr pkthdr;  // Packet information (timestamp, size...)
+    const unsigned char *packet = NULL; // Received raw data
+    struct in6_addr mn_iid;
+    char filter_string[] = "udp port 514 or ip6 proto 58";
+    char addrmac[16];
+    char addrmacByte[16];
+    char *p;
+    int b, j, count;
+
+    dbg("[PCAP] Device is %s and iif is %d\n", g_pcap_devname, g_pcap_iif);
+
+    pcap_descr = NULL;
+    memset(errbuf, 0, PCAP_ERRBUF_SIZE);
+    memset(&mn_iid, 0, sizeof(struct in6_addr));
+    pcap_descr = pcap_open_live(g_pcap_devname, PCAPMAXBYTES2CAPTURE, 0, PCAPTIMEDELAYKERNEL2USERSPACE, errbuf);
+    if (pcap_descr == NULL)
+        dbg("Error %s", errbuf);
+    else if (*errbuf)
+        dbg("Warning %s\n", errbuf);
+
+// Look up info from the capture device
+    if (pcap_lookupnet(g_pcap_devname, &netaddr, &mask, errbuf) == -1) {
+        dbg("Can't get netmask for device %s\n", g_pcap_devname);
+        netaddr = 0;
+        mask = 0;
+    }
+
+// Compiles the filter expression into a BPF filter program
+    if (pcap_compile(pcap_descr, &filter, filter_string, 0, mask) == -1) {
+        dbg("Couldn't parse filter : %s\n", pcap_geterr(pcap_descr));
+   }
+// Load the filter program into the packet capture device
+    if (pcap_setfilter(pcap_descr, &filter) == -1) {
+        dbg("Couldn't install filter: %s\n", pcap_geterr(pcap_descr));
+    }
+
+    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+    while (1) {
+        packet = pcap_next(pcap_descr, &pkthdr);    // Get one packet
+
+        if ( ( pkthdr.len > 0 ) && ( packet != NULL ) ){
+            //pmip_pcap_print_payload(packet, pkthdr.len);
+            if (packet[54] == 0x85) { // case ROUTER SOLICITATION WITH ETHERNET HEADER
+                dbg("[PCAP] RECEIVED PACKET SIZE: %d bytes caplen %d bytes\n", pkthdr.len, pkthdr.caplen);
+                memset(&mn_iid, 0, sizeof(struct in6_addr));
+                for (b=0; b< 8; b++) {
+                    mn_iid.s6_addr[b+8] = packet[b+30];
+                }
+                mn_iid = EUI64_to_EUI48(mn_iid);
+                dbg("[PCAP] RECEIVED ROUTER SOLLICITATION OVER ETHERNET MAC ADDR %x:%x:%x:%x:%x:%x:%x:%x dev %s iif %d\n", NIP6ADDR(&mn_iid), g_pcap_devname, g_pcap_iif);
+                pmip_pcap_msg_handler_associate(mn_iid, g_pcap_iif);
+            } else if (packet[56] == 0x85) {// case ROUTER SOLICITATION WITHOUT ETHERNET HEADER
+                dbg("[PCAP] RECEIVED PACKET SIZE: %d bytes caplen %d bytes\n", pkthdr.len, pkthdr.caplen);
+                memset(&mn_iid, 0, sizeof(struct in6_addr));
+                for (b=0; b< 8; b++) {
+                    mn_iid.s6_addr[b+8] = packet[b+32];
+                }
+                mn_iid = EUI64_to_EUI48(mn_iid);
+                dbg("[PCAP] RECEIVED ROUTER SOLLICITATION OVER LTE MAC ADDR %x:%x:%x:%x:%x:%x:%x:%x dev %s iif %d\n", NIP6ADDR(&mn_iid), g_pcap_devname, g_pcap_iif);
+                pmip_pcap_msg_handler_associate(mn_iid, g_pcap_iif);
+            // approx 50 bytes for MAC + IP + UDP headers
+            } else if ((p = strstr((const char *)(&packet[PCAP_CAPTURE_SYSLOG_MESSAGE_FRAME_OFFSET]), conf.PcapSyslogAssociationGrepString)) != NULL) {
+                dbg("[PCAP] RECEIVED SYSLOG PACKET SIZE: %d bytes caplen %d bytes\n", pkthdr.len, pkthdr.caplen);
+                p = p + strlen(conf.PcapSyslogAssociationGrepString);
+                count = 0;
+                j = 0;
+                while ((count < 12) && (j < 32)) {
+                    if (isxdigit(p[j])) {
+                        addrmac[count++] = p[j] ;
+                    }
+                    j++;
+                }
+                addrmac[count] = '\0';
+                dbg ("Before conversion : %s \n", addrmac);
+
+                // convert ascii hex string to bin
+                for (b = 0 ; b < 6; b++) {
+                    strncpy(addrmacByte, addrmac+2*b, 2);
+                    addrmacByte[2] = '\0';
+                    // we can do (unsigned int*) because x86 processors are little-endian
+                    // (done for suppressing a warning)
+                    sscanf ((const char*)addrmacByte, "%02x", (unsigned int*)&mn_iid.s6_addr[10 + b]);
+                }
+                pmip_pcap_msg_handler_associate(mn_iid, g_pcap_iif);
+
+            }  else if ((p = strstr((const char *)(&packet[PCAP_CAPTURE_SYSLOG_MESSAGE_FRAME_OFFSET]), conf.PcapSyslogDeAssociationGrepString)) != NULL) {
+                dbg("[PCAP] RECEIVED PACKET SIZE: %d bytes caplen %d bytes\n", pkthdr.len, pkthdr.caplen);
+                p = p + strlen(conf.PcapSyslogDeAssociationGrepString);
+                count = 0;
+                j = 0;
+                while ((count < 12) && (j < 32)) {
+                    if (isxdigit(p[j])) {
+                        addrmac[count++] = p[j] ;
+                    }
+                    j++;
+                }
+                addrmac[count] = '\0';
+                dbg ("Before conversion : %s \n", addrmac);
+
+                // convert ascii hex string to bin
+                for (b = 0 ; b < 6; b++) {
+                    strncpy(addrmacByte, addrmac+2*b, 2);
+                    addrmacByte[2] = '\0';
+                    // we can do (unsigned int*) because x86 processors are little-endian
+                    // (done for suppressing a warning)
+                    sscanf ((const char*)addrmacByte, "%02x", (unsigned int*)&mn_iid.s6_addr[10 + b]);
+                }
+                pmip_pcap_msg_handler_deassociate(mn_iid, g_pcap_iif);
+            }
+        }
+    }
+    pthread_exit(NULL);
+}
+
diff -Nur umip/src/pmip/pmip_pcap.h umip-pmipv6/src/pmip/pmip_pcap.h
--- umip/src/pmip/pmip_pcap.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_pcap.h	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,104 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_pcap.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup PACKET_CAPTURE PACKET CAPTURE
+ * \ingroup PMIP6D
+ *  PMIP PACKet CAPture (PCAP)
+ *  @{
+ */
+
+#ifndef __PMIP_PCAP_H__
+#    define __PMIP_PCAP_H__
+//-----------------------------------------------------------------------------
+#    ifdef PMIP_PCAP_C
+#        define private_pmip_pcap(x) x
+#        define protected_pmip_pcap(x) x
+#        define public_pmip_pcap(x) x
+#    else
+#        ifdef PMIP
+#            define private_pmip_pcap(x)
+#            define protected_pmip_pcap(x) extern x
+#            define public_pmip_pcap(x) extern x
+#        else
+#            define private_pmip_pcap(x)
+#            define protected_pmip_pcap(x)
+#            define public_pmip_pcap(x) extern x
+#        endif
+#    endif
+//-----------------------------------------------------------------------------
+#    include <pcap.h>
+#    include <netinet/ip6.h>
+//-----------------------------------------------------------------------------
+#    define PCAPMAXBYTES2CAPTURE 65535
+#    define PCAPTIMEDELAYKERNEL2USERSPACE 1000
+#    define PCAP_CAPTURE_SYSLOG_MESSAGE_FRAME_OFFSET   42
+//-VARS----------------------------------------------------------------------------
+/*! \var pcap_t * pcap_descr
+\brief PCAP descriptor for capturing packets on MAG ingress interface.
+*/
+public_pmip_pcap(pcap_t * pcap_descr);
+/*! \var char* g_pcap_devname
+\brief PCAP device name on which the capture of packets is done.
+*/
+public_pmip_pcap(char g_pcap_devname[32]);
+/*! \var int   g_pcap_iif
+\brief PCAP device interface index on which the capture of packets is done.
+*/
+public_pmip_pcap(int   g_pcap_iif);
+//-PROTOTYPES----------------------------------------------------------------------------
+/*! \fn int pmip_pcap_loop_start(void)
+* \brief Start the PCAP listener thread.
+* \return 0 on success.
+*/
+public_pmip_pcap(int pmip_pcap_loop_start(void);)
+/*! \fn void pmip_pcap_loop_stop(void)
+* \brief Stop the PCAP listener thread.
+*/
+public_pmip_pcap(void pmip_pcap_loop_stop(void);)
+/*! \fn void* pmip_pcap_loop(void*)
+* \brief
+* \param[in]  devname The name of the device (ex "eth1") that will be listened for capturing packets.
+* \param[in]  iif     The interface identifier that will be listened for capturing packets.
+*/
+public_pmip_pcap(void* pmip_pcap_loop(void*);)
+/*! \fn void pmip_pcap_msg_handler_associate(struct in6_addr , int )
+* \brief  Construct amessage event telling that a mobile node is associated with the radio technology of the MAG, and send it to the MAG FSM.
+* \param[in]  mn_iidP  The MAC address of the mobile node.
+* \param[in]  iifP     The interface identifier that is listened for capturing packets.
+*/
+private_pmip_pcap(void pmip_pcap_msg_handler_associate(struct in6_addr mn_iidP, int iifP);)
+/*! \fn void pmip_pcap_msg_handler_deassociate(struct in6_addr , int )
+* \brief  Construct amessage event telling that a mobile node is de-associated with the radio technology of the MAG, and send it to the MAG FSM.
+* \param[in]  mn_iidP  The MAC address of the mobile node.
+* \param[in]  iifP     The interface identifier that is listened for capturing packets.
+*/
+private_pmip_pcap(void pmip_pcap_msg_handler_deassociate(struct in6_addr mn_iidP, int iifP);)
+#endif
+/** @}*/
+
+
diff -Nur umip/src/pmip/pmip_tunnel.c umip-pmipv6/src/pmip/pmip_tunnel.c
--- umip/src/pmip/pmip_tunnel.c	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_tunnel.c	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,199 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_tunnel.c
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+#define PMIP
+#define PMIP_TUNNEL_C
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+//---------------------------------------------------------------------------------------------------------------------
+#include "pmip_tunnel.h"
+#include "pmip_handler.h"
+//---------------------------------------------------------------------------------------------------------------------
+#include "tunnelctl.h"
+#include "util.h"
+#ifdef ENABLE_VT
+#    include "vt.h"
+#endif
+#include "debug.h"
+#include "conf.h"
+//-----------------------------------------------------------------------------
+int pmip_tunnel_get_timer_index(struct in6_addr  *remoteP)
+{
+    int    mag;
+    int    first_no_mag = -1;
+    for (mag = 0 ; mag < PMIP_MAX_MAGS; mag++) {
+        if (IN6_ARE_ADDR_EQUAL(&g_tunnel_timer_table[mag].remote, remoteP)) {
+            return mag;
+        } else if ((IN6_IS_ADDR_UNSPECIFIED(&g_tunnel_timer_table[mag].remote)) && (first_no_mag == -1)) {
+            first_no_mag = mag;
+        }
+    }
+    return first_no_mag;
+}
+//-----------------------------------------------------------------------------
+int pmip_tunnels_init(void)
+{
+    unsigned int mag;
+    unsigned int link;
+
+    memset((void*)g_tunnel_timer_table, 0, sizeof(tunnel_timer_t) * PMIP_MAX_MAGS);
+    for (mag = 0 ; mag < PMIP_MAX_MAGS; mag++) {
+        INIT_LIST_HEAD(&g_tunnel_timer_table[mag].tqe.list);
+    }
+    // create static tunnels if requested
+    if (conf.TunnelingEnabled) {
+        if (conf.DynamicTunnelingEnabled == 0) {
+            dbg("DynamicTunnelingEnabled is False\n");
+            if (is_ha()) {
+                for (mag = 0 ; mag < conf.NumMags; mag++) {
+                    link = if_nametoindex(conf.LmaPmipNetworkDevice);
+                    pmip_tunnel_add(&conf.LmaAddress, &conf.MagAddressEgress[mag], link);
+                }
+            } else if (is_mag()) {
+                link = if_nametoindex(conf.MagDeviceEgress);
+                pmip_tunnel_add(&conf.MagAddressEgress[0], &conf.LmaAddress, link);
+            }
+        } else {
+            dbg("DynamicTunnelingEnabled is True\n");
+		}
+    }
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_tunnel_set_timer(struct in6_addr  *remoteP, int tunnelP, struct timespec time_outP)
+{
+    struct timespec    now_time;
+    struct timespec    delay_before_delete_time;
+    struct timespec    expires;
+    int                mag_index;
+
+    tscpy(delay_before_delete_time, time_outP);
+
+    clock_gettime(CLOCK_REALTIME, &now_time);
+
+    tsadd(now_time, delay_before_delete_time, expires);
+
+    mag_index = pmip_tunnel_get_timer_index(remoteP);
+    dbg("Found mag index %d for mag@ %x:%x:%x:%x:%x:%x:%x:%x\n", mag_index, NIP6ADDR(remoteP));
+
+    // No timer lauched for this link
+    if ((g_tunnel_timer_table[mag_index].lifetime.tv_nsec == 0) && (g_tunnel_timer_table[mag_index].lifetime.tv_sec == 0)) {
+
+        dbg("PMIP add task pmip_timer_tunnel_expired_handler in %d seconds for tunel %d\n", time_outP.tv_sec, tunnelP);
+        tscpy(g_tunnel_timer_table[mag_index].lifetime, expires);
+        add_task_abs(&expires, &g_tunnel_timer_table[mag_index].tqe, pmip_timer_tunnel_expired_handler);
+
+    } else  if (tsafter(g_tunnel_timer_table[mag_index].lifetime, expires)) {
+
+        dbg("PMIP del old task pmip_timer_tunnel_expired_handler\n");
+        del_task(&g_tunnel_timer_table[mag_index].tqe);
+        dbg("PMIP add new task pmip_timer_tunnel_expired_handler in %d seconds for tunnel %d\n", time_outP.tv_sec, tunnelP);
+        tscpy(g_tunnel_timer_table[mag_index].lifetime, expires);
+        add_task_abs(&expires, &g_tunnel_timer_table[mag_index].tqe, pmip_timer_tunnel_expired_handler);
+
+    } else {
+        dbg("No new timer set for tunnel since a timer is currently running with higher time-out %d\n");
+    }
+    return 0;
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_tunnel_add(struct in6_addr *localP, struct in6_addr *remoteP, int linkP)
+{
+    int                mag_index;
+
+    if (conf.TunnelingEnabled) {
+        // Time-out timer on this tunnel does not exist
+        mag_index = pmip_tunnel_get_timer_index(remoteP);
+        dbg("Found mag index %d for mag@ %x:%x:%x:%x:%x:%x:%x:%x\n", mag_index, NIP6ADDR(remoteP));
+        if (conf.DynamicTunnelingEnabled) {
+            if ((g_tunnel_timer_table[mag_index].lifetime.tv_nsec == 0) && (g_tunnel_timer_table[mag_index].lifetime.tv_sec == 0)) {
+                int tunnel = tunnel_add(localP, remoteP, linkP, 0, 0); // -1 if error
+                g_tunnel_timer_table[mag_index].tunnel = tunnel;
+                g_tunnel_timer_table[mag_index].remote = *remoteP;
+                dbg("Creating dynamic IP-in-IP tunnel %d link %d from %x:%x:%x:%x:%x:%x:%x:%x to %x:%x:%x:%x:%x:%x:%x:%x...\n", tunnel, linkP, NIP6ADDR(localP), NIP6ADDR(remoteP));
+                return tunnel;
+            } else {
+                dbg("PMIP del old task pmip_timer_tunnel_expired_handler\n");
+                del_task(&g_tunnel_timer_table[mag_index].tqe);
+                int usercount = tunnel_getusers(g_tunnel_timer_table[mag_index].tunnel);
+                dbg("Keeping IP-in-IP tunnel %d link %d usercount %d\n", g_tunnel_timer_table[mag_index].tunnel, linkP, usercount);
+                return g_tunnel_timer_table[mag_index].tunnel;
+            }
+        } else {
+            if (IN6_ARE_ADDR_EQUAL(&g_tunnel_timer_table[mag_index].remote, remoteP)) {
+                dbg("Static IP-in-IP tunnel %d link %d from %x:%x:%x:%x:%x:%x:%x:%x to %x:%x:%x:%x:%x:%x:%x:%x...\n", g_tunnel_timer_table[mag_index].tunnel, linkP, NIP6ADDR(localP), NIP6ADDR(remoteP));
+                return g_tunnel_timer_table[mag_index].tunnel;
+            } else if (IN6_IS_ADDR_UNSPECIFIED(&g_tunnel_timer_table[mag_index].remote)) {
+                int tunnel = tunnel_add(localP, remoteP, linkP, 0, 0); // -1 if error
+                g_tunnel_timer_table[mag_index].tunnel = tunnel;
+                g_tunnel_timer_table[mag_index].remote = *remoteP;
+                dbg("Creating static IP-in-IP tunnel %d link %d from %x:%x:%x:%x:%x:%x:%x:%x to %x:%x:%x:%x:%x:%x:%x:%x...\n", tunnel, linkP, NIP6ADDR(localP), NIP6ADDR(remoteP));
+                return tunnel;
+            } else {
+                return -1;
+            }
+        }
+    } else {
+        dbg("IP-in-IP tunneling is disabled, no tunnel is created\n");
+        return 0;
+    }
+}
+//---------------------------------------------------------------------------------------------------------------------
+int pmip_tunnel_del(int tunnelP)
+{
+    int res = 0;
+    int mag_index;
+
+    dbg(" tunnel %d\n", tunnelP);
+    if (conf.TunnelingEnabled) {
+        if (tunnelP > 0) {
+            if (conf.DynamicTunnelingEnabled) {
+                int usercount = tunnel_getusers(tunnelP);
+                if (usercount == 1) {
+                    // search if_index
+                    for (mag_index = 0 ; mag_index < PMIP_MAX_MAGS; mag_index++) {
+                        if (g_tunnel_timer_table[mag_index].tunnel == tunnelP) break;
+                    }
+                    assert(mag_index < PMIP_MAX_MAGS);
+                    // Do not delete before MaxDelayBeforeDynamicTunnelingDelete
+                    pmip_tunnel_set_timer(&g_tunnel_timer_table[mag_index].remote, tunnelP, conf.MaxDelayBeforeDynamicTunnelingDelete);
+                } else {
+                    // this will only decrease the number of users for this tunnel
+                    res = tunnel_del(tunnelP, 0, 0);
+                }
+            } else {
+                dbg("Static Tunneling, tunnel %d is not deleted\n", tunnelP);
+            }
+        } else {
+            res = -1;
+        }
+    } else {
+        dbg("IP-in-IP tunneling is disabled, no tunnel is deleted\n");
+    }
+    return res;
+}
diff -Nur umip/src/pmip/pmip_tunnel.h umip-pmipv6/src/pmip/pmip_tunnel.h
--- umip/src/pmip/pmip_tunnel.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_tunnel.h	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,109 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_tunnel.h
+* \brief
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** \defgroup TUNNEL_Management TUNNELING
+ * \ingroup PMIP6D
+ *  PMIP Tunnel management (Creation/Deletion)
+ *  @{
+ */
+
+#ifndef __PMIP_TUNNEL_H__
+#    define __PMIP_TUNNEL_H__
+//-----------------------------------------------------------------------------
+#	ifdef PMIP_TUNNEL_C
+#		define private_pmip_tunnel(x) x
+#		define protected_pmip_tunnel(x) x
+#		define public_pmip_tunnel(x) x
+#	else
+#		ifdef PMIP
+#			define private_pmip_tunnel(x)
+#			define protected_pmip_tunnel(x) extern x
+#			define public_pmip_tunnel(x) extern x
+#		else
+#			define private_pmip_tunnel(x)
+#			define protected_pmip_tunnel(x)
+#			define public_pmip_tunnel(x) extern x
+#		endif
+#	endif
+//-----------------------------------------------------------------------------
+#   include "tqueue.h"
+#   include "pmip_consts.h"
+//-----------------------------------------------------------------------------
+#	include <netinet/ip6.h>
+//-----------------------------------------------------------------------------
+/*! \struct  mnid_hnp_t
+* \brief Data structure to store the association of a network prefix and a mobile interface identifier.
+*/typedef struct tunnel_timer {
+    struct timespec         lifetime;   /*!< \brief Delay for the tunnel before being deleted */
+    struct tq_elem          tqe;        /*!< \brief Timer queue entry for expire*/
+    int                     tunnel;     /*!< \brief Tunnel id*/
+    struct in6_addr         remote;     /*!< \brief Remote Address of the tunnel*/
+} __attribute__((__packed__))tunnel_timer_t;
+//-----------------------------------------------------------------------------
+/*! \var tunnel_timer_t g_tunnel_timer_table
+\brief Table of timers managing the deletion of tunnels.
+*/
+protected_pmip_tunnel(tunnel_timer_t g_tunnel_timer_table[PMIP_MAX_MAGS];)
+
+//-PROTOTYPES----------------------------------------------------------------------------
+
+/*! \fn int pmip_tunnel_get_timer_index(struct in6_addr  *remoteP)
+* \brief Return the index pointing the tunnel_timer_t struct in g_tunnel_timer_table which have the corresponding *remoteP struct in6_addr.
+* \param[in]  remoteP    Remote tunnel address.
+* \return   index found, else return the first free area in g_tunnel_timer_table.
+*/
+protected_pmip_tunnel(int pmip_tunnel_get_timer_index(struct in6_addr  *remoteP);)
+/*! \fn void pmip_tunnels_init(void)
+* \brief Initialize PMIP tunnels, and PMIP tunnels timers.
+* \return   Zero if success, else other values.
+*/
+protected_pmip_tunnel(int pmip_tunnels_init(void);)
+/*! \fn int pmip_tunnel_set_timer(struct in6_addr  *remoteP, struct timespec time_outP)
+* \brief Set a timer for deleting the tunnel associated with link.
+* \param[in]  remoteP    Remote tunnel address.
+* \param[in]  tunnelP    Tunnel id.
+* \param[in]  time_outP  time-out init value for the timer.
+* \return   Zero if success, else other values.
+*/
+protected_pmip_tunnel(int pmip_tunnel_set_timer(struct in6_addr  *remoteP, int tunnelP, struct timespec time_outP);)
+/*! \fn int pmip_tunnel_add(struct in6_addr *local, struct in6_addr *remote, int link)
+* \brief Create an IP6-IP6 tunnel between \a local and \a remote.
+* \param[in]  local  Local tunnel address.
+* \param[in]  remote Remote tunnel address.
+* \param[in]  linkP   Interface id.
+* \return    Returns interface index of the newly created tunnel, or negative on error.
+*/
+protected_pmip_tunnel(int pmip_tunnel_add(struct in6_addr *local, struct in6_addr *remote, int link);)
+/*! \fn int pmip_tunnel_del(int ifindex)
+* \brief Deletes a tunnel identified by ifindex.
+* \param[in]  tunnelP Tunnel id
+* \return   Returns negative if tunnel does not exist, otherwise zero.
+*/
+protected_pmip_tunnel(int pmip_tunnel_del(int tunnelP);)
+#endif
+/** @}*/
diff -Nur umip/src/pmip/pmip_types.h umip-pmipv6/src/pmip/pmip_types.h
--- umip/src/pmip/pmip_types.h	1970-01-01 01:00:00.000000000 +0100
+++ umip-pmipv6/src/pmip/pmip_types.h	2013-12-22 17:16:42.000000000 +0100
@@ -0,0 +1,218 @@
+/*
+ * This file is part of the PMIP, Proxy Mobile IPv6 for Linux.
+ *
+ * Authors: OPENAIR3 <openair_tech@eurecom.fr>
+ *
+ * Copyright 2010-2011 EURECOM (Sophia-Antipolis, FRANCE)
+ * 
+ * Proxy Mobile IPv6 (or PMIPv6, or PMIP) is a network-based mobility 
+ * management protocol standardized by IETF. It is a protocol for building 
+ * a common and access technology independent of mobile core networks, 
+ * accommodating various access technologies such as WiMAX, 3GPP, 3GPP2 
+ * and WLAN based access architectures. Proxy Mobile IPv6 is the only 
+ * network-based mobility management protocol standardized by IETF.
+ * 
+ * PMIP Proxy Mobile IPv6 for Linux has been built above MIPL free software;
+ * which it involves that it is under the same terms of GNU General Public
+ * License version 2. See MIPL terms condition if you need more details. 
+ */
+/*! \file pmip_types.h
+* \brief Describe all types for pmip
+* \author OpenAir3 Group
+* \date 12th of October 2010
+* \version 1.0
+* \company Eurecom
+* \project OpenAirInterface
+* \email: openair_tech@eurecom.fr
+*/
+
+/** @defgroup PACKETS TYPES
+ * @ingroup PMIP6D
+ *  PMIP Types
+ *  @{
+ */
+
+#ifndef __PMIP_TYPES_H__
+#    define __PMIP_TYPES_H__
+//---------------------------------------------------------------------------------------------------------------------
+#    include <linux/types.h>
+#    include <netinet/ip6mh.h>
+//---------------------------------------------------------------------------------------------------------------------
+#    include "mh.h"
+//---------------------------------------------------------------------------------------------------------------------
+
+/*
+* Mobility Option TLV data structure
+*New options defined for Proxy BU & BA
+*/
+/*! \struct  ip6_mh_opt_home_net_prefix_t
+* \brief Mobility Option TLV data structure: Home Network Prefix Option.
+*/
+struct ip6_mh_opt_home_net_prefix_t {   /*Home netowork prefix option */
+    __u8            ip6hnp_type;        /*!< \brief Type is  "Home Network Prefix Option" value.*/
+    __u8            ip6hnp_len;         /*!< \brief 8-bit unsigned integer indicating the length of the option in octets, excluding the type and length fields. This field MUST be set to 18.*/
+    __u8            ip6hnp_reserved;    /*!< \brief This 8-bit field is unused for now.  The value MUST be initialized to 0 by the sender and MUST be ignored by the receiver.*/
+    __u8            ip6hnp_prefix_len;  /*!< \brief 8-bit unsigned integer indicating the prefix length of the IPv6 prefix contained in the option.*/
+    struct in6_addr ip6hnp_prefix;      /*!< \brief A sixteen-byte field containing the mobile node's IPv6 Home Network Prefix.*/
+} __attribute__ ((__packed__));
+
+typedef struct ip6_mh_opt_home_net_prefix_t ip6_mh_opt_home_net_prefix_t;
+
+
+/*! \struct  ip6mnid_t
+* \brief Contain a mobile node identifier.
+*/
+typedef struct {
+    __u32       first;
+    __u32       second;
+} ip6mnid_t;
+
+
+/*! \struct  ip6ts_t
+* \brief Timestamp structure.
+*/
+typedef struct {
+    __u32       first;
+    __u32       second;
+} ip6ts_t;
+
+
+/*! \struct  ip6_mh_opt_mobile_node_identifier_t
+* \brief Mobility Option TLV data structure: Mobile Node Identifier Option (RFC4283).
+*/
+struct ip6_mh_opt_mobile_node_identifier_t {
+    __u8                ip6mnid_type;   /*!< \brief MN-ID-OPTION-TYPE has been assigned value 8 by the IANA. It is an  8-bit identifier of the type mobility option.*/
+    __u8                ip6mnid_len;    /*!< \brief 8-bit unsigned integer, representing the length in octets of the Subtype and Identifier fields.*/
+    __u8                ip6mnid_subtype;/*!< \brief Mobile interface identifier subtype .*/
+    ip6mnid_t           ip6mnid_id;     /*!< \brief Mobile interface identifier (NOT RFC4283).*/
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_mobile_node_identifier_t ip6_mh_opt_mobile_node_identifier_t;
+
+
+
+/*! \struct  ip6_mh_opt_mobile_node_link_layer_identifier_t
+* \brief Mobility Option TLV data structure: Mobile Node Link-Layer Identifier Option (RFC5213).
+*/
+struct ip6_mh_opt_mobile_node_link_layer_identifier_t {
+    __u8                ip6mnllid_type;     /*!< \brief MN-ID-OPTION-TYPE has been assigned value 8 by the IANA. It is an  8-bit identifier of the type mobility option.*/
+    __u8                ip6mnllid_len;      /*!< \brief 8-bit unsigned integer, representing the length in octets of the Subtype and Identifier fields.*/
+    __u16               ip6mnllid_reserved; /*!< \brief  16 bits reserved.*/
+    ip6mnid_t           ip6mnllid_lli;      /*!< \brief Mobile node link-layer identifier.*/
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_mobile_node_link_layer_identifier_t ip6_mh_opt_mobile_node_link_layer_identifier_t;
+
+
+/*! \struct  ip6_mh_opt_time_stamp_t
+* \brief Mobility Option TLV data structure: Timestamp Option (RFC5213).
+*/
+struct ip6_mh_opt_time_stamp_t {
+    __u8                ip6mots_type;   /*!< \brief Option type, value is 27.*/
+    __u8                ip6mots_len;    /*!< \brief 8-bit unsigned integer indicating the length in octets of the option, excluding the type and length fields. The value for this field MUST be set to 8.*/
+    ip6ts_t             time_stamp;     /*!< \brief A 64-bit unsigned integer field containing a timestamp.  The value indicates the number of seconds since January 1, 1970, 00:00 UTC, by using a fixed point format.  In this format, the integer number of seconds is contained in the first 48 bits of the field, and the remaining 16 bits indicate the number of 1/65536 fractions of a second.*/
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_time_stamp_t ip6_mh_opt_time_stamp_t;
+
+
+/*! \struct  ip6_mh_link_local_add_t
+* \brief Mobility Option TLV data structure: Link-local Address Option (RFC5213).
+*/
+struct ip6_mh_opt_link_local_address_t {
+    __u8                ip6link_type;   /*!< \brief Option type, value is 26.*/
+    __u8                ip6link_len;    /*!< \brief 8-bit unsigned integer indicating the length of the option in octets, excluding the type and length fields. This field MUST be set to 16.*/
+    struct in6_addr     ip6link_addr;   /*!< \brief A sixteen-byte field containing the link-local address.*/
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_link_local_address_t ip6_mh_opt_link_local_address_t;
+
+/*! \struct  ip6_mh_handoff_indicator_t
+* \brief Mobility Option TLV data structure: Handoff Indicator Option (RFC5213).
+*/
+struct ip6_mh_opt_handoff_indicator_t {
+    __u8                ip6hi_type;     /*!< \brief Option type, value is 23.*/
+    __u8                ip6hi_len;      /*!< \brief 8-bit unsigned integer indicating the length of the option in octets, excluding the type and length fields. This field MUST be set to 2.*/
+    __u8                ip6hi_reserved; /*!< \brief Field unused for now (RFC5213), must be set to 0.*/
+    __u8                ip6hi_hi;       /*!< \brief A 8-bit field containing the handoff indicator.*/
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_handoff_indicator_t ip6_mh_opt_handoff_indicator_t;
+
+/*! \struct  ip6_mh_handoff_indicator_t
+* \brief Mobility Option TLV data structure: Handoff Indicator Option (RFC5213).
+*/
+struct ip6_mh_opt_access_technology_type_t {
+    __u8                ip6att_type;     /*!< \brief Option type, value is 23.*/
+    __u8                ip6att_len;      /*!< \brief 8-bit unsigned integer indicating the length of the option in octets, excluding the type and length fields. This field MUST be set to 2.*/
+    __u8                ip6att_reserved; /*!< \brief Field unused for now (RFC5213), must be set to 0.*/
+    __u8                ip6att_att;      /*!< \brief A 8-bit field containing the access technology type.*/
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_access_technology_type_t ip6_mh_opt_access_technology_type_t;
+
+
+// ******** Extended options for cluster based architecture & Route optimiztion ***********
+struct ip6_mh_opt_dst_mn_addr_t {
+    __u8                ip6dma_type;
+    __u8                ip6dma_len;
+    struct in6_addr     dst_mn_addr;    /* Destination MN Address */
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_dst_mn_addr_t ip6_mh_opt_dst_mn_addr_t;
+
+
+struct ip6_mh_opt_serv_mag_addr_t {
+    __u8                ip6sma_type;
+    __u8                ip6sma_len;
+    struct in6_addr     serv_mag_addr;  /* Serving MAG Address of the destination */
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_serv_mag_addr_t ip6_mh_opt_serv_mag_addr_t;
+
+
+struct ip6_mh_opt_serv_lma_addr_t {
+    __u8                ip6sla_type;
+    __u8                ip6sla_len;
+    struct in6_addr     serv_lma_addr;  /* Serving LMA Address of the destination */
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_serv_lma_addr_t ip6_mh_opt_serv_lma_addr_t;
+
+
+struct ip6_mh_opt_src_mn_addr {
+    __u8                ip6sma_type;
+    __u8                ip6sma_len;
+    struct in6_addr     src_mn_addr;    /* Source MN Address */
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_src_mn_addr_t ip6_mh_opt_src_mn_addr_t;
+
+
+struct ip6_mh_opt_src_mag_addr_t {
+    __u8                ip6sma_type;
+    __u8                ip6sma_len;
+    struct in6_addr     src_mag_addr;   /* Source MAG Address */
+} __attribute__ ((__packed__));
+typedef struct ip6_mh_opt_src_mag_addr_t ip6_mh_opt_src_mag_addr_t;
+
+/*! \struct  msg_info_t
+* \brief Meta structure that can store all usefull information of any PMIP message.
+*/
+typedef struct msg_info_t {
+    struct in6_addr             src;                /*!< \brief Source address of the message.*/
+    struct in6_addr             dst;                /*!< \brief Destination address of the message.*/
+    struct in6_addr_bundle      addrs;              /*!< \brief Tuple composed of src and dst address.*/
+    int                         iif;                /*!< \brief Interface identifier.*/
+    uint32_t                    msg_event;          /*!< \brief Type of event received: hasDEREG hasWLCCP hasRS hasNA hasNS hasPBU hasPBA hasPBREQ hasPBRES */
+    struct in6_addr             mn_iid;             /*!< \brief Mobile node IID.*/
+    struct in6_addr             mn_addr;            /*!< \brief Full mobile node address */
+    struct in6_addr             mn_prefix;          /*!< \brief Network Address Prefix for MN */
+    struct in6_addr             mn_serv_mag_addr;   /*!< \brief Serving MAG Address */
+    struct in6_addr             mn_serv_lma_addr;   /*!< \brief Serving LMA Address */
+    struct in6_addr             mn_link_local_addr; /*!< \brief Link Local Address  for mobile node */
+    struct timespec             addtime;            /*!< \brief When was the binding added or modified */
+    struct timespec             lifetime;           /*!< \brief Lifetime sent in this BU, in seconds */
+    uint16_t                    seqno;              /*!< \brief Sequence number of the message */
+    uint16_t                    PBU_flags;          /*!< \brief PBU flags */
+    uint8_t                     PBA_flags;          /*!< \brief PBA flags */
+    ip6ts_t                     timestamp;          /*!< \brief Timestamp */
+    struct in6_addr             src_mag_addr;       /*!< \brief Route optimization or flow control: Source MAG Address */
+    struct in6_addr             src_mn_addr;        /*!< \brief Route optimization or flow control: Source MN Address */
+    struct in6_addr             na_target;          /*!< \brief Route optimization or flow control: Neighbour advertisement target*/
+    struct in6_addr             ns_target;          /*!< \brief Route optimization or flow control: Neighbour solicitation target*/
+    int                         is_dad;             /*!< \brief Route optimization or flow control: is NS used for DAD process?*/
+    int                         hoplimit;           /*!< \brief Route optimization or flow control: Hop limit*/
+} msg_info_t;
+#endif
+/*@}*/
diff -Nur umip/src/rtnl.h umip-pmipv6/src/rtnl.h
--- umip/src/rtnl.h	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/rtnl.h	2013-12-22 17:16:42.000000000 +0100
@@ -12,6 +12,11 @@
 #define RT6_TABLE_MIP6 252
 #define RT6_TABLE_MAIN 254
 
+// Defined for Proxy MIPv6//////////////////
+#define RT6_TABLE_PMIP 200
+#define IP6_RULE_PRIO_PMIP6_FWD   1000
+///////////////////////////////////////////
+
 #define IP6_RT_PRIO_MIP6_OUT 128
 #define IP6_RT_PRIO_MIP6_FWD 192
 #define IP6_RT_PRIO_ADDRCONF 256
diff -Nur umip/src/scan.l umip-pmipv6/src/scan.l
--- umip/src/scan.l	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/scan.l	2013-12-22 17:35:17.000000000 +0100
@@ -35,6 +35,7 @@
 #include <arpa/inet.h>
 #include <glob.h>
 #include <string.h>
+#include <stdio.h>
 #include "gram.h"
 
 #define YY_NO_INPUT 1
@@ -93,6 +94,9 @@
 addr2		{hexdec}{1,4}(":"{hexdec}{1,4}){0,6}"::"
 addr3		({hexdec}{1,4}":"){7}{hexdec}{1,4}
 addr		({addr1}|{addr2}|{addr3}|"::")
+macaddr1	({hexdec}{1,2}":"){5}{hexdec}{1,2}
+macaddr2	({hexdec}{1,2}":"{hexdec}{1,2}":"{hexdec}{1,2}":"{hexdec}{1,2}":"{hexdec}{1,2}":"{hexdec}{1,2})
+macaddr		({macaddr1}|{macaddr2})
 true		(enabled|allow|true)
 false		(disabled|deny|block|false)
 %%
@@ -230,6 +234,8 @@
 HA				{ return MIP6HA; }
 CN				{ return MIP6CN; }
 MN				{ return MIP6MN; }
+LMA				{ return MIP6LMA; }
+MAG				{ return MIP6MAG; }
 DebugLevel			{ return DEBUGLEVEL; }
 DebugLogFile			{ return DEBUGLOGFILE; }
 DoRouteOptimizationCN		{ return DOROUTEOPTIMIZATIONCN; }
@@ -296,6 +302,37 @@
 HaServedPrefix       	       	{ return HASERVEDPREFIX; }
 HomePrefix     			{ return HOMEPREFIX; }
 MobRtrUseExplicitMode    	{ return MOBRTRUSEEXPLICITMODE; }
+RFC5213TimestampBasedApproachInUse	{ return RFC5213TIMESTAMPBASEDAPPROACHINUSE; }
+RFC5213MobileNodeGeneratedTimestampInUse	{ return RFC5213MOBILENODEGENERATEDTIMESTAMPINUSE; }
+RFC5213FixedMAGLinkLocalAddressOnAllAccessLinks	{ return RFC5213FIXEDMAGLINKLOCALADDRESSONALLACCESSLINKS; }
+RFC5213FixedMAGLinkLayerAddressOnAllAccessLinks	{ return RFC5213FIXEDMAGLINKLAYERADDRESSONALLACCESSLINKS; }
+RFC5213MinDelayBeforeBCEDelete	{ return RFC5213MINDELAYBEFOREBCEDELETE; }
+RFC5213MaxDelayBeforeNewBCEAssign	{ return RFC5213MAXDELAYBEFORENEWBCEASSIGN; }
+RFC5213TimestampValidityWindow	{ return RFC5213TIMESTAMPVALIDITYWINDOW; }
+RFC5213EnableMAGLocalRouting	{ return RFC5213ENABLEMAGLOCALROUTING; }
+LmaPmipNetworkAddress		{ return LMAPMIPNETWORKADDRESS; }
+LmaPmipNetworkDevice		{ return LMAPMIPNETWORKDEVICE; }
+LmaCoreNetworkAddress		{ return LMACORENETWORKADDRESS; }
+LmaCoreNetworkDevice		{ return LMACORENETWORKDEVICE; }
+MagAddressIngress		{ return MAGADDRESSINGRESS; }
+MagAddressEgress		{ return MAGADDRESSEGRESS; }
+MagDeviceIngress		{ return MAGDEVICEINGRESS; }
+MagDeviceEgress			{ return MAGDEVICEEGRESS; }
+OurAddress			{ return OURADDRESS; }
+HomeNetworkPrefix		{ return HOMENETWORKPREFIX; }
+PBULifeTime			{ return PBULIFETIME; }
+PBALifeTime			{ return PBALIFETIME; }
+RetransmissionTimeOut		{ return RETRANSMISSIONTIMEOUT; }
+MaxMessageRetransmissions	{ return MAXMESSAGERETRANSMISSIONS; }
+TunnelingEnabled		{ return TUNNELINGENABLED; }
+DynamicTunnelingEnabled		{ return DYNAMICTUNNELINGENABLED; }
+MaxDelayBeforeDynamicTunnelingDelete	{ return MAXDELAYBEFOREDYNAMICTUNNELINGDELETE; }
+ProxyMipLma			{ return PROXYMIPLMA; }
+ProxyMipMag			{ return PROXYMIPMAG; }
+RadiusPassword			{ return RADIUSPASSWORD; }
+RadiusClientConfigFile		{ return RADIUSCLIENTCONFIGFILE; }
+PcapSyslogAssociationGrepString	{ return PCAPSYSLOGASSOCIATIONGREPSTRING; }
+PcapSyslogDeAssociationGrepString	{ return PCAPSYSLOGDEASSOCIATIONGREPSTRING; }
 internal			{ return INTERNAL; }
 
 {addr}		{
@@ -309,6 +346,48 @@
 			return ADDR;
 		}
 
+{macaddr}	{
+			unsigned int i;
+                        char hex_digits [3];
+                        hex_digits[2] = 0;
+                        yylval.macaddr.s6_addr[0]  = 0;
+                        yylval.macaddr.s6_addr[1]  = 0;
+                        yylval.macaddr.s6_addr[2]  = 0;
+                        yylval.macaddr.s6_addr[3]  = 0;
+                        yylval.macaddr.s6_addr[4]  = 0;
+                        yylval.macaddr.s6_addr[5]  = 0;
+                        yylval.macaddr.s6_addr[6]  = 0;
+                        yylval.macaddr.s6_addr[7]  = 0;
+                        yylval.macaddr.s6_addr[8]  = 0;
+                        yylval.macaddr.s6_addr[9]  = 0;
+                        hex_digits[0] = yytext[0];
+                        hex_digits[1] = yytext[1];
+                        sscanf(hex_digits, "%02x", &i); 
+                        yylval.macaddr.s6_addr[10] = i & 0x000000FF; 
+                        hex_digits[0] = yytext[3];
+                        hex_digits[1] = yytext[4];
+                        sscanf(hex_digits, "%02x", &i); 
+                        yylval.macaddr.s6_addr[11] = i & 0x000000FF; 
+                        hex_digits[0] = yytext[6];
+                        hex_digits[1] = yytext[7];
+                        sscanf(hex_digits, "%02x", &i); 
+                        yylval.macaddr.s6_addr[12] = i & 0x000000FF; 
+                        hex_digits[0] = yytext[9];
+                        hex_digits[1] = yytext[10];
+                        sscanf(hex_digits, "%02x", &i); 
+                        yylval.macaddr.s6_addr[13] = i & 0x000000FF; 
+                        hex_digits[0] = yytext[12];
+                        hex_digits[1] = yytext[13];
+                        sscanf(hex_digits, "%02x", &i); 
+                        yylval.macaddr.s6_addr[14] = i & 0x000000FF; 
+                        hex_digits[0] = yytext[15];
+                        hex_digits[1] = yytext[16];
+                        sscanf(hex_digits, "%02x", &i); 
+                        yylval.macaddr.s6_addr[15] = i & 0x000000FF; 
+                        printf("scan.l: %02x:%02x:%02x:%02x:%02x:%02x\n", yylval.macaddr.s6_addr[10], yylval.macaddr.s6_addr[11],yylval.macaddr.s6_addr[12],yylval.macaddr.s6_addr[13],yylval.macaddr.s6_addr[14],yylval.macaddr.s6_addr[15]);
+			return MACADDR;
+		}
+
 {number}	{ yylval.num = atoi(yytext); return NUMBER; }
 
 {decimal}	{ yylval.dec = atof(yytext); return DECIMAL; }
diff -Nur umip/src/tunnelctl.c umip-pmipv6/src/tunnelctl.c
--- umip/src/tunnelctl.c	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/tunnelctl.c	2013-12-22 17:16:42.000000000 +0100
@@ -461,3 +461,14 @@
 	pthread_mutex_unlock(&tnl_lock);
 	close(tnl_fd);
 }
+
+int tunnel_getusers(int tun_index)
+{
+    struct mip6_tnl *tnl;
+    int usercount = -1;
+    pthread_mutex_lock(&tnl_lock);
+    if ((tnl = get_tnl(tun_index)) != NULL) usercount = tnl->users;
+    pthread_mutex_unlock(&tnl_lock);
+    return usercount;
+}
+
diff -Nur umip/src/tunnelctl.h umip-pmipv6/src/tunnelctl.h
--- umip/src/tunnelctl.h	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/tunnelctl.h	2013-12-22 17:16:42.000000000 +0100
@@ -33,4 +33,5 @@
 
 void tunnelctl_cleanup(void);
 
+int tunnel_getusers(int tun_index);
 #endif
diff -Nur umip/src/vt.c umip-pmipv6/src/vt.c
--- umip/src/vt.c	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/vt.c	2013-12-22 17:16:42.000000000 +0100
@@ -66,6 +66,7 @@
 #include "mpdisc_mn.h"
 #include "mpdisc_ha.h"
 #include "statistics.h"
+#include "pmip_cache.h"
 
 #define VT_PKT_BUFLEN		(8192)
 #define VT_REPLY_BUFLEN		(LINE_MAX)
@@ -823,6 +824,125 @@
 	return 0;
 }
 
+//////////////////////////////////////////////////
+//Defined for PMIP///////////////////////////////
+/////////////////////////////////////////////////
+struct pmip_cache_vt_arg {
+    const struct vt_handle *vh;
+};
+
+static int pmip_cache_vt_dump(void *data, void *arg)
+{
+    pmip_entry_t *bce = (pmip_entry_t *)data;
+    struct pmip_cache_vt_arg *bva = (struct pmip_cache_vt_arg *)arg;
+    const struct vt_handle *vh = bva->vh;
+    struct timespec ts_now;
+
+    tsclear(ts_now);
+
+    fprintf_bl(vh, "peer_addr %x:%x:%x:%x:%x:%x:%x:%x",
+           NIP6ADDR(&bce->mn_addr));
+           //NIP6ADDR(&bce->mn_suffix));
+
+
+    fprintf_b(vh, " status %s",
+          (bce->type == BCE_PMIP) ? "PMIP" :
+          (bce->type == BCE_TEMP) ? "TEMP" :
+          (bce->type == BCE_NO_ENTRY) ? "EMPTY" :
+          "(unknown)");
+
+    fprintf(vh->vh_stream, "\n");
+
+    if (is_ha()) {
+        fprintf(vh->vh_stream, " Serv_MAG_addr %x:%x:%x:%x:%x:%x:%x:%x",
+            NIP6ADDR(&bce->mn_serv_mag_addr));
+    }
+
+    if (is_mag()) {
+        fprintf(vh->vh_stream, " LMA_addr %x:%x:%x:%x:%x:%x:%x:%x",
+            NIP6ADDR(&bce->mn_serv_lma_addr));
+    }
+
+    fprintf(vh->vh_stream, " local %x:%x:%x:%x:%x:%x:%x:%x",
+        NIP6ADDR(&bce->our_addr));
+
+    if (vh->vh_opt.verbose == VT_BOOL_TRUE) {
+        char buf[IF_NAMESIZE + 1];
+        char *dev;
+
+        if (bce->tunnel) {
+            fprintf(vh->vh_stream, " tunnel %d ",bce->tunnel);
+
+            dev = if_indextoname(bce->tunnel, buf);
+            if (!dev || strlen(dev) == 0)
+                fprintf(vh->vh_stream, "(%d)", bce->tunnel);
+            else
+                fprintf(vh->vh_stream, "%s", dev);
+        }
+        if (bce->link) {
+            fprintf(vh->vh_stream, " link ");
+
+            dev = if_indextoname(bce->link, buf);
+            if (!dev || strlen(dev) == 0)
+                fprintf(vh->vh_stream, "(%d)", bce->link);
+            else
+                fprintf(vh->vh_stream, "%s", dev);
+        }
+    }
+
+    fprintf(vh->vh_stream, "\n");
+
+    fprintf(vh->vh_stream, " lifetime ");
+
+    if (clock_gettime(CLOCK_REALTIME, &ts_now) != 0)
+        fprintf(vh->vh_stream, "(error)");
+    else {
+        if (tsafter(ts_now, bce->add_time))
+            fprintf(vh->vh_stream, "(broken)");
+        else {
+            struct timespec ts;
+
+            tssub(ts_now, bce->add_time, ts);
+            /* "ts" is now time how log it alives */
+            if (tsafter(bce->lifetime, ts)) {
+                tssub(ts, bce->lifetime, ts);
+                fprintf(vh->vh_stream, "-%ld", ts.tv_sec);
+            } else {
+                tssub(bce->lifetime, ts, ts);
+                fprintf(vh->vh_stream, "%ld", ts.tv_sec);
+            }
+        }
+    }
+    fprintf(vh->vh_stream, " / %ld", bce->lifetime.tv_sec);
+
+    fprintf(vh->vh_stream, " seq %u", bce->seqno_out);
+
+    fprintf(vh->vh_stream, "\n");
+
+    return 0;
+}
+
+static int pmip_cache_vt_cmd_pbc(const struct vt_handle *vh, const char *str)
+{
+    struct pmip_cache_vt_arg bva;
+    bva.vh = vh;
+
+    if (strlen(str) > 0) {
+        fprintf(vh->vh_stream, "unknown args\n");
+        return 0;
+    }
+
+    pmip_cache_iterate(pmip_cache_vt_dump, &bva);
+    return 0;
+}
+
+static struct vt_cmd_entry vt_cmd_pbc = {
+    .cmd = "pmip",
+    .parser = pmip_cache_vt_cmd_pbc,
+};
+////////////////////////////////////////////////////////////
+
+
 static int vt_str_to_uint32(const struct vt_handle *vh, const char *str,
 			    uint32_t *val)
 {
@@ -1780,6 +1900,18 @@
 	return 0;
 }
 
+//Defined for PMIP////////////////
+int vt_pbc_init(void)
+{
+    int ret;
+    ret = vt_cmd_add_root(&vt_cmd_pbc);
+    if (ret < 0)
+    return ret;
+
+    return 0;
+}
+//////////////////////////////////
+
 int vt_init(void)
 {
 	if (pthread_rwlock_init(&vt_lock, NULL))
diff -Nur umip/src/vt.h umip-pmipv6/src/vt.h
--- umip/src/vt.h	2013-12-22 18:47:25.000000000 +0100
+++ umip-pmipv6/src/vt.h	2013-12-22 17:16:42.000000000 +0100
@@ -77,6 +77,8 @@
 
 int vt_bc_init(void);
 
+int vt_pbc_init(void);
+
 int vt_init(void);
 void vt_fini(void);
 
